<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋龙宽|个人博客</title>
  
  
  <link href="https://songlongkuan.com/atom.xml" rel="self"/>
  
  <link href="https://songlongkuan.com/"/>
  <updated>2021-01-07T01:51:50.469Z</updated>
  <id>https://songlongkuan.com/</id>
  
  <author>
    <name>宋龙宽|个人博客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LRU缓存淘汰策略</title>
    <link href="https://songlongkuan.com/2020/11/29/algorithm_lru_cache/"/>
    <id>https://songlongkuan.com/2020/11/29/algorithm_lru_cache/</id>
    <published>2020-11-29T02:56:00.000Z</published>
    <updated>2021-01-07T01:51:50.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LRU淘汰算法主要目的：在已知限制大小的容器中，当容器满了的情况还有元素放入容器时，移出最久未使用元素。</p><ul><li>LRU淘汰算法可以用链表来实现</li><li>当一个新元素放入容器，将会插入到链表的表头</li><li>当从容器中查询某一个元素，会将链表中的该元素删除，再重新插入到链表的表头</li><li>而那些旧元素且没有查询操作的元素就会沉淀在链表的底部，当容器满了的情况会逐一删除。</li></ul><a id="more"></a><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>假设现在设定一个容器只能最大存储5个元素，已知存储了”张三-&gt;李四-&gt;王五-&gt;赵六-&gt;麻子”。</p><p>链表头为张三，链表尾为麻子，如下图所示。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_1_1606617279798.png" alt="lru_1"></p><h4 id="插入新元素"><a href="#插入新元素" class="headerlink" title="插入新元素"></a>插入新元素</h4><p>假设现在又要放入一个新元素：”小二”，应将”小二” 插入到张三的前面，而麻子则删除，并且尾部指针指向到赵六。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_2_1606617531882.png" alt="lru_2"></p><h4 id="查询旧元素"><a href="#查询旧元素" class="headerlink" title="查询旧元素"></a>查询旧元素</h4><p>假设现在要从容器中查询 “李四”，因为”李四”已经存在于链表中所以应先从链表删除”李四”，再将”李四”插入到链表的头部，并将链表的头部指针指向到”李四”。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_3_1606617851297.png" alt="lru_3"></p><h2 id="Java的代码实现"><a href="#Java的代码实现" class="headerlink" title="Java的代码实现"></a>Java的代码实现</h2><h4 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU缓存淘汰策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限制大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limitSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru已存储大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lruSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, LRUCacheValue&lt;K, V&gt;&gt; cache;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru-指针-头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LRUCacheNode&lt;K&gt; head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru-指针-尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LRUCacheNode&lt;K&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> limitSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limitSize = limitSize;</span><br><span class="line">        <span class="comment">//初始化HashMap的大小</span></span><br><span class="line">        <span class="keyword">int</span> initialCapacity = (<span class="keyword">int</span>) Math.round((<span class="keyword">float</span>) limitSize / <span class="number">0.75</span>);</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="comment">//如果当前lru已经满了的話  删除最后一个</span></span><br><span class="line">            K removeLruTailKey = removeLruTail();</span><br><span class="line">            cache.remove(removeLruTailKey);</span><br><span class="line">            lruSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lruCacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个key在lru缓存中是存在的話  先进行删除 remove操作</span></span><br><span class="line">            removeLruNode(lruCacheValue.node);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key, <span class="keyword">new</span> LRUCacheValue&lt;K, V&gt;(value, insertLruHead(key)));</span><br><span class="line">        lruSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lruCacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        removeLruNode(lruCacheValue.node);</span><br><span class="line">        <span class="comment">//压入链表节点</span></span><br><span class="line">        lruCacheValue.node = insertLruHead(key);</span><br><span class="line">        <span class="keyword">return</span> lruCacheValue.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.tail == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否满了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lruSize &gt;= limitSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历打印所有lru链表中的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LRUCacheNode&lt;K&gt; curr = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span> + curr.key);</span><br><span class="line">        &#125; <span class="keyword">while</span> ((curr = curr.next) != <span class="keyword">null</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;lrusize:&quot;</span> + lruSize + <span class="string">&quot; cacheCount:&quot;</span> + cache.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入到lru-头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LRUCacheNode&lt;K&gt; <span class="title">insertLruHead</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        LRUCacheNode&lt;K&gt; lruCacheNode = <span class="keyword">new</span> LRUCacheNode&lt;&gt;(key);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = lruCacheNode;</span><br><span class="line">            <span class="keyword">this</span>.tail = lruCacheNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lruCacheNode.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head.prew = lruCacheNode;</span><br><span class="line">            <span class="keyword">this</span>.head = lruCacheNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lruCacheNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除lru最后一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> K <span class="title">removeLruTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暂存key</span></span><br><span class="line">        K key = <span class="keyword">this</span>.tail.key;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            <span class="comment">//只有一个节点</span></span><br><span class="line">            removeAll();</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tail.prew != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tail.prew.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点指向到尾节点的prew节点</span></span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">this</span>.tail.prew;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除全部链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定节点的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLruNode</span><span class="params">(LRUCacheNode&lt;K&gt; cacheNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.head &amp;&amp; cacheNode == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            removeAll();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheNode.next.prew = cacheNode.prew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode.prew != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheNode.prew.next = cacheNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            <span class="comment">//要删除的是head指针</span></span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            <span class="comment">//要删除的是tail指针</span></span><br><span class="line">            <span class="keyword">this</span>.tail = cacheNode.prew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheValue</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; node;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheValue</span><span class="params">(V value, LRUCacheNode&lt;K&gt; node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheNode</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; prew;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheNode</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>先检查是否容器已满，如果满了的情况删除最后一个链表的元素，并且从map集合中remove。</p><p>如果这个key已经存在于lru链表中，将lru中的该元素删除。</p><p>插入key到链表的头部</p><p>最后把数据放入到map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        <span class="comment">//如果当前lru已经满了的話  删除最后一个</span></span><br><span class="line">        K removeLruTailKey = removeLruTail();</span><br><span class="line">        cache.remove(removeLruTailKey);</span><br><span class="line">        lruSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lruCacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果这个key在lru缓存中是存在的話  先进行删除 remove操作</span></span><br><span class="line">        removeLruNode(lruCacheValue.node);</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(key, <span class="keyword">new</span> LRUCacheValue&lt;K, V&gt;(value, insertLruHead(key)));</span><br><span class="line">    lruSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>如果key存在于map中，则删除这个key在链表中的元素。</p><p>将这个key重新插入到链表的头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lruCacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    removeLruNode(lruCacheValue.node);</span><br><span class="line">    <span class="comment">//压入链表节点</span></span><br><span class="line">    lruCacheValue.node = insertLruHead(key);</span><br><span class="line">    <span class="keyword">return</span> lruCacheValue.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>循环放入1万个数字，且是自增的数字，每次放入后都查询一下key为0、1的元素。</p><p>理论上，因为每次插入数据都会查询0、1，所以最后链表肯定1、0在最前面。再往后就是99999-99992</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; lruCache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            lruCache.put(i, String.valueOf(i));</span><br><span class="line">            lruCache.get(<span class="number">0</span>);</span><br><span class="line">            lruCache.get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lruCache.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果输出如下- 符合理论预期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key:1</span><br><span class="line">key:0</span><br><span class="line">key:99999</span><br><span class="line">key:99998</span><br><span class="line">key:99997</span><br><span class="line">key:99996</span><br><span class="line">key:99995</span><br><span class="line">key:99994</span><br><span class="line">key:99993</span><br><span class="line">key:99992</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LRU淘汰算法主要目的：在已知限制大小的容器中，当容器满了的情况还有元素放入容器时，移出最久未使用元素。</summary>
    
    
    
    <category term="算法" scheme="https://songlongkuan.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LRU" scheme="https://songlongkuan.com/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="https://songlongkuan.com/2020/11/26/data_structure_stack/"/>
    <id>https://songlongkuan.com/2020/11/26/data_structure_stack/</id>
    <published>2020-11-26T13:27:00.000Z</published>
    <updated>2021-01-07T01:49:41.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈结构是遵循先进后出，后进先出的 First In Last Out（FILO）。</p><p>而实现栈结构的方式有数组、链表。</p><ul><li><p>数组实现</p><ul><li>效率高，因为数组是一块连续的空间，CPU加载内存时会加载一片连续的内存。</li><li>需要对数组进行动态的扩容、缩容。</li></ul></li><li><p>链表实现</p><ul><li>效率相对数组要低，因为它的对象内存地址不连续。</li><li>内存空间占用更大，因为每个节点都需要包含next指针。</li><li>理论上可以无限压入数据到栈，但是可能会溢出。</li><li>不需要考虑扩容、缩容、下标越界。</li></ul><a id="more"></a></li></ul><p><img src="https://oss.pencilso.cn/enclosure/stack_1_1606395677610.png" alt="stack_1"></p><p>大多数场景下还是用数组实现的栈结构更多，因为它的性能更高。</p><p>先创建一个接口，再由子类去实现它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Item <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="栈-数组实现"><a href="#栈-数组实现" class="headerlink" title="栈-数组实现"></a>栈-数组实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cap = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Item table[] = (Item[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        judgeSize();</span><br><span class="line">        <span class="keyword">this</span>.table[size++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        judgeSize();</span><br><span class="line">        Item item = <span class="keyword">this</span>.table[--size];</span><br><span class="line">        <span class="keyword">this</span>.table[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验数组是否要扩容 或者缩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">judgeSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt;= <span class="keyword">this</span>.table.length) &#123;</span><br><span class="line">            <span class="comment">//扩容两倍</span></span><br><span class="line">            resize(<span class="keyword">this</span>.table.length * <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt;= cap &amp;&amp; (<span class="keyword">this</span>.table.length / <span class="number">2</span>) &gt; size) &#123;</span><br><span class="line">            <span class="comment">//如果当前元素数量大于cap 并且小于数组长度的一半  则对数组缩容一半</span></span><br><span class="line">            resize(<span class="keyword">this</span>.table.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> resize)</span> </span>&#123;</span><br><span class="line">        Item[] tempTable = (Item[]) <span class="keyword">new</span> Object[resize];</span><br><span class="line">        <span class="comment">//克隆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            tempTable[i] = <span class="keyword">this</span>.table[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.table = tempTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack&lt;String&gt; arrayStack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">        arrayStack.push(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">----- 输出结果如下所示</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="栈-链表实现"><a href="#栈-链表实现" class="headerlink" title="栈-链表实现"></a>栈-链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        LinkedStackNode&lt;Item&gt; newNode = <span class="keyword">new</span> LinkedStackNode&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.prew = tail;</span><br><span class="line">            tail.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedStackNode&lt;Item&gt; tempTail = <span class="keyword">this</span>.tail;</span><br><span class="line">        <span class="keyword">if</span> (tempTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">this</span>.tail = tempTail.prew;</span><br><span class="line">            <span class="keyword">return</span> tempTail.getData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStackNode</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedStackNode</span><span class="params">(Item data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Item data;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; prew;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; arrayStack = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        arrayStack.push(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">----- 输出结果如下所示</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java数组、链表实现实现 数据结构-栈</summary>
    
    
    
    <category term="数据结构" scheme="https://songlongkuan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈" scheme="https://songlongkuan.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Java之ThreadLocal</title>
    <link href="https://songlongkuan.com/2020/09/12/java_threadlocal/"/>
    <id>https://songlongkuan.com/2020/09/12/java_threadlocal/</id>
    <published>2020-09-12T07:30:16.000Z</published>
    <updated>2021-01-31T11:42:30.271Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</p><a id="more"></a><h2 id="ThreadLocal的简单应用"><a href="#ThreadLocal的简单应用" class="headerlink" title="ThreadLocal的简单应用"></a>ThreadLocal的简单应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread-<span class="number">1</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">1</span> 执行前数后:张三</span><br><span class="line">thread-<span class="number">2</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">2</span> 执行前数后:李四</span><br></pre></td></tr></table></figure><p>由此可以得出结论，threadLocal是线程之间隔离的数据存储方式。</p><h2 id="ThreadLocal-的问题"><a href="#ThreadLocal-的问题" class="headerlink" title="ThreadLocal 的问题"></a>ThreadLocal 的问题</h2><p>ThreadLocal在线程池中应用的话是会产生问题的，我们知道线程池它是会对线程进行重复利用，也就是说可能放几个任务到线程池中执行最后都是由一个KLT线程去运行的。</p><p>线程池+ThreadLocal问题重现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：张三</span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><p>可以观察到，runnable2执行的时候拿到了runnable1置入的”张三”，这时候已经不是逻辑上的隔离了，因为线程复用导致ThreadLocal里面的数据没有释放，从而导致下一次在线程池运行任务的时候，获取到的数据还是上一个线程置入的数据。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案-1"></a>解决方案-1</h2><p>第一种解决方案，就是在线程执行之前清空一下ThreadLocal，至于线程执行结束的话，系统会自动清理。</p><p>改造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">   <span class="comment">//设置为nulll</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">    <span class="comment">//设置为null</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行输出结果如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案-2"></a>解决方案-2</h2><p>第二种解决方案的话，主要是从线程池入手，线程池有一个执行线程任务前的拦截方法，可以在Runnable执行之前执行。</p><p>再次改造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>)) &#123;</span><br><span class="line">          <span class="comment">//重写beforeExecute方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">                <span class="comment">//统一把ThreadLocal设置为null</span></span><br><span class="line">                threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal实现的原理"><a href="#ThreadLocal实现的原理" class="headerlink" title="ThreadLocal实现的原理"></a>ThreadLocal实现的原理</h2><h3 id="ThreadLocal-的set方法"><a href="#ThreadLocal-的set方法" class="headerlink" title="ThreadLocal 的set方法"></a>ThreadLocal 的set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//如果map已创建  则置入数据 </span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//如果map还未创建 则创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的createMap方法"><a href="#ThreadLocal的createMap方法" class="headerlink" title="ThreadLocal的createMap方法"></a>ThreadLocal的createMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实例化一个ThreadLocalMap对象 并且赋值到thread.threadLocals字段里面</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的getMap方法"><a href="#ThreadLocal的getMap方法" class="headerlink" title="ThreadLocal的getMap方法"></a>ThreadLocal的getMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//直接获取的thread里面的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thread中的threadLocals字段"><a href="#Thread中的threadLocals字段" class="headerlink" title="Thread中的threadLocals字段"></a>Thread中的threadLocals字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal总结"><a href="#ThreadLocal总结" class="headerlink" title="ThreadLocal总结"></a>ThreadLocal总结</h3><p>ThreadLocal其实就是封装了调用Thread对象中ThreadLocalMap类型的threadlocals变量的过程。</p><p>至于ThreadLocalMap其实就是一个简化的hashmap。</p><p>如果说程序的调用链路比较长，假设一个请求需要调用10个方法，而只有第一个方法和最后一个方法需要一个”userId” 数据，如果我们给10个方法都加上”userId” 参数进行传递固然是可以解决，但是冗余了代码，而使用ThreadLocal后只需要在第一个和最后一个方法种调用ThreadLocal即可。</p><p>再比如说Mybatis的分页插件 PageHelper.startPage就是通过ThreadLocal把page参数放到了ThreadLocal中。</p><h2 id="ThreadLocal在线程间传递的问题"><a href="#ThreadLocal在线程间传递的问题" class="headerlink" title="ThreadLocal在线程间传递的问题"></a>ThreadLocal在线程间传递的问题</h2><p>ThreadLocal是线程独享的数据，是线程安全的，但是多线程开发过程中，可能会存在将一个线程的ThreadLocal数据传递给子线程的ThreadLocal。</p><h3 id="举例问题复现"><a href="#举例问题复现" class="headerlink" title="举例问题复现"></a>举例问题复现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------  输出结果如下  ----------</span><br><span class="line">当前线程中获取用户ID:<span class="number">1000</span></span><br><span class="line">子线程中获取用户ID：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>我们假设需要启动子线程去执行一些耗时任务，而子线程中需要ThreadLocal中的数据，那么这个时候子线程是获取不到的，当然我们也可以通过参数传递的方式把用户id传到thread对象中。<br>再举例一个场景，对请求的链路追踪，如果在程序在接到请求后，用子线程执行了某些耗时任务，那么也会追踪不到子线程中执行的哪些方法，因为ThreadLocal无法传递到子线程。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们将ThreadLocal 换成 InheritableThreadLocal 即可解决，如下代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------  输出结果如下  ----------</span><br><span class="line">当前线程中获取用户ID:<span class="number">1000</span></span><br><span class="line">子线程中获取用户ID：<span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="InheritableThreadLocal-源码解析-、Thread部分源码"><a href="#InheritableThreadLocal-源码解析-、Thread部分源码" class="headerlink" title="InheritableThreadLocal 源码解析 、Thread部分源码"></a>InheritableThreadLocal 源码解析 、Thread部分源码</h3><p>查看InheritableThreadLocal源码的时候，能看到InheritableThreadLocal只是继承自ThreadLocal 并且重写了三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继承可继承的inheritableThreadLocals 时会调用到该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写获取map方法，返回可继承的map对象</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写创建map方法，把创建出来的map赋值给可继承的 t.inheritableThreadLocals</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想弄明白InheritableThreadLocal的实现原理，需要先了解了解Thread的源码，接下来先写部分Thread的源码解析。<br>Thread的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 不可继承，ThreadLocal就是用的这个成员变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 可继承，InheritableThreadLocal 用的是这个变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>在Thread的构造方法中，会调用一个初始化方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//inheritThreadLocals 是否继承，默认为true   </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//现在的代码执行阶段还在Thread构造方法中调用的，所以这里currentThread 获取的还是当前线程，并不是未来将要开启的子线程。当前线程就是未来要开启的子线程的父级。</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果inheritThreadLocals = true 并且 父级的inheritableThreadLocals对象不为空</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">//根据父级的inheritableThreadLocals 创建一个新的map，并且赋值给新的Thread.inheritableThreadLocals 。</span></span><br><span class="line">               <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                   ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据父级的map，创建新的map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//ThreadLocalMap 的构造方法（复制父map的内容）</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//map中的table（数组）</span></span><br><span class="line">     Entry[] parentTable = parentMap.table;</span><br><span class="line">     <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">     setThreshold(len);</span><br><span class="line">     <span class="comment">//创建新的数组，这个tbale变量在ThreadLocalMap的成员属性中</span></span><br><span class="line">     table = <span class="keyword">new</span> Entry[len];    <span class="comment">//this.table = new Entry[len];</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//遍历数组</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        </span><br><span class="line">         Entry e = parentTable[j];</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从Entry中，拿到ThreadLocal</span></span><br><span class="line">             ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用ThreadLocal.childValue 方法， InheritableThreadLocal就重写了这个方法</span></span><br><span class="line">                 Object value = key.childValue(e.value);</span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">//接下来就是计算hash，然后决定将key放到哪里。</span></span><br><span class="line">                 Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                 <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                 <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                     h = nextIndex(h, len);</span><br><span class="line">                 table[h] = c;</span><br><span class="line">                 size++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure><p>以上是Thread对 可继承的inheritableThreadLocals 变量所做的一系列操作过程。</p><p>InheritableThreadLocal 总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用InheritableThreadLocal.set方法，而set方法第一次执行会调用createMap方法，而createMap已经被InheritableThreadLocal这个类重写。</span></span><br><span class="line">      <span class="comment">//所以创建出来的map会存储在inheritableThreadLocals变量中</span></span><br><span class="line">      threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这个get方法，里面实际是调用了一次getMap方法，而getMap也被inheritableThreadLocals重写，返回的是inheritableThreadLocals变量map。所以能拿到值。</span></span><br><span class="line">      System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//new Thread会执行一系列的初始化操作</span></span><br><span class="line">      <span class="comment">//1、判断inheritableThreadLocals=true （默认为true）</span></span><br><span class="line">      <span class="comment">//2、判断parent.inheritableThreadLocals !=null (我们放了一个id:1000在里面，所以不为空)</span></span><br><span class="line">      <span class="comment">//3、根据parent.inheritableThreadLocals 创建新的map对象，并且赋值到新的Thread.inheritableThreadLocals变量中（new Thread（）中)</span></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这个时候，Thread.inheritableThreadLocals已经继承了父级的数据，所以能拿到。</span></span><br><span class="line">          System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://songlongkuan.com/tags/Java/"/>
    
    <category term="ThreadLocal" scheme="https://songlongkuan.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之Executor线程池原理、增强拒绝策略</title>
    <link href="https://songlongkuan.com/2020/08/30/concurrent_executor_thread/"/>
    <id>https://songlongkuan.com/2020/08/30/concurrent_executor_thread/</id>
    <published>2020-08-30T04:48:00.000Z</published>
    <updated>2021-01-31T11:37:34.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是调度CPU资源的最小单位，线程模型分为KLT模型、ULT模型，JVM使用的KLT模型。因此Java线程与OS线程保持1:!的映射关系，也就是说一个Java线程也会在操作系统里有一个对应的线程。</p><a id="more"></a><p>Java线程有多种生命状态：</p><ul><li><p>NEW：新建</p></li><li><p>RUNNABLE：运行</p></li><li><p>BLOCKED：阻塞</p></li><li><p>WAITING：等待</p></li><li><p>TIMED_WAITING：超时等待</p></li><li><p>TERMINATED：终结</p><p><img src="https://oss.pencilso.cn/enclosure/thread_excter_1_1598748857919.png" alt="thread_excter_1"></p></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>这里记录一下协程相关的资料，协程（纤程、用户级线程），主要目的是为了追求最大力度的发挥硬件性能和提升软件的速度。</p><p>协程的基本原理：在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务，等完成或达到某个条件时，再还原原来的栈信息并继续执行，（整个过程不需要上下文切换）</p><p>协程是用户级线程ULT模型，多个协程由一个线程所处理，协程的创建与销毁由程序自己来控制，当提交了多个线程任务，那么最终都是由一个KLT线程去顺序执行这些协程的任务。以此避免KLT线程之间的切换。</p><p>Java原生是不支持协程的，在纯Java代码里需要使用协程的话需要引入第三方包，如：quasar</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>“线程池” 顾名思义就是一个线程缓存，线程时稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程统一分配、调优、监控。</p><h3 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h3><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行 处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p><ul><li>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁 线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</li></ul><p>线程池的解决方案：线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上，适合以下场景使用线程池：</p><ul><li>单个任务处理时间短</li><li>需要处理的任务数量很大</li></ul><h3 id="线程池优势"><a href="#线程池优势" class="headerlink" title="线程池优势"></a>线程池优势</h3><ul><li>重用存在的线程，减少线程创建，消亡的开销，提高性能</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资 源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p>1、Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImp</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadImp</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Callable（与前两种不同的是，Callable可以在执行任务后带有返回内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableImp</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图为它的继承与实现 <img src="https://oss.pencilso.cn/enclosure/thread_excter_2_1598752817575.png" alt="thread_excter_2"></p><p>从图中可以看出Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体行为</p><ol><li>execute（Runnable command）：履行Ruannable类型的任务,</li><li>submit（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future 对象</li><li>shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,</li><li>shutdownNow（）：停止所有正在履行的任务并封闭办事。</li><li>isTerminated（）：测试是否所有任务都履行完毕了。</li><li>isShutdown（）：测试是否该ExecutorService已被关闭。</li></ol><h3 id="ThreadPoolExecutor线程池重点属性"><a href="#ThreadPoolExecutor线程池重点属性" class="headerlink" title="ThreadPoolExecutor线程池重点属性"></a>ThreadPoolExecutor线程池重点属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>)); </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存 workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p><p>ctl相关方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><ul><li>runStateOf：获取运行状态；</li><li>workerCountOf：获取活动线程数；</li><li>ctlOf：获取运行状态和活动线程数的值。</li></ul><p>线程池存在5种状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UNNING = ‐1 &lt;&lt; COUNT_BITS; //高3位为111 </span><br><span class="line">SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //高3位为000 </span><br><span class="line">STOP = 1 &lt;&lt; COUNT_BITS; //高3位为001 </span><br><span class="line">TIDYING = 2 &lt;&lt; COUNT_BITS; //高3位为010 </span><br><span class="line">TERMINATED = 3 &lt;&lt; COUNT_BITS; //高3位为011</span><br></pre></td></tr></table></figure><p>1、RUNNING</p><p>​    (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行 处理。</p><p>​     (02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处 于RUNNING状态，并且线程池中的任务数为0！</p><p>2、 SHUTDOWN </p><p>​    (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</p><p>​     (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p><p>3、STOP </p><p>​    (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中 断正在处理的任务。 </p><p>​    (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p><p>4、TIDYING </p><p>​    (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING 状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在 ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理； 可以通过重载terminated()函数来实现。 </p><p>​    (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也 为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的 任务为空时，就会由STOP -&gt; TIDYING。</p><p>5、 TERMINATED<br>    (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。</p><p>​     (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING - &gt; TERMINATED。 进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TIDYING状态或TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； workerCount为0； 设置TIDYING状态成功。</p><h3 id="线程池的具体实现"><a href="#线程池的具体实现" class="headerlink" title="线程池的具体实现"></a>线程池的具体实现</h3><p>ThreadPoolExecutor 默认线程池</p><p>ScheduledThreadPoolExecutor 定时线程池</p><h2 id="线程池-ThreadPoolExecutor"><a href="#线程池-ThreadPoolExecutor" class="headerlink" title="线程池 ThreadPoolExecutor"></a>线程池 ThreadPoolExecutor</h2><h3 id="线程池ThreadPoolExecutor的创建"><a href="#线程池ThreadPoolExecutor的创建" class="headerlink" title="线程池ThreadPoolExecutor的创建"></a>线程池ThreadPoolExecutor的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span></span><br></pre></td></tr></table></figure><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize：</span><br><span class="line">    线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</span><br><span class="line"></span><br><span class="line">maximumPoolSize：</span><br><span class="line">    线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。</span><br><span class="line"></span><br><span class="line">keepAliveTime：</span><br><span class="line">    线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime.</span><br><span class="line"></span><br><span class="line">unit：</span><br><span class="line">    keepAliveTime的单位。</span><br><span class="line"></span><br><span class="line">workQueue：</span><br><span class="line">    用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</span><br><span class="line">    1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</span><br><span class="line">    2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</span><br><span class="line">    3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到 另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQuene；</span><br><span class="line">    4、priorityBlockingQuene：具有优先级的无界阻塞队列；</span><br><span class="line">    </span><br><span class="line">threadFactory：</span><br><span class="line">    它是ThreadFactory类型的变量，用来创建新线程。默认使用 Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</span><br><span class="line">    </span><br><span class="line">handler：</span><br><span class="line">    线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</span><br><span class="line">        1、AbortPolicy：直接抛出异常，默认策略；</span><br><span class="line">        2、CallerRunsPolicy：用调用者所在的线程来执行任务；</span><br><span class="line">        3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</span><br><span class="line">        4、DiscardPolicy：直接丢弃任务；</span><br><span class="line">        上面的4种策略都是ThreadPoolExecutor的内部类。</span><br><span class="line">        当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如 记录日志或持久化存储不能处理的任务。</span><br></pre></td></tr></table></figure><h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务无返回值提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span></span><br><span class="line"><span class="function"> <span class="comment">//任务有返回值提交</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程池监控方法"><a href="#线程池监控方法" class="headerlink" title="线程池监控方法"></a>线程池监控方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> <span class="comment">//线程池已执行与未执行的任务总数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> <span class="comment">//已完成的任务数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> <span class="comment">//线程池当前的线程数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> <span class="comment">//线程池中正在执行任务的线程数量</span></span></span><br></pre></td></tr></table></figure><h3 id="线程池ThreadPoolExecutor原理"><a href="#线程池ThreadPoolExecutor原理" class="headerlink" title="线程池ThreadPoolExecutor原理"></a>线程池ThreadPoolExecutor原理</h3><p> <img src="https://oss.pencilso.cn/enclosure/thread_excter_3_1598755457770.png" alt="thread_excter_3"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h6 id="ThreadPoolExecutor-execute方法"><a href="#ThreadPoolExecutor-execute方法" class="headerlink" title="ThreadPoolExecutor execute方法"></a>ThreadPoolExecutor execute方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">// clt记录着runState和workerCount</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line"><span class="comment">   * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span></span><br><span class="line"><span class="comment">   * 并把任务添加到该线程中。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">     * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">     * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果添加失败，则重新获取ctl值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 如果当前线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">       <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">      <span class="comment">// 这时需要移除该command</span></span><br><span class="line">      <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">       * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">       * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">       * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">       * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 如果执行到这里，有两种情况：</span></span><br><span class="line"><span class="comment">   * 1. 线程池已经不是RUNNING状态；</span></span><br><span class="line"><span class="comment">   * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。</span></span><br><span class="line"><span class="comment">   * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line"><span class="comment">   * 如果失败则拒绝该任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ThreadPoolExecutor-addWorker方法"><a href="#ThreadPoolExecutor-addWorker方法" class="headerlink" title="ThreadPoolExecutor addWorker方法"></a>ThreadPoolExecutor addWorker方法</h6><p> addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这个if判断</span></span><br><span class="line"><span class="comment">     * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">     * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">     * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">     * 2. firsTask为空</span></span><br><span class="line"><span class="comment">     * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">     * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">     * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">     * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">              <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">              <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                  <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">      <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                   <span class="comment">// workers是一个HashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                  <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">              <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h5><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，请参见JDK源码。</p><p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p><p>在调用构造方法时，需要把任务传入，这里通过getThreadFactory().newThread(this);来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p><p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li><li>如果正在执行任务，则不应该中断线程；</li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li><li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li><li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li></ol><p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p><p>​    此外，在构造方法中执行了setState(-1);，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cas修改state，不可重入</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Worker构造方法"><a href="#Worker构造方法" class="headerlink" title="Worker构造方法"></a>Worker构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire方法是根据state是否是0来判断的，所以，setState(-1);将state设置为-1是为了禁止在执行任务前对线程进行中断。</p><p>正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0。</p><p>Worker runWorker方法：在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//允许中断，把state改为0</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 如果task为空，则通过getTask来获取任务 getTask会从阻塞队列获取任务，对于线程的复用就是在该while循环中体现</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">                <span class="comment">//该if判断见下面的备注</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//修改为正常退出循环</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>如果线程池正在停止，那么要保证当前线程是中断状态；</li><li>如果不是的话，则要保证当前线程不是中断状态；</li></ul><p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p><ul><li>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</li><li>在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</li><li>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</li></ul><p>总结一下runWorker方法的执行过程：</p><ol><li>while循环不断地通过getTask()方法获取任务；</li><li>getTask()方法从阻塞队列中取任务；</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li><li>调用task.run()执行任务；</li><li>如果task为null则跳出循环，执行processWorkerExit()方法；</li><li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li></ol><p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</p><p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p><h6 id="Worker-getTask方法"><a href="#Worker-getTask方法" class="headerlink" title="Worker getTask方法"></a>Worker getTask方法</h6><p>getTask方法用来从阻塞队列中取任务，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">                </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">       * 1. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">       * 2. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">       * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">       * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">           * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">           * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">           * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">           * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">//该判断的分析见备注</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class="line"><span class="comment">         * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">              <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">          <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><pre><code>目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</code></pre><h6 id="Worker-processWorkerExit方法"><a href="#Worker-processWorkerExit方法" class="headerlink" title="Worker processWorkerExit方法"></a>Worker processWorkerExit方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">       <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">   * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">   * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束。</p><h2 id="拒绝策略增强"><a href="#拒绝策略增强" class="headerlink" title="拒绝策略增强"></a>拒绝策略增强</h2><p>拒绝策略的触发条件是：核心线程已满、阻塞队列已满、非核心线程已满</p><p>而Java提供的四种策略：</p><pre><code>    1、AbortPolicy：直接抛出异常，默认策略；    2、CallerRunsPolicy：用调用者所在的线程来执行任务；    3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；    4、DiscardPolicy：直接丢弃任务；</code></pre><p>如果说应用场景里面，提交任务不允许异常、线程任务不允许丢弃、也不允许用调用者所在的线程来执行任务。那么这时候可以使用无界的阻塞队列，也可以我们自己来定义拒绝策略。</p><p>接下来我实现一个用redis实现的拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义线程任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTask</span><span class="params">(<span class="keyword">int</span> task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTask</span><span class="params">(<span class="keyword">int</span> task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; task:&quot;</span> + task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义拒绝策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String redisKey = <span class="string">&quot;executor_list&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisRejectedExecutionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledThreadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">        scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ListOperations listOperations = redisTemplate.opsForList();</span><br><span class="line">                <span class="keyword">while</span> (listOperations.size(redisKey) != <span class="number">0L</span>) &#123;</span><br><span class="line">                    BlockingQueue&lt;Runnable&gt; queue = executor.getQueue();</span><br><span class="line">                    <span class="keyword">if</span> (queue.remainingCapacity() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//尝试重新放回阻塞队列里面</span></span><br><span class="line">                        CustomTask customTask = ((CustomTask) listOperations.leftPop(redisKey));</span><br><span class="line">                        <span class="keyword">if</span> (customTask != <span class="keyword">null</span> &amp;&amp; !queue.offer(customTask, <span class="number">500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            <span class="comment">//放入队列失败，跳出while循环</span></span><br><span class="line">                            <span class="comment">//把task重新放回redis</span></span><br><span class="line">                            listOperations.leftPush(redisKey, customTask);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//队列是满的 放不下</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> CustomTask) &#123;</span><br><span class="line">            CustomTask customTask = (CustomTask) r;</span><br><span class="line">            ListOperations&lt;String, Serializable&gt; listOperations = redisTemplate.opsForList();</span><br><span class="line">            listOperations.rightPush(redisKey, customTask);</span><br><span class="line">            System.out.println(<span class="string">&quot;task:&quot;</span> + customTask.getTask() + <span class="string">&quot; 已经放入redis&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟多线程测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), redisRejectedExecutionHandler);</span><br><span class="line">    redisRejectedExecutionHandler.setExecutor(threadPoolExecutor);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> CustomTask(i));</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000000000L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">task:<span class="number">6</span> 已经放入redis</span><br><span class="line">task:<span class="number">7</span> 已经放入redis</span><br><span class="line">task:<span class="number">8</span> 已经放入redis</span><br><span class="line">task:<span class="number">9</span> 已经放入redis</span><br><span class="line"> task:<span class="number">5</span></span><br><span class="line"> task:<span class="number">4</span></span><br><span class="line"> task:<span class="number">0</span></span><br><span class="line"> task:<span class="number">1</span></span><br><span class="line"> task:<span class="number">3</span></span><br><span class="line"> task:<span class="number">2</span></span><br><span class="line"> task:<span class="number">6</span></span><br><span class="line"> task:<span class="number">7</span></span><br><span class="line"> task:<span class="number">8</span></span><br><span class="line"> task:<span class="number">9</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//ps： ThreadPoolExecutor最大线程数是3，而ArrayBlockingQueue队列数量也是3，所以最终有4个会放到redis，从打印日志来看是符合预期的。6、7、8、9被放到了redis，当阻塞队列有空闲位置的时候，我们又把redis中的线程任务添加到队列中，最后6、7、8、9也执行了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ThreadPoolExecutor线程池的使用及原理</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://songlongkuan.com/tags/Java/"/>
    
    <category term="Executor" scheme="https://songlongkuan.com/tags/Executor/"/>
    
  </entry>
  
  <entry>
    <title>Java基础  JDK类加载机制</title>
    <link href="https://songlongkuan.com/2020/06/26/java_basics_classloader/"/>
    <id>https://songlongkuan.com/2020/06/26/java_basics_classloader/</id>
    <published>2020-06-26T12:00:00.000Z</published>
    <updated>2021-01-31T11:44:08.176Z</updated>
    
    <content type="html"><![CDATA[<p>记录类加载全过程、类加载器、双亲委派机制，以及自定义类加载器。</p><a id="more"></a><h2 id="类加载运行全过程"><a href="#类加载运行全过程" class="headerlink" title="类加载运行全过程"></a>类加载运行全过程</h2><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到JVM。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.pencilso.study.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRun</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> int1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> int2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> int1 + int2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        TestRun testRun = <span class="keyword">new</span> TestRun();</span><br><span class="line">        <span class="keyword">int</span> add = testRun.add();</span><br><span class="line">        System.out.println(<span class="string">&quot;add-&gt; &quot;</span>+add);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 通过Java命令执行代码的大体流程如下：</p><p><img src="https://oss.pencilso.cn/enclosure/classloader%20(1)_1591971696396.png" alt="classloader (1)"></p><p>其中classloader.loadClass的类加载过程有如下几步：</p><p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p><ul><li><p>加载 ：读入class字节码文件，使用到类时才会加载，例如调用类的静态方法，new对象等。</p></li><li><p>验证：校验字节码文件的正确性。</p></li><li><p>准备：对静态变量分配内存，并赋予默认值，例如 int1的默认值是0，而user是null，至于int2则是2，因为int2 使用了final修饰词，所以int2是常量，不再是静态变量。</p></li><li><p>解析：将符号引用替换为直接引用，该阶段会把一些静态方法（符号引用，比如main() 方法）替换为指向数据所存内存的指针或句柄等 (直接引用) ，这是所谓的静态链接过程 (类加载期间完成)。</p><p>动态链接是在程序运行期间完成的将符号引用替换为直接引用。</p></li><li><p>初始化：对类的静态变量初始化为指定的值，int1赋值为1 ，user 则会加载User类，创建User实例后赋值给user， 然后执行静态代码块。</p></li></ul><p>主类在运行过程中如果使用到其他类，会逐步加载这些类。</p><p>jar包或war包里的类不是一次性全部加载的，是使用到时才加载。</p><h2 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h2><p>Java中有多种类加载器</p><pre><code>- 引导类加载器：负责加载jre/lib目录下的jvm的核心类库，rt.jar、charsets.jar 等。- 扩展类加载器：负责加载jre/ext目录下的jvm扩展类库。- 应用程序类加载器：负责加载ClassPath路径下的类，主要就是加载自己编写的那些类。- 自定义加载器：负责加载指定目录下的类。</code></pre><p>注意，引导类加载器是由C++所创建的，所以在Java代码中是获取不到引导类加载器的对象。</p><p>查看对应的几种类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader stringClassLoader = String.class.getClassLoader();</span><br><span class="line">        ClassLoader deskeyFactoryClassloader = DESKeyFactory.class.getClassLoader();</span><br><span class="line">        ClassLoader testJdkClassloader = TestJDKClassloader.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;stringClassLoader-&gt; &quot;</span>+stringClassLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;fileClassloader-&gt; &quot;</span>+deskeyFactoryClassloader);</span><br><span class="line">        System.out.println(<span class="string">&quot;testJdkClassloader-&gt; &quot;</span>+testJdkClassloader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line">stringClassLoader-&gt; <span class="keyword">null</span></span><br><span class="line">fileClassloader-&gt; sun.misc.Launcher$ExtClassLoader@1b28cdfa</span><br><span class="line">testJdkClassloader-&gt; sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">  </span><br><span class="line"><span class="comment">// String是Java核心类库，是由C++所编写的引导式加载器 bootstrapLoader，所以获取到的是null</span></span><br><span class="line"><span class="comment">// DESKeyFactory 是Java的扩展类库，所以获取到的是 ExtClassLoader</span></span><br><span class="line"><span class="comment">// testJdkClassloader 是自己编写的文件，所以类加载器是AppClassLoader</span></span><br></pre></td></tr></table></figure><p>在创建Launcher时就创建好了ExtClassLoader、AppClassLoader两种加载器。</p><p>查看源码Launcher，分析ExtClassLoader、AppClassLoader是如何创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例 Launcher</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line"> <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Create the extension class loader</span></span><br><span class="line">       ClassLoader extcl;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//创建扩展的类加载器</span></span><br><span class="line">           extcl = ExtClassLoader.getExtClassLoader(); </span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">               <span class="string">&quot;Could not create extension class loader&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//创建应用的类加载器 , 并且将扩展库加载器传递到参数</span></span><br><span class="line">           loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">               <span class="string">&quot;Could not create application class loader&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">     ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="ExtClassLoader-创建过程"><a href="#ExtClassLoader-创建过程" class="headerlink" title="ExtClassLoader 创建过程"></a>ExtClassLoader 创建过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、单例模式 ，在createExtClassLoader方法进行创建</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(ExtClassLoader.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        instance = createExtClassLoader();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、可以看到new了一个ExtClassLoader，并且把扩展类库的路径传给了构造参数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ExtClassLoader <span class="title">createExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Prior implementations of this doPrivileged() block supplied</span></span><br><span class="line">                <span class="comment">// aa synthesized ACC via a call to the private method</span></span><br><span class="line">                <span class="comment">// ExtClassLoader.getContext().</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                            <span class="keyword">final</span> File[] dirs = getExtDirs();</span><br><span class="line">                            <span class="keyword">int</span> len = dirs.length;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                                MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、调用了supper方法，将类库路径传给了supper构造的参数中，并且将parent参数传递的是null，至此extClassLoader则创建出来了</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] dirs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(getExtURLs(dirs), <span class="keyword">null</span>, factory);</span><br><span class="line">            SharedSecrets.getJavaNetAccess().</span><br><span class="line">                getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h6 id="AppClassLoader-创建过程"><a href="#AppClassLoader-创建过程" class="headerlink" title="AppClassLoader 创建过程"></a>AppClassLoader 创建过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取classpath下的类路径，并且new了一个AppClassLoader，将路径与扩展库加载器传递到构造参数。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> String s = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] path = (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> File[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    URL[] urls =</span><br><span class="line">                        (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> URL[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> AppClassLoader(urls, extcl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、AppClassLoader构造方法，将类路径数组与扩展库类加载器传到了supper</span></span><br><span class="line">        AppClassLoader(URL[] urls, ClassLoader parent) &#123;</span><br><span class="line">            <span class="keyword">super</span>(urls, parent, factory);</span><br><span class="line">            ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line">            ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 3、最后跟踪supper构造方法，将parent 保存在了一个成员变量里面。而对于AppClassLoader来说</span></span><br><span class="line"><span class="comment">//        这个parent就是扩展库的ClassLoader</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="类加载器初始化过程"><a href="#类加载器初始化过程" class="headerlink" title="类加载器初始化过程"></a>类加载器初始化过程</h6><p>类运行加载过程中会创建JVM启动器实例sun.misc.Launcher 并且使用了单例设计模式。</p><p>在Launcher构造方法内部，创建了两个类加载器，分别是：</p><pre><code>- ExtClassLoader 扩展类加载器- AppClassLoader 应用加载器 并且其parent是ExtClassLoader扩展类加载器- JVM默认使用Launcher的getClassLoader方法返回的类加载器实例，加载应用程序，而这个getClassLoader方法返回的就是AppClassLoader应用加载器。</code></pre><h6 id="双亲委派机制流程"><a href="#双亲委派机制流程" class="headerlink" title="双亲委派机制流程"></a>双亲委派机制流程</h6><p>每个类加载器都会维护一个已加载过的类数组，当需要加载某一个类时，类加载器执行顺序是：自定义加载器（如果有的话）-&gt; 应用类加载器 -&gt; 扩展类加载器 -&gt; 引导类加载器</p><p>假设现在需要加载一个User.class类，会从自定义加载器开始，先检查自身已加载类列表是否存在，如果存在则直接返回，如果不存在，调用parent类加载器进行加载，如果parent已加载列表也没有，则调用parent的parent类加载器，如此层层向上委托，直到没有parent为止。</p><p>如果最顶级的parent在它自己的已加载列表中找不到，则在它的类加载路径寻找文件，如果还找不到，则层层往下退回加载请求，每一层都执行同样的操作，只要有一层类加载器找到了，就会放到该加载器的已加载列表，并且返回该类的信息，如果所有的类加载器都没有找到，则抛出ClassNotFoundException。</p><p> <img src="https://oss.pencilso.cn/enclosure/classloader-shuangqin_1592006161540.png" alt="classloader-shuangqin"></p><h6 id="双亲委派机制源码实现"><a href="#双亲委派机制源码实现" class="headerlink" title="双亲委派机制源码实现"></a>双亲委派机制源码实现</h6><p>源码在ClassLoader.loadCLass </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 第一步，检查已经加载过的class，如果已加载过了，则直接return了。</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 如果该加载器有父类，则委托父加载器去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果该加载器没有父类，则用引导类加载器去加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="comment">// 如果所有的parent都加载不到的话，则去自己的类路径寻找文件</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="为什么要设计双亲委派机制"><a href="#为什么要设计双亲委派机制" class="headerlink" title="为什么要设计双亲委派机制"></a>为什么要设计双亲委派机制</h6><pre><code>- 沙箱安全机制 : 自己写的核心内库不会被加载，这样可以防止核心API库被随意篡改。- 避免类的重复加载：当父加载器已经加载了该类时，就没有必要子CLassLoader再加载一次，保证被加载类的唯一性</code></pre><p>尝试自定义String类如下，替换Java的核心类库String ，运行错误，提示找不到这个main方法。</p><p>原因String是Java核心类库，由引导类加载器最先加载的。在执行下列代码时，会委托给父加载器进行加载String，最后委托到引导类加载器的时候，会从引导类加载器返回回来，而引导类加载器所加载的String，是Java的核心类库，它的匹配规则是依据包名+类名的匹配规则来匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------My String ----------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure><h6 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h6><p>“全盘负责” 是指当一个ClassLoader装在一个类时，除非显示的使用另外一个CLassLoader，该类所依赖及引用的类也由这个CLassLoader载入。</p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><h6 id="自定义类加载器，加载Class文件"><a href="#自定义类加载器，加载Class文件" class="headerlink" title="自定义类加载器，加载Class文件"></a>自定义类加载器，加载Class文件</h6><p>实现一个简单的类加载器，只需要继承CLassLoader，并重写findClass 方法即可。</p><p>先准备一个示例类 : User </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.pencilso.study.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------this is User Class --------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对代码进行编译，编译之后class文件会在项目的target 目录下。</p><p>准备文件夹，将User这个类的class文件复制出来。</p><p>我把class文件放在了 “/Users/pencilso/Desktop/classloader/“ +  “cn/pencilso/study/classloader”</p><p>需要注意的是，后面的  “cn/pencilso/study/classloader” 对应的是这个类的包名。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pencilso@MacBook-Pro ~ % ls ~/Desktop/classloader/cn/pencilso/study/classloader</span><br><span class="line">User.class</span><br></pre></td></tr></table></figure><p>简单的类加载器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.pencilso.study.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/Users/pencilso/Desktop/classloader/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; userCLass = myClassLoader.loadClass(<span class="string">&quot;cn.pencilso.study.classloader.User&quot;</span>);</span><br><span class="line">        Object userInstance = userCLass.newInstance();</span><br><span class="line">        Method soutMethod = userCLass.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        soutMethod.invoke(userInstance, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader:&quot;</span> + userCLass.getClassLoader().getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * class 文件所在的文件夹</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String folder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从指定目录中寻找class文件</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将包名中的 &quot;.&quot; 替换为文件路径分隔符</span></span><br><span class="line">                String classPath = name.replace(<span class="string">&quot;.&quot;</span>, File.separator);</span><br><span class="line">                FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(folder + classPath + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> len = fileInputStream.available();</span><br><span class="line">                <span class="keyword">byte</span>[] classByte = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">                fileInputStream.read(classByte);</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">                <span class="comment">//解释class文件</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, classByte, <span class="number">0</span>, classByte.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，结果如下，可以看到已经调用到了User对象里面的”sout”方法，输出了 “this is User Class” 。</p><p>但是classLoader为什么还是AppClassLoader？</p><p>这是因为双亲委托机制的结果，自定义ClassLoader加载器也会向上层级委托。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------this is User Class --------</span><br><span class="line">classLoader:class sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure><p>源码分析：</p><p>我们的自定义类加载器是继承自CLassLoader，那么在初始化时会执行CLassLoader的构造方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1、ClassLoader的无参构造方法，调用了getSystemClassLoader，并且传入了二参构造    </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、getSystemClassLoader方法是获取一个CLassLoader对象，其初始化方法是 initSystemClassLoader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、初始化SystemClassLoader</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recursive invocation&quot;</span>);</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">// 调用了getClassLoader方法，而这个getClassLoader方法获取到的就是appClassLoader对象</span></span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">          ......</span><br><span class="line"> &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 4、查看二参的ClassLoader构造方法，可以得知，它最后将AppClassLoader对象存在了parent字段中。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面源码分析，我们自定义的类加载器，加载User.class，执行双亲委派机制时，委托到了AppClassLoader，后又委托到ExtClassLoader，后又委托到 BootstrapLoader ，而 BootstrapLoader 是肯定找不到这个类的，ExtClassLoader也找不到，委托退到AppClassLoader的时候找到了。所以上面的代码运行输出的ClassLoader是 AppClassLoader。</p><p>即使我们的User.class文件在项目的target目录下，和我们自己创建的外部文件夹都有一份，但是只要有一个类加载器加载到了文件，其他的类加载器则不再会加载。而AppClassLoader的层级比自定义ClassLoader的层级要高 。</p><p>那怎样让它用自定义加载器加载User.class ?</p><p>接下来，把源码中的User.java 删除，编译、重新运行，这次的结果是自定义的CLassLoader了，因为这时候target目录下已经没有了User.class ，所以AppClassLoader找不到这个类，委托会退到自定义CLassLoader，而自定义CLassLoader会去我们自定义的文件夹下面去找这个类文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------this is User Class --------</span><br><span class="line">classLoader:class cn.pencilso.study.classloader.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure><h6 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h6><p>我们得知在加载类文件时，需要经过双亲委派机制，层级向上委托，层级向下退回。</p><p>那么如何指定让自定义加载器直接加载，而不向上委托？</p><p>之前提到过双亲委派机制的源码实现在 ClassLoader.loadCLass  中，那么自定义类加载器继承后，在MyClassLoader类中，重写loadClass方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="keyword">if</span> (name.equals(<span class="string">&quot;cn.pencilso.study.classloader.User&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//当加载指定的类时，不委托给父加载器，自行加载。</span></span><br><span class="line">                        c = findClass(name);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//默认委托给父加载器</span></span><br><span class="line">                        c = getParent().loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接下来把源码中的User.java 文件添加回来，再次执行，最后输出的是我们自定义的类加载器了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------this is User Class --------</span><br><span class="line">classLoader:class cn.pencilso.study.classloader.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">类加载全过程、双亲委派机制。</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="类加载机制" scheme="https://songlongkuan.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从架构、哨兵架构</title>
    <link href="https://songlongkuan.com/2020/06/11/redis_master_slate_sentiel/"/>
    <id>https://songlongkuan.com/2020/06/11/redis_master_slate_sentiel/</id>
    <published>2020-06-11T08:53:00.000Z</published>
    <updated>2021-01-31T12:09:45.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一点需要注意，在不关闭防火墙的情况下，可能导致slave节点同步主节点数据失败。</p></blockquote><a id="more"></a><h2 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h2><h6 id="搭建Redis主从"><a href="#搭建Redis主从" class="headerlink" title="搭建Redis主从"></a>搭建Redis主从</h6><p>先启动一个6379端口的redis，作为主节点，master。</p><p>复制一份新的redis.conf文件进行修改，作为slave节点的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改端口</span></span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改pid文件路径</span></span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改redis数据存放目录</span></span><br><span class="line">dir /root/redis/data/6380/dir</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定主节点，从主节点同步数据</span></span><br><span class="line">replicaof 192.168.2.166 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置slave节点为只读</span></span><br><span class="line">replica‐read‐only yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动slave节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server data/6380/redis.conf</span><br></pre></td></tr></table></figure><p>查看进程，这时候已经能看到两个进程了，一个6379，一个6380 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# ps -ef | grep redis</span><br><span class="line">root      8966     1  0 10:14 ?        00:00:00 src/redis-server 127.0.0.1:6379</span><br><span class="line">root      9020     1  0 10:15 ?        00:00:00 src/redis-server 127.0.0.1:6380</span><br><span class="line">root      9053  3698  0 10:15 pts/0    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><p>进入6379主节点写入数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set zhangsan 2020</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p>进入slave从节点执行get命令，可以看到已经同步了主节点 master的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; get zhangsan</span><br><span class="line">&quot;2020&quot;</span><br><span class="line">127.0.0.1:6380&gt; </span><br></pre></td></tr></table></figure><p>但是slave节点我们在配置文件里设置的是只读，不允许写，尝试一下写入命令。可以看到控制台输出错误信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; set zhangsan 1</span><br><span class="line">(error) READONLY You can&#x27;t write against a read only replica.</span><br><span class="line">127.0.0.1:6380&gt; </span><br></pre></td></tr></table></figure><h6 id="使用Docker-搭建主从架构"><a href="#使用Docker-搭建主从架构" class="headerlink" title="使用Docker 搭建主从架构"></a>使用Docker 搭建主从架构</h6><p>先使用docker 拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# docker pull redis:6</span><br><span class="line">6: Pulling from library/redis</span><br><span class="line">8559a31e96f4: Pull complete </span><br><span class="line">85a6a5c53ff0: Pull complete </span><br><span class="line">b69876b7abed: Pull complete </span><br><span class="line">a72d84b9df6a: Pull complete </span><br><span class="line">5ce7b314b19c: Pull complete </span><br><span class="line">04c4bfb0b023: Pull complete </span><br><span class="line">Digest: sha256:800f2587bf3376cb01e6307afe599ddce9439deafbd4fb8562829da96085c9c5</span><br><span class="line">Status: Downloaded newer image for redis:6</span><br><span class="line">docker.io/library/redis:6</span><br></pre></td></tr></table></figure><p>创建多个文件夹，我这里以端口为命名，文件夹下有dir文件夹（作为redis工作目录），并且复制一个未修改的redis.conf 配置文件。</p><p>需要注意的是，需要对文件夹的权限修改为757。不然后续redis会没有写入权限 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-data]# mkdir 6379/dir</span><br><span class="line">[root@localhost redis-data]# cp /root/redis/redis.conf 6379/redis.conf</span><br><span class="line">[root@localhost redis-data]# chmod -R 757 6379</span><br><span class="line">[root@localhost redis-data]# ls 6379</span><br><span class="line">dir  redis.conf</span><br></pre></td></tr></table></figure><p>修改redis.conf中的工作目录  其他的aof  rdb持久化等配置，根据自己需要，自行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止使用后台守护进程</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置redis的工作目录</span></span><br><span class="line">dir /redis-data/dir</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置绑定地址</span></span><br><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure><p>运行主节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动主节点 master</span>  </span><br><span class="line">docker run -d --name redis-master -p 6379:6379 -v /root/redis-data/6379:/redis-data redis:6 redis-server /redis-data/redis.conf</span><br></pre></td></tr></table></figure><p>准备slave从节点，将master主节点的文件夹 ”6379“ 复制出一份，到 ”6380“  。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-data]# cp -r 6379 6380</span><br><span class="line">[root@localhost redis-data]# chmod -R 757 6380</span><br><span class="line">[root@localhost redis-data]# ls</span><br><span class="line">6379  6380</span><br></pre></td></tr></table></figure><p>修改6380下的redis.conf配置文件，添加主节点的ip地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定主节点，从主节点同步数据</span></span><br><span class="line">replicaof 192.168.2.116 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置slave节点为只读</span></span><br><span class="line">replica‐read‐only yes</span><br></pre></td></tr></table></figure><p>启动slave 从节点命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动从节点 slave-6380</span>  </span><br><span class="line">docker run -d --name redis-slave-6380 -p 6380:6379 -v /root/redis-data/6380:/redis-data redis:6 redis-server /redis-data/redis.conf</span><br></pre></td></tr></table></figure><p>测试主从是否生效，先进入主节点端口，执行set指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set zhangsan 2020</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p>现在进入slave从节点，查看数据，已经同步到slave从节点上了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; get zhangsan</span><br><span class="line">&quot;2020&quot;</span><br><span class="line">127.0.0.1:6380&gt; </span><br></pre></td></tr></table></figure><h6 id="主从架构数据复制原理"><a href="#主从架构数据复制原理" class="headerlink" title="主从架构数据复制原理"></a>主从架构数据复制原理</h6><p>Slave 节点在第一次启动时，会发送psync指令到主节点同步全量数据，主节点在获取到psync指令后，会将master主节点最新的内存数据，生成一次RDB数据快照（如果同时收到多次同步全量数据的指令，只会生成一次数据快照），并且发送到slave节点，slave节点接收到RDB数据后，加载到内存当中，然后master主节点会将生成RDB文件后的缓存在内存中的命令，发送给slave节点。</p><p>当slave节点与master节点完成同步之后，master会通过长连接的方式，持续将新的写命令，发送给slave节点。</p><p>master 主节点在执行写的命令时，会将命令存放到缓存区，每条命令都会有一个offset偏移值，缓存区大小约为1M，会滚动删除，并且master和它所有的slave节点都会持有每条命令的offset 偏移值和master 进程id。</p><p>如果因为网络波动等原因导致slave 与 master连接中断，这时候slave节点会进行重连，如果master 进程id出现了变化，则会发送全量同步的指令，否则会执行增量同步，发送psync( offset )指令，将slave节点最新的一条数据的偏移量（offset）通过psync指令发送给master。master在接到这条psync（offset）指令后，会去master的缓存区域查找这条offset，如果找到了的话，会将这个指令之后的数据一次性同步给slave节点，倘若没有找到的话，说明这个offset 已经过旧了，则会出发一次全量同步。</p><h2 id="哨兵架构"><a href="#哨兵架构" class="headerlink" title="哨兵架构"></a>哨兵架构</h2><p>sentinel哨兵是特殊的redis服务，它主要是用来监控redis的实例节点。</p><p>在哨兵的架构下，client端会在第一次获取redis实例，从sentinel找出主节点master，后续就会一直访问该主节点。</p><p>如果主节点master宕机了的情况下，sentinel会第一时间感知到，并对slave节点进行选举，选出一个新的master节点。如果redis的client端实现了订阅功能，那么这时候client可以订阅sentinel发布的节点变动消息。</p><h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><p>先运行一个master主节点，其次再运行两个slave节点，其实就是先把主从跑起来。</p><p>这里的话我就不采用docker运行了，修改配置文件，参考上面写的搭建Redis主从slave配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行主节点  master</span></span><br><span class="line">[root@myredis redis]# src/redis-server /root/redis-data/6379/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行slave节点  6380</span></span><br><span class="line">[root@myredis redis]# src/redis-server /root/redis-data/6380/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行slave节点  6381</span></span><br><span class="line">[root@myredis redis]# src/redis-server /root/redis-data/6381/redis.conf</span><br></pre></td></tr></table></figure><p>查看进程是否运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@myredis redis]# ps -ef | grep redis</span><br><span class="line">root      7746     1  0 17:14 ?        00:00:01 src/redis-server 0.0.0.0:6379</span><br><span class="line">root      7767     1  0 17:14 ?        00:00:01 src/redis-server 0.0.0.0:6380</span><br><span class="line">root      7783     1  0 17:14 ?        00:00:01 src/redis-server 0.0.0.0:6381</span><br></pre></td></tr></table></figure><h6 id="搭建哨兵架构"><a href="#搭建哨兵架构" class="headerlink" title="搭建哨兵架构"></a>搭建哨兵架构</h6><p>修改配置文件，要启动多少个哨兵，就修改多少份文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个文件夹 用来存储多个sentinel节点的配置文件</span></span><br><span class="line">mkdir sentinel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制一个sentinel.conf 文件，并以端口为结尾命名</span></span><br><span class="line">cp sentinel.conf sentinel/sentinel-26379.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来修改 配置文件</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行端口</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否开启后台守护进程</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进程id保存路径 结尾以端口号命名，以防多个实例冲突。</span></span><br><span class="line">pidfile /var/run/redis-sentinel-26379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件，同样以端口号命名，以防多个实例冲突。</span></span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改工作目录，同样以端口号结尾命名，工作目录要事先创建好，</span></span><br><span class="line">dir /root/redis-data/sentinel/26379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置主节点的ip地址和端口号，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel monitor &lt;master‐name&gt; &lt;ip&gt; &lt;redis‐port&gt; &lt;quorum&gt;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> quorum是一个数字，指明多少个sentinel认为master失效时，master才算真正失效（一般是sentinel总数/2 + 1）。</span></span><br><span class="line">sentinel monitor mymaster 192.168.2.116 6379 2</span><br></pre></td></tr></table></figure><p>启动sentinel。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据指定的配置文件启动sentinel 哨兵</span></span><br><span class="line">[root@localhost redis]# src/redis-sentinel sentinel/sentinel-26379.conf</span><br><span class="line">[root@localhost redis]# src/redis-sentinel sentinel/sentinel-26380.conf</span><br><span class="line">[root@localhost redis]# src/redis-sentinel sentinel/sentinel-26381.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动后，使用redis客户端进入sentinel</span></span><br><span class="line">[root@localhost redis]# src/redis-cli -p 26379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看sentinel信息，执行info命令</span></span><br><span class="line">127.0.0.1:26379&gt; info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Sentinel</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到 redis master的地址和端口，还有该master所对应的slaves的数量</span></span><br><span class="line">master0:name=mymaster,status=ok,address=192.168.2.116:6379,slaves=2,sentinels=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，哨兵架构已经搭建起来了</p><h2 id="SpringBoot-集成Redis哨兵"><a href="#SpringBoot-集成Redis哨兵" class="headerlink" title="SpringBoot 集成Redis哨兵"></a>SpringBoot 集成Redis哨兵</h2><p>依赖配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> application.yaml 配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment"># 哨兵节点，逗号分隔</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.116</span><span class="string">:26379,192.168.2.116:26380,192.168.2.116:26381</span></span><br><span class="line">      <span class="comment"># 主节点所在名称</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>编写测试接口，测试是否能从哨兵节点获取master节点，并写入数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一直向Redis 循环写入数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;whileWriteData&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">whileWriteData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               stringRedisTemplate.opsForValue().set(<span class="string">&quot;zhangsan:&quot;</span> + i, String.valueOf(i));</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用接口后，可以看到在一直向redis写入数据</p> <img src="https://oss.pencilso.cn/enclosure/WX20200616-174401@2x_1592300679655.png" alt="WX20200616-174401@2x" style="zoom:50%;" /><p>这时候尝试将redis的master节点，也就是 6379的进程kill掉。测试sentinel是否会切换slave为master。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@myredis redis]# ps -ef | grep redis</span><br><span class="line">root      7746     1  0 17:14 ?        00:00:04 src/redis-server 0.0.0.0:6379</span><br><span class="line">root      7767     1  0 17:14 ?        00:00:03 src/redis-server 0.0.0.0:6380</span><br><span class="line">root      7783     1  0 17:14 ?        00:00:03 src/redis-server 0.0.0.0:6381</span><br><span class="line">root      8312     1  0 17:17 ?        00:00:04 src/redis-sentinel *:26379 [sentinel]</span><br><span class="line">root     10878     1  0 17:30 ?        00:00:02 src/redis-sentinel *:26380 [sentinel]</span><br><span class="line">root     10907     1  0 17:30 ?        00:00:02 src/redis-sentinel *:26381 [sentinel]</span><br><span class="line">root     13848  3855  0 17:45 pts/0    00:00:00 grep --color=auto redis</span><br><span class="line"></span><br><span class="line">[root@myredis redis]# kill 7746</span><br></pre></td></tr></table></figure><p>再看SpringBoot运行日志，先是连接超时异常，后又重新尝试重新连接master节点。当sentinel重新选举出新的master后，会获取到新的master节点地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.lettuce.core.RedisCommandTimeoutException: Command timed out after <span class="number">3</span> second(s)</span><br><span class="line">  .....</span><br><span class="line"><span class="comment">//尝试重连master</span></span><br><span class="line">Cannot reconnect to [<span class="number">192.168</span><span class="number">.2</span><span class="number">.116</span>:<span class="number">6379</span>]: Connection refused: /<span class="number">192.168</span><span class="number">.2</span><span class="number">.116</span>:<span class="number">6379</span></span><br><span class="line"><span class="comment">// 连接新的master  </span></span><br><span class="line">Reconnected to <span class="number">192.168</span><span class="number">.2</span><span class="number">.116</span>:<span class="number">6382</span></span><br></pre></td></tr></table></figure><p>当SpringBoot获取到新的节点后，代码会继续往redis插入数据。</p><p>如果旧的master重新启动后，旧的master会变成slave节点。</p>]]></content>
    
    
    <summary type="html">Redis 主从架构、哨兵架构</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
    <category term="master" scheme="https://songlongkuan.com/tags/master/"/>
    
    <category term="slave" scheme="https://songlongkuan.com/tags/slave/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化，RDB、AOF、混合持久化</title>
    <link href="https://songlongkuan.com/2020/06/10/redis_rdb_aof/"/>
    <id>https://songlongkuan.com/2020/06/10/redis_rdb_aof/</id>
    <published>2020-06-10T15:11:00.000Z</published>
    <updated>2021-01-31T12:05:22.620Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 持久化，RDB、AOF、混合持久化</p><a id="more"></a><h2 id="RDB快照（snapshot）"><a href="#RDB快照（snapshot）" class="headerlink" title="RDB快照（snapshot）"></a><strong>RDB快照（snapshot）</strong></h2><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>在默认情况下，Redis会将快照数据放到 “dump.rdb” 的文件中。并且该文件是一个被压缩过的二进制文件。</p><p>而且可以对Redis设置多个生成RDB快照的策略。让Redis在某一个时间段内，修改次数达到设定的阈值，则触发持久化。</p><p>打开redis.conf 配置文件，配置几条规则，这里设置阈值较小，方便测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 存储RDB文件的文件名</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 存储数据目录，RDB 、 AOF 等文件都会存储在这个目录下</span></span><br><span class="line">dir /root/redis/data/6379/dir</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置30秒内 有20个更新操作即生成一个RDB快照</span></span><br><span class="line">save 30 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置60秒内 有10个更新操作即生成一个RDB快照</span></span><br><span class="line">save 60 10</span><br></pre></td></tr></table></figure><p>尝试手动在30秒内执行20个更新操作，观察dir目录下确实生成了一个 “dump.rdb” 文件，不过因为这是二进制的压缩文件，所以查看时，会是乱码状态。 <img src="https://oss.pencilso.cn/enclosure/QQ20200610-210658@2x_1591794433375.png" alt="QQ20200610-210658@2x"></p><p>除了这种方式以外，还有手动生成快照的命令，可以通过redis的客户端，发送命令到redis，让redis生成数据快照保存下来。</p><p>先把 dump.rdb 文件删除，接着我们直接使用 “src/redis-cli -p 6379 ” 进入redis客户端，执行save命令。</p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-211224@2x_1591794756582.png" alt="QQ20200610-211224@2x"></p><p>这时候再次进入dir 目录下，可以看到新的dump.rdb 文件生成了。</p><p>可以尝试手动将redis的进程kill掉，然后重启，会发现数据被恢复回来了。</p><p>不过需要注意的是，save是一个同步命令，它会在生成快照的这个时间段，阻塞其他的命令。</p><p>bgsave，是redis提供的异步生成快照的命令（bg是background的简写），当redis的单线程解析到 “bg” 这个指令的时候，就会fork一个子进程去执行命令。</p><p>比如bgsave，就会fork出来一个子进程去生成RDB文件快照。</p><p>而且，通过配置文件的策略自动生成RDB快照，是以bgsave的命令生成的。不会阻塞客户端的其他命令。</p><p>如果要关闭RDB持久化方案，将redis.conf 配置文件中的所有save 配置注释掉即可。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>RDB快照方案的持久化，存在较大的可能，数据丢失问题。</p><p>倘若设置的60秒以内1000个更新操作则生成RDB快照，如果在这60秒以内没有达到1000个更新操作的阈值，而Redis宕机了的话，则会丢失这60秒的数据。</p><h2 id="AOF-持久化方案"><a href="#AOF-持久化方案" class="headerlink" title="AOF 持久化方案"></a>AOF 持久化方案</h2><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><p>从Redis的1.1版本开始，增加了一种AOF持久化（ append-only file ），它会将每一条更新命令以RESP协议的方式，追加在文件 “appendonly.aof” 中。</p><p>当Redis重启时，会从aof文件里读取命令，重新执行一遍，以此来恢复数据。</p><p>修改配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是否启用 AOF，  no、yes</span> </span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF保存的文件名，默认 appendonly.aof</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步策略  每秒同步一次</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>同步策略有三种</p><ul><li>appendfsync always 每次有新的命令都会执行一次fsync，追加命令到文件，安全性高，性能低下。</li><li>appendfsync everysec 每秒会执行一次fsync，把新的命令追加到文件里。倘若故障，会丢失一秒的数据。（Redis默认配置）</li><li>appendfsync no  从不fsync到文件 ，将数据交给操作系统来处理。更快，也更不安全的选择。</li></ul><p>测试一下执行多次incr命令后，是否会追加到aof文件里。</p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-221432@2x_1591798485793.png" alt="QQ20200610-221432@2x"></p><p>查看aof文件， 可以看到有6个incr指令都被追加到了appendonly.aof的文件里。<img src="https://oss.pencilso.cn/enclosure/QQ20200610-221914@2x_1591798766759.png" alt="QQ20200610-221914@2x"></p><p>这时候aof的弊端也显现出来了，就是aof的文件必然会非常的大，假设这个zhangsan字段，被incr了一万次，那么就会在aof文件里生成一万条incr指令，</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>aof里面可能会存在大量没用的指令，造成文件过大，数据恢复较慢。</p><p>那么在这种场景下，aof定期重写，可以做到一定的优化，它会定期将当前最新的数据，生成aof文件。</p><p>通过修改redis.conf配置，让redis自动执行aof重写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> aof 文件至少要达到64mb 以后才会执行aof重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure><p>可以通过 “bgrewriteaof” 指令，手动进行aof重写，而且该指令会fork一个新的子进程到后台去处理。</p><p>我们进入redis客户端，手动执行一次“bgrewriteaof”后，查看一下aof文件内容。可以明确的看到多条incr指令变成了一个set zhangsan 6 的指令。</p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-224605@2x_1591800376580.png" alt="QQ20200610-224605@2x"></p><p>redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点。</p><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>Redis重启时，我们很少用RDB来恢复数据，因为RDB可能会丢失过多的数据，通常使用AOF来恢复数据，对命令重新执行。</p><p>但是重新执行AOF，效率对于RDB来说会低很多，有可能导致恢复数据时间过长。</p><p>Redis 为了解决这个问题，引入了混合持久化。</p><p>通过配置redis.conf 可以开启混合持久化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p>开启了混合持久化后，AOF在进行重写的时候，不再是简单的最新的数据存储在apf文件中。</p><p>而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改命令存在一起，并一起存入到新的文件中。</p><p>新的文件一开始不叫“appendonly.aof”，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</p><p>在混合持久化开启下，Redis重启会先加载“appendonly.aof” 文件中的RDB数据，其次再加载“appendonly.aof” RDB后面的 AOF增量命令。</p><p>接下来测试拥有RDB和AOF增量数据的 “appendonly.aof” 文件会是什么样的。</p><p>在打开持久化后，手动执行一次AOF重写，也就是“bgrewriteaof”命令，当我们再次查看aof文件的时候，应该是下面这样的乱码，这些是RDB格式的二进制数据，因为在生成RDB之后，重写AOF之前，没有新的修改命令，所以这里看不到AOF的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REDIS0009�      redis-ver6.0.5�</span><br><span class="line">�edis-bits�@�ctime�T��^used-mem�3</span><br><span class="line"> aof-preamble��zhangsan����dD�C�A</span><br></pre></td></tr></table></figure><p>打开redis客户端，再次执行几次incr命令之后，再次查看aof文件，如下。可以看到，上面的是RDB数据，下面的是AOF增量数据。</p><p><img src="https://oss.pencilso.cn/enclosure/QQ20200610-230841@2x_1591801742677.png" alt="QQ20200610-230841@2x"></p>]]></content>
    
    
    <summary type="html">Redis 持久化，RDB、AOF、混合持久化</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
    <category term="aof" scheme="https://songlongkuan.com/tags/aof/"/>
    
    <category term="rdb" scheme="https://songlongkuan.com/tags/rdb/"/>
    
  </entry>
  
  <entry>
    <title>Redis 渐进式遍历键</title>
    <link href="https://songlongkuan.com/2020/06/10/redis_key_search/"/>
    <id>https://songlongkuan.com/2020/06/10/redis_key_search/</id>
    <published>2020-06-10T09:55:00.000Z</published>
    <updated>2021-01-31T12:10:12.421Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中难免有时候会遇到遍历key的情景，但是redis是单线程处理命令的，如果说我们采用keys * 的指令来进行遍历的话，那么很有可能会造成redis的单线程阻塞，因为这是一个耗时操作。</p><a id="more"></a><p>这个时候可以采用Redis的 scan指令，进行渐进式遍历键，也可以理解为分页遍历。防止数据量过大遍历的时间过长。</p><p>redis指令 : scan cursor match pattern count querycount</p><p>例如 : scan 0 match user* count 1000</p><p>指令中, cursor 指的是游标第一次为0，pattern指的是key的匹配正则，querycount指的是，要遍历的数量（ 注意不是匹配的数据数量 )</p><p>我们先模拟10万个用户 ，插入到Redis缓存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;generateUserCache&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateUserCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:&quot;</span> + num, String.valueOf(num));</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用scan 命令渐进式遍历键，返回的第一个数值，即下一次执行scan命令时用到的游标。</p><p>当游标为0时，则表明数据已经遍历完毕。</p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-173005@2x_1591781440678.png" alt="QQ20200610-173005@2x" style="zoom: 50%;" /><p>再次使用scan命令遍历</p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-173251@2x_1591781585146.png" alt="QQ20200610-173251@2x" style="zoom:50%;" /><p>我们尝试使用SpringBoot中的RedisTemplate来实现，RedisTemplate已经封装好了方法，直接调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;scanUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">scanUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String keyPattern = <span class="string">&quot;user*&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> queryCount = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> stringRedisTemplate.execute((RedisCallback&lt;Integer&gt;) connection -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> dataCount = <span class="number">0</span>;</span><br><span class="line">        Cursor&lt;<span class="keyword">byte</span>[]&gt; cursor = connection.scan(<span class="keyword">new</span> ScanOptions.ScanOptionsBuilder().match(keyPattern).count(queryCount).build());</span><br><span class="line">        <span class="keyword">while</span> (cursor.hasNext()) &#123;</span><br><span class="line">            String value = <span class="keyword">new</span> String(cursor.next());</span><br><span class="line">            dataCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;dataCount:[&#123;&#125;]&quot;</span>,dataCount);</span><br><span class="line">        <span class="keyword">return</span> dataCount;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果为10万，Redis中的所有user都遍历了出来。</p>]]></content>
    
    
    <summary type="html">Redis 渐进式遍历键</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 核心数据结构</title>
    <link href="https://songlongkuan.com/2020/06/08/redis_core_data_structure/"/>
    <id>https://songlongkuan.com/2020/06/08/redis_core_data_structure/</id>
    <published>2020-06-08T15:23:00.000Z</published>
    <updated>2021-01-31T12:01:59.236Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 具有五种核心数据结构。</p><ol><li>String 结构，该结构用来存储字符串数据。</li><li>Hash 结构，该结构用来存储key value 键值对，可以理解为嵌套map 。</li><li>List 列表，该结构用来存储列表数据，还可以用来当做队列结构，和栈结构。</li><li>Set集合，该结构存储的数据不允许重复。</li><li>ZSet集合，该结构是一个有序的Set集合，排序条件是分值Scores 。</li></ol><a id="more"></a><h2 id="Redis-String数据结构"><a href="#Redis-String数据结构" class="headerlink" title="Redis String数据结构"></a>Redis String数据结构</h2><h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><h6 id="插入字符串键值对"><a href="#插入字符串键值对" class="headerlink" title="插入字符串键值对"></a>插入字符串键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令: set key value </span><br><span class="line"></span><br><span class="line">例如:  set user:zhangsan 10086</span><br></pre></td></tr></table></figure><h6 id="批量插入字符串键值对"><a href="#批量插入字符串键值对" class="headerlink" title="批量插入字符串键值对"></a>批量插入字符串键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令: mset key value key value ....</span><br><span class="line"></span><br><span class="line">例如: mset user:zhangsan 10086  user:lisi 10010 user:wangwu 10000</span><br></pre></td></tr></table></figure><h6 id="插入不存在的键值对"><a href="#插入不存在的键值对" class="headerlink" title="插入不存在的键值对"></a>插入不存在的键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : setnx key value</span><br><span class="line"></span><br><span class="line">例如 : setnx commodity:100 uid56</span><br></pre></td></tr></table></figure><p>该功能可以用作轻量级的分布式锁，当执行指令后，redis会判断是否数据已存在，如果不存在则新增数据并且返回1，否则返回0。</p><p>当线程获取到返回1后才可以继续执行业务，并且要在执行完毕后删除该key，也就是释放锁。</p><p>以防万一线程挂了的情况下造成死锁，理应给key加上超时时间，让redis自行删除超时数据。</p><h6 id="获取单个字符串数据"><a href="#获取单个字符串数据" class="headerlink" title="获取单个字符串数据"></a>获取单个字符串数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : get key </span><br><span class="line"></span><br><span class="line">例如 : get  user:zhangsan</span><br></pre></td></tr></table></figure><h6 id="批量获取字符串数据"><a href="#批量获取字符串数据" class="headerlink" title="批量获取字符串数据"></a>批量获取字符串数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : mget key key ....</span><br><span class="line"></span><br><span class="line">例如 : mget user:zhangsan user:lisi user:wangwu</span><br></pre></td></tr></table></figure><h6 id="删除key"><a href="#删除key" class="headerlink" title="删除key"></a>删除key</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : del key key ....</span><br><span class="line"></span><br><span class="line">例如 : del user:zhangsan user:wangwu</span><br></pre></td></tr></table></figure><h6 id="设置key的超时时间"><a href="#设置key的超时时间" class="headerlink" title="设置key的超时时间"></a>设置key的超时时间</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : expire  key  seconds</span><br><span class="line"></span><br><span class="line">例如 : expire  commodity:100  10</span><br></pre></td></tr></table></figure><h3 id="原子增减"><a href="#原子增减" class="headerlink" title="原子增减"></a>原子增减</h3><h6 id="对数据原子增-1"><a href="#对数据原子增-1" class="headerlink" title="对数据原子增 1"></a>对数据原子增 1</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : incr key</span><br><span class="line"></span><br><span class="line">例如 : incr commodity:share</span><br></pre></td></tr></table></figure><h6 id="对数据原子减-1"><a href="#对数据原子减-1" class="headerlink" title="对数据原子减 1"></a>对数据原子减 1</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : decr key </span><br><span class="line"></span><br><span class="line">例如 : decr commodity:share</span><br></pre></td></tr></table></figure><h6 id="对数据原子增-指定数值"><a href="#对数据原子增-指定数值" class="headerlink" title="对数据原子增 指定数值"></a>对数据原子增 指定数值</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : incrby key increment </span><br><span class="line"></span><br><span class="line">例如 : incrby commodity:share 1000</span><br></pre></td></tr></table></figure><h6 id="对数据原子减-指定数值"><a href="#对数据原子减-指定数值" class="headerlink" title="对数据原子减 指定数值"></a>对数据原子减 指定数值</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : decrby key increment</span><br><span class="line"></span><br><span class="line">例如 : decrby commodity:share 1000</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、计数器，例如点赞次数 、分享次数、预览次数 。</p><p>2、Web集群session共享 </p><p>3、分布式系统全局自增序列</p><h2 id="Redis-Hash数据结构"><a href="#Redis-Hash数据结构" class="headerlink" title="Redis Hash数据结构"></a>Redis Hash数据结构</h2><h3 id="Hash常用操作"><a href="#Hash常用操作" class="headerlink" title="Hash常用操作"></a>Hash常用操作</h3><h6 id="存储哈希表key的键值"><a href="#存储哈希表key的键值" class="headerlink" title="存储哈希表key的键值"></a>存储哈希表key的键值</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hset  key  field  value</span><br><span class="line"></span><br><span class="line">例如 : hset commodity:100 name 蛋黄酥</span><br></pre></td></tr></table></figure><h6 id="插入不存在的哈希表键值对"><a href="#插入不存在的哈希表键值对" class="headerlink" title="插入不存在的哈希表键值对"></a>插入不存在的哈希表键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hsetnx  key  field  value</span><br><span class="line"></span><br><span class="line">例如 : hsetnx commodity:100 edit uid56</span><br></pre></td></tr></table></figure><p>同String结构，当Redis中没有该数据时，会新增并返回1.否则返回0 。</p><h6 id="存储多个键值对"><a href="#存储多个键值对" class="headerlink" title="存储多个键值对"></a>存储多个键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hmset  key  field  value field  value ...</span><br><span class="line"></span><br><span class="line">例如 : hmset commodity:100 name 蛋黄酥 price 10</span><br></pre></td></tr></table></figure><h6 id="获取哈希表key中的键值对数量"><a href="#获取哈希表key中的键值对数量" class="headerlink" title="获取哈希表key中的键值对数量"></a>获取哈希表key中的键值对数量</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hlen  key</span><br><span class="line"></span><br><span class="line">例如 : hlen  commodity:100</span><br></pre></td></tr></table></figure><h6 id="获取哈希表key中的单个field对应的value"><a href="#获取哈希表key中的单个field对应的value" class="headerlink" title="获取哈希表key中的单个field对应的value"></a>获取哈希表key中的单个field对应的value</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hget key field</span><br><span class="line"></span><br><span class="line">例如 : hget commodity:100 edit</span><br></pre></td></tr></table></figure><h6 id="获取哈希表key中的多个field对应的value"><a href="#获取哈希表key中的多个field对应的value" class="headerlink" title="获取哈希表key中的多个field对应的value"></a>获取哈希表key中的多个field对应的value</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hmget key field field</span><br><span class="line"></span><br><span class="line">例如 : hmget commodity:100 edit share</span><br></pre></td></tr></table></figure><h6 id="获取哈希表key中的所有键值数据"><a href="#获取哈希表key中的所有键值数据" class="headerlink" title="获取哈希表key中的所有键值数据"></a>获取哈希表key中的所有键值数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hgetall  key</span><br><span class="line"></span><br><span class="line">例如 : hgetall commodity:100</span><br></pre></td></tr></table></figure><h6 id="对哈希表key中field的value数据原子增"><a href="#对哈希表key中field的value数据原子增" class="headerlink" title="对哈希表key中field的value数据原子增"></a>对哈希表key中field的value数据原子增</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hincrby  key  field  increment</span><br><span class="line"></span><br><span class="line">例如 : hincrby commodity:100 share 100</span><br></pre></td></tr></table></figure><h6 id="删除哈希表key中的键值对"><a href="#删除哈希表key中的键值对" class="headerlink" title="删除哈希表key中的键值对"></a>删除哈希表key中的键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hdel key field field field....</span><br><span class="line"></span><br><span class="line">例如 : hdel commodity:100 name price</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象缓存</p><p>例如购物车，用户id为key值，field为商品id，value 为加入购物车的数量。</p><p>当用户操作商品数量时，对value进行原子增、原子减。</p><p>hlen 命令获取购物车数量，hgetall获取所有购物车商品id 和 数量 。</p> <img src="https://oss.pencilso.cn/enclosure/WX20200608-231646@2x_1591629454263.png" alt="WX20200608-231646@2x" style="zoom:50%;" /><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点 ：</p><p>1、同类数据归类整合储存，方便数据管理<br>2、相比string操作消耗内存与cpu更小<br>3、相比string储存更节省空间</p><p>缺点：</p><p>1、过期功能不能使用在field上，只能用在key上<br>2、Redis集群架构下不适合大规模使用</p><h2 id="Redis-List数据结构"><a href="#Redis-List数据结构" class="headerlink" title="Redis List数据结构"></a>Redis List数据结构</h2><h3 id="List-常用操作"><a href="#List-常用操作" class="headerlink" title="List 常用操作"></a>List 常用操作</h3><h6 id="插入一个或多个数据到list表头-最左边"><a href="#插入一个或多个数据到list表头-最左边" class="headerlink" title="插入一个或多个数据到list表头 (最左边 )"></a>插入一个或多个数据到list表头 (最左边 )</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : lpush  key  value value ....</span><br><span class="line"></span><br><span class="line">例如 : lpush commodity:hot 100 101 102 103</span><br></pre></td></tr></table></figure><h6 id="插入一个或多个数据到list表尾-最右边"><a href="#插入一个或多个数据到list表尾-最右边" class="headerlink" title="插入一个或多个数据到list表尾 ( 最右边 )"></a>插入一个或多个数据到list表尾 ( 最右边 )</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : rpush key value value ...</span><br><span class="line"></span><br><span class="line">例如 : rpush commodity:hot 99 98 97</span><br></pre></td></tr></table></figure><h6 id="移除并返回表头元素"><a href="#移除并返回表头元素" class="headerlink" title="移除并返回表头元素"></a>移除并返回表头元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : lpop key</span><br><span class="line"></span><br><span class="line">例如 : lpop commodity:hot</span><br></pre></td></tr></table></figure><h6 id="移除并返回表尾元素"><a href="#移除并返回表尾元素" class="headerlink" title="移除并返回表尾元素"></a>移除并返回表尾元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : rpop key</span><br><span class="line"></span><br><span class="line">例如 : rpop commodity:hot</span><br></pre></td></tr></table></figure><h6 id="获取list指定区间的数据"><a href="#获取list指定区间的数据" class="headerlink" title="获取list指定区间的数据"></a>获取list指定区间的数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  lrange  key  start  stop</span><br><span class="line"></span><br><span class="line">例如 : lrange commodity:hot 1 3</span><br></pre></td></tr></table></figure><h3 id="List-阻塞操作"><a href="#List-阻塞操作" class="headerlink" title="List 阻塞操作"></a>List 阻塞操作</h3><h6 id="阻塞弹出表头的元素"><a href="#阻塞弹出表头的元素" class="headerlink" title="阻塞弹出表头的元素"></a>阻塞弹出表头的元素</h6><p>从表头弹出一个元素，若没有数据则会等待， timeout是超时时间 ( 单位为秒 ) ,倘若为0的话，则会一直等待。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : blpop  key  timeout</span><br><span class="line"></span><br><span class="line">例如 : blpop commodity:hot 10 </span><br></pre></td></tr></table></figure><h6 id="阻塞弹出表尾的元素"><a href="#阻塞弹出表尾的元素" class="headerlink" title="阻塞弹出表尾的元素"></a>阻塞弹出表尾的元素</h6><p>从表尾弹出一个元素，若没有数据则会等待， timeout是超时时间 ( 单位为秒 ) ,倘若为0的话，则会一直等待。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : brpop key timeout</span><br><span class="line"></span><br><span class="line">例如 : brpop commodity:hot 10</span><br></pre></td></tr></table></figure><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、Stack 栈数据结构，先进后出。 lpush + lpop </p><p>2、Queue 队列，先进先出。 lpush + rpop </p><p>3、Blocking MQ 阻塞队列 先进先出。lpush + brpop</p><p>4、业务场景：文章流分页查询，lrange  key  start  stop 查询区间数据 。</p><h2 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h2><h3 id="Set集合常用操作"><a href="#Set集合常用操作" class="headerlink" title="Set集合常用操作"></a>Set集合常用操作</h3><h6 id="加入数据到Set集合"><a href="#加入数据到Set集合" class="headerlink" title="加入数据到Set集合"></a>加入数据到Set集合</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : sadd key member member...</span><br><span class="line"></span><br><span class="line">例如 : sadd commodity:101:collect uid56 uid57 uid58 uid59 uid60</span><br></pre></td></tr></table></figure><p>如果数据不存在则新增，并且返回1，否则忽略执行，并且返回0 。</p><h6 id="从Set集合中移除数据"><a href="#从Set集合中移除数据" class="headerlink" title="从Set集合中移除数据"></a>从Set集合中移除数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : srem key member member...</span><br><span class="line"></span><br><span class="line">例如：srem commodity:101:collect uid56 uid57</span><br></pre></td></tr></table></figure><h6 id="获取集合中所有元素"><a href="#获取集合中所有元素" class="headerlink" title="获取集合中所有元素"></a>获取集合中所有元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  smembers  key</span><br><span class="line"></span><br><span class="line">例如 : smembers  commodity:101:collect</span><br></pre></td></tr></table></figure><h6 id="获取集合key的元素个数"><a href="#获取集合key的元素个数" class="headerlink" title="获取集合key的元素个数"></a>获取集合key的元素个数</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  scard key</span><br><span class="line"></span><br><span class="line">例如 : scard commodity:101:collect</span><br></pre></td></tr></table></figure><h6 id="判断Set集合中是否存在元素"><a href="#判断Set集合中是否存在元素" class="headerlink" title="判断Set集合中是否存在元素"></a>判断Set集合中是否存在元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sismember key  member</span><br><span class="line"></span><br><span class="line">例如 : sismember commodity:101:collect uid58</span><br></pre></td></tr></table></figure><p>存在则返回1，不存在则返回0。</p><h6 id="从Set集合随机取出指定数量元素"><a href="#从Set集合随机取出指定数量元素" class="headerlink" title="从Set集合随机取出指定数量元素"></a>从Set集合随机取出指定数量元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : srandmember  key count</span><br><span class="line"></span><br><span class="line">例如 : srandmember commodity:101:collect 2</span><br></pre></td></tr></table></figure><h6 id="从Set集合随机取出指定数量元素，并删除"><a href="#从Set集合随机取出指定数量元素，并删除" class="headerlink" title="从Set集合随机取出指定数量元素，并删除"></a>从Set集合随机取出指定数量元素，并删除</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : spop  key count</span><br><span class="line"></span><br><span class="line">例如 : spop commodity:101:collect 2</span><br></pre></td></tr></table></figure><h3 id="Set运算操作"><a href="#Set运算操作" class="headerlink" title="Set运算操作"></a>Set运算操作</h3><p>先初始化三个Set集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd commodity:101:collect uid56 uid57 uid58</span><br><span class="line"></span><br><span class="line">sadd commodity:102:collect uid57 uid58 uid59</span><br><span class="line"></span><br><span class="line">sadd commodity:103:collect uid57 uid60 uid61</span><br></pre></td></tr></table></figure><p><img src="https://oss.pencilso.cn/enclosure/QQ20200609-114153@2x_1591674138390.png" alt="QQ20200609-114153@2x"></p><h6 id="交集运算"><a href="#交集运算" class="headerlink" title="交集运算"></a>交集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sinter key key ...</span><br><span class="line"></span><br><span class="line">例如 : sinter commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>交集运算可以在多个集合中，寻找共同的数据，比如这三个集合中都有uid57，所以交集运算结果能能到uid57。</p><h6 id="交集运算-生成新的集合"><a href="#交集运算-生成新的集合" class="headerlink" title="交集运算 生成新的集合"></a>交集运算 生成新的集合</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sinterstore newkey  key key...</span><br><span class="line"></span><br><span class="line">例如 : sinterstore commodity:101-102-103:collect:sinter commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>该指令会将其他集合有交集的数据放到新的集合中，如上指令执行后，会生成一个 “commodity:101-102-103:collect:sinter” 集合。</p><h6 id="并集运算"><a href="#并集运算" class="headerlink" title="并集运算"></a>并集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sunion key  key....</span><br><span class="line"></span><br><span class="line">例如 : sunion commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>该指令会将多个集合的数据组合成一起返回</p><h6 id="并集运算-生成新的集合"><a href="#并集运算-生成新的集合" class="headerlink" title="并集运算 生成新的集合"></a>并集运算 生成新的集合</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sunionstore newkey  key key....</span><br><span class="line"></span><br><span class="line">例如 : sunionstore commodity:101-102-103:collect:sunion commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>该指令会将多个集合的数据组成一个新的集合，如上指令执行后，会生成一个 “commodity:101-102-103:collect:sunion” 集合。</p><h6 id="差集运算"><a href="#差集运算" class="headerlink" title="差集运算"></a>差集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : sdiff  key key ....</span><br><span class="line"></span><br><span class="line">例如 : sdiff  commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>差集运算是以第一个key的集合为基准，与其他集合进行匹配，最后筛选出不在其他集合中的数据。</p><p>如上指令执行后，得到的结果是uid56，因为其他两个集合都没有uid56，所以uid56被筛选出来了。</p><h6 id="差集运算-生成新的集合"><a href="#差集运算-生成新的集合" class="headerlink" title="差集运算 生成新的集合"></a>差集运算 生成新的集合</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : sdiffstore  newkey  key key...</span><br><span class="line"></span><br><span class="line">例如 : sdiffstore commodity:101-102-103:collect:diff commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>该指令会将差集数据生成到新的集合中 ，如上指令会生成一个 “commodity:101-102-103:collect:diff ” 的集合。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、列表数据不重复，点赞用户列表、分享用户列表 等等 。</p><p>2、随机抽奖，利用srandmember 、spop 指令随机抽取。</p><p>3、并集运算、交集运算、差集运算。</p><h2 id="ZSet-数据结构"><a href="#ZSet-数据结构" class="headerlink" title="ZSet 数据结构"></a>ZSet 数据结构</h2><h3 id="ZSet-常用操作"><a href="#ZSet-常用操作" class="headerlink" title="ZSet 常用操作"></a>ZSet 常用操作</h3><h6 id="添加带分值元素"><a href="#添加带分值元素" class="headerlink" title="添加带分值元素"></a>添加带分值元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zadd key score member score member ...</span><br><span class="line"></span><br><span class="line">例如 : zadd article:hotlist 100 article1 101 article2 102 article3</span><br></pre></td></tr></table></figure><h6 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zrem key member member...</span><br><span class="line"></span><br><span class="line">例如 : zrem article:hotlist article1 article2</span><br></pre></td></tr></table></figure><h6 id="查询元素的分值"><a href="#查询元素的分值" class="headerlink" title="查询元素的分值"></a>查询元素的分值</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zscore key member</span><br><span class="line"></span><br><span class="line">例如 : zscore article:hotlist article3</span><br></pre></td></tr></table></figure><h6 id="对元素分值增加"><a href="#对元素分值增加" class="headerlink" title="对元素分值增加"></a>对元素分值增加</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zincrby key increment member</span><br><span class="line"></span><br><span class="line">例如 : zincrby article:hotlist 100 article3</span><br></pre></td></tr></table></figure><h6 id="获取集合中的元素个数"><a href="#获取集合中的元素个数" class="headerlink" title="获取集合中的元素个数"></a>获取集合中的元素个数</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zcard key</span><br><span class="line"></span><br><span class="line">例如 : zcard article:hotlist </span><br></pre></td></tr></table></figure><h6 id="正序获取区间元素"><a href="#正序获取区间元素" class="headerlink" title="正序获取区间元素"></a>正序获取区间元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zrange key start stop </span><br><span class="line"></span><br><span class="line">例如 : zrange article:hotlist  0 1</span><br></pre></td></tr></table></figure><p>如果需要连分值一起获取的话，在指令后面加上withscores即可，例: zrange article:hotlist  0 1 withscores</p><h6 id="倒序获取区间元素"><a href="#倒序获取区间元素" class="headerlink" title="倒序获取区间元素"></a>倒序获取区间元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zrevrange  key start stop</span><br><span class="line"></span><br><span class="line">例如 : zrevrange  article:hotlist 0 1</span><br></pre></td></tr></table></figure><h3 id="ZSet-集合操作"><a href="#ZSet-集合操作" class="headerlink" title="ZSet 集合操作"></a>ZSet 集合操作</h3><p>准备两个集合数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zincrby article:hotlist:20200608 2 article1</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200608 1 article2</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200608 1 article3</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 4 article1</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 2 article2</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 1 article6</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 1 article4</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 1 article3</span><br></pre></td></tr></table></figure><p>这时候数据应该是这样的  <img src="https://oss.pencilso.cn/enclosure/QQ20200609-143312@2x_1591684411678.png" alt="20200608"></p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200609-143537@2x_1591684569390.png" alt="20200609"></p><h6 id="并集运算-1"><a href="#并集运算-1" class="headerlink" title="并集运算"></a>并集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  zunionstore newkey numkeys key key ...</span><br><span class="line"></span><br><span class="line">例如 : zunionstore article:hotlist:20200608-20200609  2 article:hotlist:20200608 article:hotlist:20200609</span><br></pre></td></tr></table></figure><p>指令中numkeys 用来表示要计算的集合数量。</p><p>将多个集合组合起来，并且会叠加分值，生成一个新的集合，如上执行后，会生成新的 “article:hotlist:20200608-20200609” 集合。</p><h6 id="交集运算-1"><a href="#交集运算-1" class="headerlink" title="交集运算"></a>交集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zinterstore newkey numkeys key key ...</span><br><span class="line"></span><br><span class="line">例如 : zinterstore article:hotlist:insterstore 2 article:hotlist:20200608 article:hotlist:20200609</span><br></pre></td></tr></table></figure><p>指令中numkeys 用来表示要计算的集合数量。</p><p>将多个集合进行交集运算，并且会叠加分值，生成一个新的集合，如上执行后，会生成新的 “article:hotlist:insterstore” 集合。</p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、排行榜，通过分值让redis自行排序。</p><p>2、近期排行榜，通过redis并集计算，生成近期排行榜。</p>]]></content>
    
    
    <summary type="html">Redis 核心数据结构、常用命令</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
  </entry>
  
</feed>
