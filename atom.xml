<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋龙宽|个人博客</title>
  
  
  <link href="https://songlongkuan.com/atom.xml" rel="self"/>
  
  <link href="https://songlongkuan.com/"/>
  <updated>2021-01-06T05:16:50.019Z</updated>
  <id>https://songlongkuan.com/</id>
  
  <author>
    <name>宋龙宽|个人博客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java之ThreadLocal</title>
    <link href="https://songlongkuan.com/2020/09/12/java_threadlocal/"/>
    <id>https://songlongkuan.com/2020/09/12/java_threadlocal/</id>
    <published>2020-09-12T07:30:16.000Z</published>
    <updated>2021-01-06T05:16:50.019Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</p><h2 id="ThreadLocal的简单应用"><a href="#ThreadLocal的简单应用" class="headerlink" title="ThreadLocal的简单应用"></a>ThreadLocal的简单应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread-<span class="number">1</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">1</span> 执行前数后:张三</span><br><span class="line">thread-<span class="number">2</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">2</span> 执行前数后:李四</span><br></pre></td></tr></table></figure><p>由此可以得出结论，threadLocal是线程之间隔离的数据存储方式。</p><a id="more"></a><h2 id="ThreadLocal-的问题"><a href="#ThreadLocal-的问题" class="headerlink" title="ThreadLocal 的问题"></a>ThreadLocal 的问题</h2><p>ThreadLocal在线程池中应用的话是会产生问题的，我们知道线程池它是会对线程进行重复利用，也就是说可能放几个任务到线程池中执行最后都是由一个KLT线程去运行的。</p><p>线程池+ThreadLocal问题重现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：张三</span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><p>可以观察到，runnable2执行的时候拿到了runnable1置入的”张三”，这时候已经不是逻辑上的隔离了，因为线程复用导致ThreadLocal里面的数据没有释放，从而导致下一次在线程池运行任务的时候，获取到的数据还是上一个线程置入的数据。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案-1"></a>解决方案-1</h2><p>第一种解决方案，就是在线程执行之前清空一下ThreadLocal，至于线程执行结束的话，系统会自动清理。</p><p>改造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">   <span class="comment">//设置为nulll</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">    <span class="comment">//设置为null</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行输出结果如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案-2"></a>解决方案-2</h2><p>第二种解决方案的话，主要是从线程池入手，线程池有一个执行线程任务前的拦截方法，可以在Runnable执行之前执行。</p><p>再次改造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>)) &#123;</span><br><span class="line">          <span class="comment">//重写beforeExecute方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">                <span class="comment">//统一把ThreadLocal设置为null</span></span><br><span class="line">                threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal实现的原理"><a href="#ThreadLocal实现的原理" class="headerlink" title="ThreadLocal实现的原理"></a>ThreadLocal实现的原理</h2><h3 id="ThreadLocal-的set方法"><a href="#ThreadLocal-的set方法" class="headerlink" title="ThreadLocal 的set方法"></a>ThreadLocal 的set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//如果map已创建  则置入数据 </span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//如果map还未创建 则创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的createMap方法"><a href="#ThreadLocal的createMap方法" class="headerlink" title="ThreadLocal的createMap方法"></a>ThreadLocal的createMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实例化一个ThreadLocalMap对象 并且赋值到thread.threadLocals字段里面</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的getMap方法"><a href="#ThreadLocal的getMap方法" class="headerlink" title="ThreadLocal的getMap方法"></a>ThreadLocal的getMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//直接获取的thread里面的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thread中的threadLocals字段"><a href="#Thread中的threadLocals字段" class="headerlink" title="Thread中的threadLocals字段"></a>Thread中的threadLocals字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>ThreadLocal其实就是封装了调用Thread成员变量里面ThreadLocalMap类型的threadlocals变量的过程。</p><p>这个ThreadLocalMap其实就是一个简化的hashmap。</p><p>如果说程序的调用链路比较长，假设一个请求需要调用10个方法，而只有第一个方法和最后一个方法需要一个”userId” 数据，如果我们给10个方法都加上”userId” 参数进行传递固然是可以解决，但是冗余了代码，而使用ThreadLocal后只需要在第一个和最后一个方法种调用ThreadLocal即可。</p><p>再比如说Mybatis的分页插件 PageHelper.startPage就是通过ThreadLocal把page参数放到了ThreadLocal中。</p>]]></content>
    
    
    <summary type="html">ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://songlongkuan.com/tags/Java/"/>
    
    <category term="ThreadLocal" scheme="https://songlongkuan.com/tags/ThreadLocal/"/>
    
  </entry>
  
</feed>
