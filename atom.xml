<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋龙宽|个人博客</title>
  
  
  <link href="https://songlongkuan.com/atom.xml" rel="self"/>
  
  <link href="https://songlongkuan.com/"/>
  <updated>2021-01-07T01:51:50.469Z</updated>
  <id>https://songlongkuan.com/</id>
  
  <author>
    <name>宋龙宽|个人博客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LRU缓存淘汰策略</title>
    <link href="https://songlongkuan.com/2020/11/29/algorithm_lru_cache/"/>
    <id>https://songlongkuan.com/2020/11/29/algorithm_lru_cache/</id>
    <published>2020-11-29T02:56:00.000Z</published>
    <updated>2021-01-07T01:51:50.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LRU淘汰算法主要目的：在已知限制大小的容器中，当容器满了的情况还有元素放入容器时，移出最久未使用元素。</p><ul><li>LRU淘汰算法可以用链表来实现</li><li>当一个新元素放入容器，将会插入到链表的表头</li><li>当从容器中查询某一个元素，会将链表中的该元素删除，再重新插入到链表的表头</li><li>而那些旧元素且没有查询操作的元素就会沉淀在链表的底部，当容器满了的情况会逐一删除。</li></ul><a id="more"></a><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>假设现在设定一个容器只能最大存储5个元素，已知存储了”张三-&gt;李四-&gt;王五-&gt;赵六-&gt;麻子”。</p><p>链表头为张三，链表尾为麻子，如下图所示。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_1_1606617279798.png" alt="lru_1"></p><h4 id="插入新元素"><a href="#插入新元素" class="headerlink" title="插入新元素"></a>插入新元素</h4><p>假设现在又要放入一个新元素：”小二”，应将”小二” 插入到张三的前面，而麻子则删除，并且尾部指针指向到赵六。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_2_1606617531882.png" alt="lru_2"></p><h4 id="查询旧元素"><a href="#查询旧元素" class="headerlink" title="查询旧元素"></a>查询旧元素</h4><p>假设现在要从容器中查询 “李四”，因为”李四”已经存在于链表中所以应先从链表删除”李四”，再将”李四”插入到链表的头部，并将链表的头部指针指向到”李四”。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_3_1606617851297.png" alt="lru_3"></p><h2 id="Java的代码实现"><a href="#Java的代码实现" class="headerlink" title="Java的代码实现"></a>Java的代码实现</h2><h4 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU缓存淘汰策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限制大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limitSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru已存储大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lruSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, LRUCacheValue&lt;K, V&gt;&gt; cache;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru-指针-头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LRUCacheNode&lt;K&gt; head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru-指针-尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LRUCacheNode&lt;K&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> limitSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limitSize = limitSize;</span><br><span class="line">        <span class="comment">//初始化HashMap的大小</span></span><br><span class="line">        <span class="keyword">int</span> initialCapacity = (<span class="keyword">int</span>) Math.round((<span class="keyword">float</span>) limitSize / <span class="number">0.75</span>);</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="comment">//如果当前lru已经满了的話  删除最后一个</span></span><br><span class="line">            K removeLruTailKey = removeLruTail();</span><br><span class="line">            cache.remove(removeLruTailKey);</span><br><span class="line">            lruSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lruCacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个key在lru缓存中是存在的話  先进行删除 remove操作</span></span><br><span class="line">            removeLruNode(lruCacheValue.node);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key, <span class="keyword">new</span> LRUCacheValue&lt;K, V&gt;(value, insertLruHead(key)));</span><br><span class="line">        lruSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lruCacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        removeLruNode(lruCacheValue.node);</span><br><span class="line">        <span class="comment">//压入链表节点</span></span><br><span class="line">        lruCacheValue.node = insertLruHead(key);</span><br><span class="line">        <span class="keyword">return</span> lruCacheValue.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.tail == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否满了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lruSize &gt;= limitSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历打印所有lru链表中的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LRUCacheNode&lt;K&gt; curr = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span> + curr.key);</span><br><span class="line">        &#125; <span class="keyword">while</span> ((curr = curr.next) != <span class="keyword">null</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;lrusize:&quot;</span> + lruSize + <span class="string">&quot; cacheCount:&quot;</span> + cache.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入到lru-头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LRUCacheNode&lt;K&gt; <span class="title">insertLruHead</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        LRUCacheNode&lt;K&gt; lruCacheNode = <span class="keyword">new</span> LRUCacheNode&lt;&gt;(key);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = lruCacheNode;</span><br><span class="line">            <span class="keyword">this</span>.tail = lruCacheNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lruCacheNode.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head.prew = lruCacheNode;</span><br><span class="line">            <span class="keyword">this</span>.head = lruCacheNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lruCacheNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除lru最后一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> K <span class="title">removeLruTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暂存key</span></span><br><span class="line">        K key = <span class="keyword">this</span>.tail.key;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            <span class="comment">//只有一个节点</span></span><br><span class="line">            removeAll();</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tail.prew != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tail.prew.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点指向到尾节点的prew节点</span></span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">this</span>.tail.prew;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除全部链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定节点的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLruNode</span><span class="params">(LRUCacheNode&lt;K&gt; cacheNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.head &amp;&amp; cacheNode == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            removeAll();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheNode.next.prew = cacheNode.prew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode.prew != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheNode.prew.next = cacheNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            <span class="comment">//要删除的是head指针</span></span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            <span class="comment">//要删除的是tail指针</span></span><br><span class="line">            <span class="keyword">this</span>.tail = cacheNode.prew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheValue</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; node;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheValue</span><span class="params">(V value, LRUCacheNode&lt;K&gt; node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheNode</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; prew;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheNode</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>先检查是否容器已满，如果满了的情况删除最后一个链表的元素，并且从map集合中remove。</p><p>如果这个key已经存在于lru链表中，将lru中的该元素删除。</p><p>插入key到链表的头部</p><p>最后把数据放入到map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        <span class="comment">//如果当前lru已经满了的話  删除最后一个</span></span><br><span class="line">        K removeLruTailKey = removeLruTail();</span><br><span class="line">        cache.remove(removeLruTailKey);</span><br><span class="line">        lruSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lruCacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果这个key在lru缓存中是存在的話  先进行删除 remove操作</span></span><br><span class="line">        removeLruNode(lruCacheValue.node);</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(key, <span class="keyword">new</span> LRUCacheValue&lt;K, V&gt;(value, insertLruHead(key)));</span><br><span class="line">    lruSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>如果key存在于map中，则删除这个key在链表中的元素。</p><p>将这个key重新插入到链表的头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lruCacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    removeLruNode(lruCacheValue.node);</span><br><span class="line">    <span class="comment">//压入链表节点</span></span><br><span class="line">    lruCacheValue.node = insertLruHead(key);</span><br><span class="line">    <span class="keyword">return</span> lruCacheValue.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>循环放入1万个数字，且是自增的数字，每次放入后都查询一下key为0、1的元素。</p><p>理论上，因为每次插入数据都会查询0、1，所以最后链表肯定1、0在最前面。再往后就是99999-99992</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; lruCache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            lruCache.put(i, String.valueOf(i));</span><br><span class="line">            lruCache.get(<span class="number">0</span>);</span><br><span class="line">            lruCache.get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lruCache.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果输出如下- 符合理论预期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key:1</span><br><span class="line">key:0</span><br><span class="line">key:99999</span><br><span class="line">key:99998</span><br><span class="line">key:99997</span><br><span class="line">key:99996</span><br><span class="line">key:99995</span><br><span class="line">key:99994</span><br><span class="line">key:99993</span><br><span class="line">key:99992</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LRU淘汰算法主要目的：在已知限制大小的容器中，当容器满了的情况还有元素放入容器时，移出最久未使用元素。</summary>
    
    
    
    <category term="算法" scheme="https://songlongkuan.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LRU" scheme="https://songlongkuan.com/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="https://songlongkuan.com/2020/11/26/data_structure_stack/"/>
    <id>https://songlongkuan.com/2020/11/26/data_structure_stack/</id>
    <published>2020-11-26T13:27:00.000Z</published>
    <updated>2021-01-07T01:49:41.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈结构是遵循先进后出，后进先出的 First In Last Out（FILO）。</p><p>而实现栈结构的方式有数组、链表。</p><ul><li><p>数组实现</p><ul><li>效率高，因为数组是一块连续的空间，CPU加载内存时会加载一片连续的内存。</li><li>需要对数组进行动态的扩容、缩容。</li></ul></li><li><p>链表实现</p><ul><li>效率相对数组要低，因为它的对象内存地址不连续。</li><li>内存空间占用更大，因为每个节点都需要包含next指针。</li><li>理论上可以无限压入数据到栈，但是可能会溢出。</li><li>不需要考虑扩容、缩容、下标越界。</li></ul><a id="more"></a></li></ul><p><img src="https://oss.pencilso.cn/enclosure/stack_1_1606395677610.png" alt="stack_1"></p><p>大多数场景下还是用数组实现的栈结构更多，因为它的性能更高。</p><p>先创建一个接口，再由子类去实现它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Item <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="栈-数组实现"><a href="#栈-数组实现" class="headerlink" title="栈-数组实现"></a>栈-数组实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cap = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Item table[] = (Item[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        judgeSize();</span><br><span class="line">        <span class="keyword">this</span>.table[size++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        judgeSize();</span><br><span class="line">        Item item = <span class="keyword">this</span>.table[--size];</span><br><span class="line">        <span class="keyword">this</span>.table[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验数组是否要扩容 或者缩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">judgeSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt;= <span class="keyword">this</span>.table.length) &#123;</span><br><span class="line">            <span class="comment">//扩容两倍</span></span><br><span class="line">            resize(<span class="keyword">this</span>.table.length * <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt;= cap &amp;&amp; (<span class="keyword">this</span>.table.length / <span class="number">2</span>) &gt; size) &#123;</span><br><span class="line">            <span class="comment">//如果当前元素数量大于cap 并且小于数组长度的一半  则对数组缩容一半</span></span><br><span class="line">            resize(<span class="keyword">this</span>.table.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> resize)</span> </span>&#123;</span><br><span class="line">        Item[] tempTable = (Item[]) <span class="keyword">new</span> Object[resize];</span><br><span class="line">        <span class="comment">//克隆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            tempTable[i] = <span class="keyword">this</span>.table[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.table = tempTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack&lt;String&gt; arrayStack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">        arrayStack.push(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">----- 输出结果如下所示</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="栈-链表实现"><a href="#栈-链表实现" class="headerlink" title="栈-链表实现"></a>栈-链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        LinkedStackNode&lt;Item&gt; newNode = <span class="keyword">new</span> LinkedStackNode&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.prew = tail;</span><br><span class="line">            tail.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedStackNode&lt;Item&gt; tempTail = <span class="keyword">this</span>.tail;</span><br><span class="line">        <span class="keyword">if</span> (tempTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">this</span>.tail = tempTail.prew;</span><br><span class="line">            <span class="keyword">return</span> tempTail.getData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStackNode</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedStackNode</span><span class="params">(Item data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Item data;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; prew;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; arrayStack = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        arrayStack.push(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">----- 输出结果如下所示</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java数组、链表实现实现 数据结构-栈</summary>
    
    
    
    <category term="数据结构" scheme="https://songlongkuan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈" scheme="https://songlongkuan.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Java之ThreadLocal</title>
    <link href="https://songlongkuan.com/2020/09/12/java_threadlocal/"/>
    <id>https://songlongkuan.com/2020/09/12/java_threadlocal/</id>
    <published>2020-09-12T07:30:16.000Z</published>
    <updated>2021-01-07T01:40:48.329Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</p><h2 id="ThreadLocal的简单应用"><a href="#ThreadLocal的简单应用" class="headerlink" title="ThreadLocal的简单应用"></a>ThreadLocal的简单应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread-<span class="number">1</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">1</span> 执行前数后:张三</span><br><span class="line">thread-<span class="number">2</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">2</span> 执行前数后:李四</span><br></pre></td></tr></table></figure><p>由此可以得出结论，threadLocal是线程之间隔离的数据存储方式。</p><a id="more"></a><h2 id="ThreadLocal-的问题"><a href="#ThreadLocal-的问题" class="headerlink" title="ThreadLocal 的问题"></a>ThreadLocal 的问题</h2><p>ThreadLocal在线程池中应用的话是会产生问题的，我们知道线程池它是会对线程进行重复利用，也就是说可能放几个任务到线程池中执行最后都是由一个KLT线程去运行的。</p><p>线程池+ThreadLocal问题重现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：张三</span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><p>可以观察到，runnable2执行的时候拿到了runnable1置入的”张三”，这时候已经不是逻辑上的隔离了，因为线程复用导致ThreadLocal里面的数据没有释放，从而导致下一次在线程池运行任务的时候，获取到的数据还是上一个线程置入的数据。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案-1"></a>解决方案-1</h2><p>第一种解决方案，就是在线程执行之前清空一下ThreadLocal，至于线程执行结束的话，系统会自动清理。</p><p>改造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">   <span class="comment">//设置为nulll</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">    <span class="comment">//设置为null</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行输出结果如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案-2"></a>解决方案-2</h2><p>第二种解决方案的话，主要是从线程池入手，线程池有一个执行线程任务前的拦截方法，可以在Runnable执行之前执行。</p><p>再次改造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>)) &#123;</span><br><span class="line">          <span class="comment">//重写beforeExecute方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">                <span class="comment">//统一把ThreadLocal设置为null</span></span><br><span class="line">                threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal实现的原理"><a href="#ThreadLocal实现的原理" class="headerlink" title="ThreadLocal实现的原理"></a>ThreadLocal实现的原理</h2><h3 id="ThreadLocal-的set方法"><a href="#ThreadLocal-的set方法" class="headerlink" title="ThreadLocal 的set方法"></a>ThreadLocal 的set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//如果map已创建  则置入数据 </span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//如果map还未创建 则创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的createMap方法"><a href="#ThreadLocal的createMap方法" class="headerlink" title="ThreadLocal的createMap方法"></a>ThreadLocal的createMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实例化一个ThreadLocalMap对象 并且赋值到thread.threadLocals字段里面</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的getMap方法"><a href="#ThreadLocal的getMap方法" class="headerlink" title="ThreadLocal的getMap方法"></a>ThreadLocal的getMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//直接获取的thread里面的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thread中的threadLocals字段"><a href="#Thread中的threadLocals字段" class="headerlink" title="Thread中的threadLocals字段"></a>Thread中的threadLocals字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal总结"><a href="#ThreadLocal总结" class="headerlink" title="ThreadLocal总结"></a>ThreadLocal总结</h3><p>ThreadLocal其实就是封装了调用Thread对象中ThreadLocalMap类型的threadlocals变量的过程。</p><p>至于ThreadLocalMap其实就是一个简化的hashmap。</p><p>如果说程序的调用链路比较长，假设一个请求需要调用10个方法，而只有第一个方法和最后一个方法需要一个”userId” 数据，如果我们给10个方法都加上”userId” 参数进行传递固然是可以解决，但是冗余了代码，而使用ThreadLocal后只需要在第一个和最后一个方法种调用ThreadLocal即可。</p><p>再比如说Mybatis的分页插件 PageHelper.startPage就是通过ThreadLocal把page参数放到了ThreadLocal中。</p><h2 id="ThreadLocal在线程间传递的问题"><a href="#ThreadLocal在线程间传递的问题" class="headerlink" title="ThreadLocal在线程间传递的问题"></a>ThreadLocal在线程间传递的问题</h2><p>ThreadLocal是线程独享的数据，是线程安全的，但是多线程开发过程中，可能会存在将一个线程的ThreadLocal数据传递给子线程的ThreadLocal。</p><h3 id="举例问题复现"><a href="#举例问题复现" class="headerlink" title="举例问题复现"></a>举例问题复现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------  输出结果如下  ----------</span><br><span class="line">当前线程中获取用户ID:<span class="number">1000</span></span><br><span class="line">子线程中获取用户ID：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>我们假设需要启动子线程去执行一些耗时任务，而子线程中需要ThreadLocal中的数据，那么这个时候子线程是获取不到的，当然我们也可以通过参数传递的方式把用户id传到thread对象中。<br>再举例一个场景，对请求的链路追踪，如果在程序在接到请求后，用子线程执行了某些耗时任务，那么也会追踪不到子线程中执行的哪些方法，因为ThreadLocal无法传递到子线程。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们将ThreadLocal 换成 InheritableThreadLocal 即可解决，如下代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------  输出结果如下  ----------</span><br><span class="line">当前线程中获取用户ID:<span class="number">1000</span></span><br><span class="line">子线程中获取用户ID：<span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="InheritableThreadLocal-源码解析-、Thread部分源码"><a href="#InheritableThreadLocal-源码解析-、Thread部分源码" class="headerlink" title="InheritableThreadLocal 源码解析 、Thread部分源码"></a>InheritableThreadLocal 源码解析 、Thread部分源码</h3><p>查看InheritableThreadLocal源码的时候，能看到InheritableThreadLocal只是继承自ThreadLocal 并且重写了三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继承可继承的inheritableThreadLocals 时会调用到该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写获取map方法，返回可继承的map对象</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写创建map方法，把创建出来的map赋值给可继承的 t.inheritableThreadLocals</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想弄明白InheritableThreadLocal的实现原理，需要先了解了解Thread的源码，接下来先写部分Thread的源码解析。<br>Thread的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 不可继承，ThreadLocal就是用的这个成员变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 可继承，InheritableThreadLocal 用的是这个变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>在Thread的构造方法中，会调用一个初始化方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//inheritThreadLocals 是否继承，默认为true   </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//现在的代码执行阶段还在Thread构造方法中调用的，所以这里currentThread 获取的还是当前线程，并不是未来将要开启的子线程。当前线程就是未来要开启的子线程的父级。</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果inheritThreadLocals = true 并且 父级的inheritableThreadLocals对象不为空</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">//根据父级的inheritableThreadLocals 创建一个新的map，并且赋值给新的Thread.inheritableThreadLocals 。</span></span><br><span class="line">               <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                   ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据父级的map，创建新的map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//ThreadLocalMap 的构造方法（复制父map的内容）</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//map中的table（数组）</span></span><br><span class="line">     Entry[] parentTable = parentMap.table;</span><br><span class="line">     <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">     setThreshold(len);</span><br><span class="line">     <span class="comment">//创建新的数组，这个tbale变量在ThreadLocalMap的成员属性中</span></span><br><span class="line">     table = <span class="keyword">new</span> Entry[len];    <span class="comment">//this.table = new Entry[len];</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//遍历数组</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        </span><br><span class="line">         Entry e = parentTable[j];</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从Entry中，拿到ThreadLocal</span></span><br><span class="line">             ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用ThreadLocal.childValue 方法， InheritableThreadLocal就重写了这个方法</span></span><br><span class="line">                 Object value = key.childValue(e.value);</span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">//接下来就是计算hash，然后决定将key放到哪里。</span></span><br><span class="line">                 Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                 <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                 <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                     h = nextIndex(h, len);</span><br><span class="line">                 table[h] = c;</span><br><span class="line">                 size++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure><p>以上是Thread对 可继承的inheritableThreadLocals 变量所做的一系列操作过程。</p><p>InheritableThreadLocal 总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用InheritableThreadLocal.set方法，而set方法第一次执行会调用createMap方法，而createMap已经被InheritableThreadLocal这个类重写。</span></span><br><span class="line">      <span class="comment">//所以创建出来的map会存储在inheritableThreadLocals变量中</span></span><br><span class="line">      threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这个get方法，里面实际是调用了一次getMap方法，而getMap也被inheritableThreadLocals重写，返回的是inheritableThreadLocals变量map。所以能拿到值。</span></span><br><span class="line">      System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//new Thread会执行一系列的初始化操作</span></span><br><span class="line">      <span class="comment">//1、判断inheritableThreadLocals=true （默认为true）</span></span><br><span class="line">      <span class="comment">//2、判断parent.inheritableThreadLocals !=null (我们放了一个id:1000在里面，所以不为空)</span></span><br><span class="line">      <span class="comment">//3、根据parent.inheritableThreadLocals 创建新的map对象，并且赋值到新的Thread.inheritableThreadLocals变量中（new Thread（）中)</span></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这个时候，Thread.inheritableThreadLocals已经继承了父级的数据，所以能拿到。</span></span><br><span class="line">          System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://songlongkuan.com/tags/Java/"/>
    
    <category term="ThreadLocal" scheme="https://songlongkuan.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之Executor线程池原理、增强拒绝策略</title>
    <link href="https://songlongkuan.com/2020/08/30/concurrent_executor_thread/"/>
    <id>https://songlongkuan.com/2020/08/30/concurrent_executor_thread/</id>
    <published>2020-08-30T04:48:00.000Z</published>
    <updated>2021-01-07T01:43:41.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是调度CPU资源的最小单位，线程模型分为KLT模型、ULT模型，JVM使用的KLT模型。因此Java线程与OS线程保持1:!的映射关系，也就是说一个Java线程也会在操作系统里有一个对应的线程。</p><p>Java线程有多种生命状态：</p><ul><li>NEW：新建</li><li>RUNNABLE：运行</li><li>BLOCKED：阻塞</li><li>WAITING：等待</li><li>TIMED_WAITING：超时等待</li><li>TERMINATED：终结</li></ul><a id="more"></a><p> <img src="https://oss.pencilso.cn/enclosure/thread_excter_1_1598748857919.png" alt="thread_excter_1"></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>这里记录一下协程相关的资料，协程（纤程、用户级线程），主要目的是为了追求最大力度的发挥硬件性能和提升软件的速度。</p><p>协程的基本原理：在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务，等完成或达到某个条件时，再还原原来的栈信息并继续执行，（整个过程不需要上下文切换）</p><p>协程是用户级线程ULT模型，多个协程由一个线程所处理，协程的创建与销毁由程序自己来控制，当提交了多个线程任务，那么最终都是由一个KLT线程去顺序执行这些协程的任务。以此避免KLT线程之间的切换。</p><p>Java原生是不支持协程的，在纯Java代码里需要使用协程的话需要引入第三方包，如：quasar</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>“线程池” 顾名思义就是一个线程缓存，线程时稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程统一分配、调优、监控。</p><h3 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h3><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行 处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p><ul><li>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁 线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</li></ul><p>线程池的解决方案：线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上，适合以下场景使用线程池：</p><ul><li>单个任务处理时间短</li><li>需要处理的任务数量很大</li></ul><h3 id="线程池优势"><a href="#线程池优势" class="headerlink" title="线程池优势"></a>线程池优势</h3><ul><li>重用存在的线程，减少线程创建，消亡的开销，提高性能</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资 源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p>1、Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImp</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadImp</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Callable（与前两种不同的是，Callable可以在执行任务后带有返回内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableImp</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图为它的继承与实现 <img src="https://oss.pencilso.cn/enclosure/thread_excter_2_1598752817575.png" alt="thread_excter_2"></p><p>从图中可以看出Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体行为</p><ol><li>execute（Runnable command）：履行Ruannable类型的任务,</li><li>submit（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future 对象</li><li>shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,</li><li>shutdownNow（）：停止所有正在履行的任务并封闭办事。</li><li>isTerminated（）：测试是否所有任务都履行完毕了。</li><li>isShutdown（）：测试是否该ExecutorService已被关闭。</li></ol><h3 id="ThreadPoolExecutor线程池重点属性"><a href="#ThreadPoolExecutor线程池重点属性" class="headerlink" title="ThreadPoolExecutor线程池重点属性"></a>ThreadPoolExecutor线程池重点属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>)); </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存 workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p><p>ctl相关方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><ul><li>runStateOf：获取运行状态；</li><li>workerCountOf：获取活动线程数；</li><li>ctlOf：获取运行状态和活动线程数的值。</li></ul><p>线程池存在5种状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UNNING = ‐1 &lt;&lt; COUNT_BITS; //高3位为111 </span><br><span class="line">SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //高3位为000 </span><br><span class="line">STOP = 1 &lt;&lt; COUNT_BITS; //高3位为001 </span><br><span class="line">TIDYING = 2 &lt;&lt; COUNT_BITS; //高3位为010 </span><br><span class="line">TERMINATED = 3 &lt;&lt; COUNT_BITS; //高3位为011</span><br></pre></td></tr></table></figure><p>1、RUNNING</p><p>​    (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行 处理。</p><p>​     (02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处 于RUNNING状态，并且线程池中的任务数为0！</p><p>2、 SHUTDOWN </p><p>​    (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</p><p>​     (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p><p>3、STOP </p><p>​    (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中 断正在处理的任务。 </p><p>​    (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p><p>4、TIDYING </p><p>​    (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING 状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在 ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理； 可以通过重载terminated()函数来实现。 </p><p>​    (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也 为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的 任务为空时，就会由STOP -&gt; TIDYING。</p><p>5、 TERMINATED<br>    (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。</p><p>​     (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING - &gt; TERMINATED。 进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TIDYING状态或TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； workerCount为0； 设置TIDYING状态成功。</p><h3 id="线程池的具体实现"><a href="#线程池的具体实现" class="headerlink" title="线程池的具体实现"></a>线程池的具体实现</h3><p>ThreadPoolExecutor 默认线程池</p><p>ScheduledThreadPoolExecutor 定时线程池</p><h2 id="线程池-ThreadPoolExecutor"><a href="#线程池-ThreadPoolExecutor" class="headerlink" title="线程池 ThreadPoolExecutor"></a>线程池 ThreadPoolExecutor</h2><h3 id="线程池ThreadPoolExecutor的创建"><a href="#线程池ThreadPoolExecutor的创建" class="headerlink" title="线程池ThreadPoolExecutor的创建"></a>线程池ThreadPoolExecutor的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span></span><br></pre></td></tr></table></figure><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize：</span><br><span class="line">    线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</span><br><span class="line"></span><br><span class="line">maximumPoolSize：</span><br><span class="line">    线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。</span><br><span class="line"></span><br><span class="line">keepAliveTime：</span><br><span class="line">    线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime.</span><br><span class="line"></span><br><span class="line">unit：</span><br><span class="line">    keepAliveTime的单位。</span><br><span class="line"></span><br><span class="line">workQueue：</span><br><span class="line">    用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</span><br><span class="line">    1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</span><br><span class="line">    2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</span><br><span class="line">    3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到 另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQuene；</span><br><span class="line">    4、priorityBlockingQuene：具有优先级的无界阻塞队列；</span><br><span class="line">    </span><br><span class="line">threadFactory：</span><br><span class="line">    它是ThreadFactory类型的变量，用来创建新线程。默认使用 Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</span><br><span class="line">    </span><br><span class="line">handler：</span><br><span class="line">    线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</span><br><span class="line">        1、AbortPolicy：直接抛出异常，默认策略；</span><br><span class="line">        2、CallerRunsPolicy：用调用者所在的线程来执行任务；</span><br><span class="line">        3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</span><br><span class="line">        4、DiscardPolicy：直接丢弃任务；</span><br><span class="line">        上面的4种策略都是ThreadPoolExecutor的内部类。</span><br><span class="line">        当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如 记录日志或持久化存储不能处理的任务。</span><br></pre></td></tr></table></figure><h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务无返回值提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span></span><br><span class="line"><span class="function"> <span class="comment">//任务有返回值提交</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程池监控方法"><a href="#线程池监控方法" class="headerlink" title="线程池监控方法"></a>线程池监控方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> <span class="comment">//线程池已执行与未执行的任务总数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> <span class="comment">//已完成的任务数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> <span class="comment">//线程池当前的线程数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> <span class="comment">//线程池中正在执行任务的线程数量</span></span></span><br></pre></td></tr></table></figure><h3 id="线程池ThreadPoolExecutor原理"><a href="#线程池ThreadPoolExecutor原理" class="headerlink" title="线程池ThreadPoolExecutor原理"></a>线程池ThreadPoolExecutor原理</h3><p> <img src="https://oss.pencilso.cn/enclosure/thread_excter_3_1598755457770.png" alt="thread_excter_3"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h6 id="ThreadPoolExecutor-execute方法"><a href="#ThreadPoolExecutor-execute方法" class="headerlink" title="ThreadPoolExecutor execute方法"></a>ThreadPoolExecutor execute方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">// clt记录着runState和workerCount</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line"><span class="comment">   * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span></span><br><span class="line"><span class="comment">   * 并把任务添加到该线程中。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">     * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">     * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果添加失败，则重新获取ctl值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 如果当前线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">       <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">      <span class="comment">// 这时需要移除该command</span></span><br><span class="line">      <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">       * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">       * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">       * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">       * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 如果执行到这里，有两种情况：</span></span><br><span class="line"><span class="comment">   * 1. 线程池已经不是RUNNING状态；</span></span><br><span class="line"><span class="comment">   * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。</span></span><br><span class="line"><span class="comment">   * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line"><span class="comment">   * 如果失败则拒绝该任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ThreadPoolExecutor-addWorker方法"><a href="#ThreadPoolExecutor-addWorker方法" class="headerlink" title="ThreadPoolExecutor addWorker方法"></a>ThreadPoolExecutor addWorker方法</h6><p> addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这个if判断</span></span><br><span class="line"><span class="comment">     * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">     * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">     * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">     * 2. firsTask为空</span></span><br><span class="line"><span class="comment">     * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">     * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">     * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">     * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">              <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">              <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                  <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">      <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                   <span class="comment">// workers是一个HashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                  <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">              <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h5><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，请参见JDK源码。</p><p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p><p>在调用构造方法时，需要把任务传入，这里通过getThreadFactory().newThread(this);来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p><p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li><li>如果正在执行任务，则不应该中断线程；</li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li><li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li><li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li></ol><p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p><p>​    此外，在构造方法中执行了setState(-1);，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cas修改state，不可重入</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Worker构造方法"><a href="#Worker构造方法" class="headerlink" title="Worker构造方法"></a>Worker构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire方法是根据state是否是0来判断的，所以，setState(-1);将state设置为-1是为了禁止在执行任务前对线程进行中断。</p><p>正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0。</p><p>Worker runWorker方法：在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//允许中断，把state改为0</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 如果task为空，则通过getTask来获取任务 getTask会从阻塞队列获取任务，对于线程的复用就是在该while循环中体现</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">                <span class="comment">//该if判断见下面的备注</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//修改为正常退出循环</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>如果线程池正在停止，那么要保证当前线程是中断状态；</li><li>如果不是的话，则要保证当前线程不是中断状态；</li></ul><p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p><ul><li>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</li><li>在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</li><li>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</li></ul><p>总结一下runWorker方法的执行过程：</p><ol><li>while循环不断地通过getTask()方法获取任务；</li><li>getTask()方法从阻塞队列中取任务；</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li><li>调用task.run()执行任务；</li><li>如果task为null则跳出循环，执行processWorkerExit()方法；</li><li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li></ol><p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</p><p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p><h6 id="Worker-getTask方法"><a href="#Worker-getTask方法" class="headerlink" title="Worker getTask方法"></a>Worker getTask方法</h6><p>getTask方法用来从阻塞队列中取任务，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">                </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">       * 1. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">       * 2. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">       * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">       * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">           * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">           * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">           * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">           * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">//该判断的分析见备注</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class="line"><span class="comment">         * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">              <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">          <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><pre><code>目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</code></pre><h6 id="Worker-processWorkerExit方法"><a href="#Worker-processWorkerExit方法" class="headerlink" title="Worker processWorkerExit方法"></a>Worker processWorkerExit方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">       <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">   * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">   * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束。</p><h2 id="拒绝策略增强"><a href="#拒绝策略增强" class="headerlink" title="拒绝策略增强"></a>拒绝策略增强</h2><p>拒绝策略的触发条件是：核心线程已满、阻塞队列已满、非核心线程已满</p><p>而Java提供的四种策略：</p><pre><code>    1、AbortPolicy：直接抛出异常，默认策略；    2、CallerRunsPolicy：用调用者所在的线程来执行任务；    3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；    4、DiscardPolicy：直接丢弃任务；</code></pre><p>如果说应用场景里面，提交任务不允许异常、线程任务不允许丢弃、也不允许用调用者所在的线程来执行任务。那么这时候可以使用无界的阻塞队列，也可以我们自己来定义拒绝策略。</p><p>接下来我实现一个用redis实现的拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义线程任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTask</span><span class="params">(<span class="keyword">int</span> task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTask</span><span class="params">(<span class="keyword">int</span> task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; task:&quot;</span> + task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义拒绝策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String redisKey = <span class="string">&quot;executor_list&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisRejectedExecutionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledThreadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">        scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ListOperations listOperations = redisTemplate.opsForList();</span><br><span class="line">                <span class="keyword">while</span> (listOperations.size(redisKey) != <span class="number">0L</span>) &#123;</span><br><span class="line">                    BlockingQueue&lt;Runnable&gt; queue = executor.getQueue();</span><br><span class="line">                    <span class="keyword">if</span> (queue.remainingCapacity() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//尝试重新放回阻塞队列里面</span></span><br><span class="line">                        CustomTask customTask = ((CustomTask) listOperations.leftPop(redisKey));</span><br><span class="line">                        <span class="keyword">if</span> (customTask != <span class="keyword">null</span> &amp;&amp; !queue.offer(customTask, <span class="number">500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            <span class="comment">//放入队列失败，跳出while循环</span></span><br><span class="line">                            <span class="comment">//把task重新放回redis</span></span><br><span class="line">                            listOperations.leftPush(redisKey, customTask);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//队列是满的 放不下</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> CustomTask) &#123;</span><br><span class="line">            CustomTask customTask = (CustomTask) r;</span><br><span class="line">            ListOperations&lt;String, Serializable&gt; listOperations = redisTemplate.opsForList();</span><br><span class="line">            listOperations.rightPush(redisKey, customTask);</span><br><span class="line">            System.out.println(<span class="string">&quot;task:&quot;</span> + customTask.getTask() + <span class="string">&quot; 已经放入redis&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟多线程测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), redisRejectedExecutionHandler);</span><br><span class="line">    redisRejectedExecutionHandler.setExecutor(threadPoolExecutor);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> CustomTask(i));</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000000000L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">task:<span class="number">6</span> 已经放入redis</span><br><span class="line">task:<span class="number">7</span> 已经放入redis</span><br><span class="line">task:<span class="number">8</span> 已经放入redis</span><br><span class="line">task:<span class="number">9</span> 已经放入redis</span><br><span class="line"> task:<span class="number">5</span></span><br><span class="line"> task:<span class="number">4</span></span><br><span class="line"> task:<span class="number">0</span></span><br><span class="line"> task:<span class="number">1</span></span><br><span class="line"> task:<span class="number">3</span></span><br><span class="line"> task:<span class="number">2</span></span><br><span class="line"> task:<span class="number">6</span></span><br><span class="line"> task:<span class="number">7</span></span><br><span class="line"> task:<span class="number">8</span></span><br><span class="line"> task:<span class="number">9</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//ps： ThreadPoolExecutor最大线程数是3，而ArrayBlockingQueue队列数量也是3，所以最终有4个会放到redis，从打印日志来看是符合预期的。6、7、8、9被放到了redis，当阻塞队列有空闲位置的时候，我们又把redis中的线程任务添加到队列中，最后6、7、8、9也执行了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ThreadPoolExecutor线程池的使用及原理</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://songlongkuan.com/tags/Java/"/>
    
    <category term="Executor" scheme="https://songlongkuan.com/tags/Executor/"/>
    
  </entry>
  
</feed>
