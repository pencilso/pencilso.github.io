<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋龙宽|个人博客</title>
  
  
  <link href="https://songlongkuan.com/atom.xml" rel="self"/>
  
  <link href="https://songlongkuan.com/"/>
  <updated>2021-01-07T01:51:50.469Z</updated>
  <id>https://songlongkuan.com/</id>
  
  <author>
    <name>宋龙宽|个人博客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LRU缓存淘汰策略</title>
    <link href="https://songlongkuan.com/2020/11/29/algorithm_lru_cache/"/>
    <id>https://songlongkuan.com/2020/11/29/algorithm_lru_cache/</id>
    <published>2020-11-29T02:56:00.000Z</published>
    <updated>2021-01-07T01:51:50.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LRU淘汰算法主要目的：在已知限制大小的容器中，当容器满了的情况还有元素放入容器时，移出最久未使用元素。</p><ul><li>LRU淘汰算法可以用链表来实现</li><li>当一个新元素放入容器，将会插入到链表的表头</li><li>当从容器中查询某一个元素，会将链表中的该元素删除，再重新插入到链表的表头</li><li>而那些旧元素且没有查询操作的元素就会沉淀在链表的底部，当容器满了的情况会逐一删除。</li></ul><a id="more"></a><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>假设现在设定一个容器只能最大存储5个元素，已知存储了”张三-&gt;李四-&gt;王五-&gt;赵六-&gt;麻子”。</p><p>链表头为张三，链表尾为麻子，如下图所示。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_1_1606617279798.png" alt="lru_1"></p><h4 id="插入新元素"><a href="#插入新元素" class="headerlink" title="插入新元素"></a>插入新元素</h4><p>假设现在又要放入一个新元素：”小二”，应将”小二” 插入到张三的前面，而麻子则删除，并且尾部指针指向到赵六。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_2_1606617531882.png" alt="lru_2"></p><h4 id="查询旧元素"><a href="#查询旧元素" class="headerlink" title="查询旧元素"></a>查询旧元素</h4><p>假设现在要从容器中查询 “李四”，因为”李四”已经存在于链表中所以应先从链表删除”李四”，再将”李四”插入到链表的头部，并将链表的头部指针指向到”李四”。</p><p><img src="https://oss.pencilso.cn/enclosure/lru_3_1606617851297.png" alt="lru_3"></p><h2 id="Java的代码实现"><a href="#Java的代码实现" class="headerlink" title="Java的代码实现"></a>Java的代码实现</h2><h4 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU缓存淘汰策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限制大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limitSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru已存储大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lruSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, LRUCacheValue&lt;K, V&gt;&gt; cache;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru-指针-头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LRUCacheNode&lt;K&gt; head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru-指针-尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LRUCacheNode&lt;K&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> limitSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limitSize = limitSize;</span><br><span class="line">        <span class="comment">//初始化HashMap的大小</span></span><br><span class="line">        <span class="keyword">int</span> initialCapacity = (<span class="keyword">int</span>) Math.round((<span class="keyword">float</span>) limitSize / <span class="number">0.75</span>);</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="comment">//如果当前lru已经满了的話  删除最后一个</span></span><br><span class="line">            K removeLruTailKey = removeLruTail();</span><br><span class="line">            cache.remove(removeLruTailKey);</span><br><span class="line">            lruSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lruCacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个key在lru缓存中是存在的話  先进行删除 remove操作</span></span><br><span class="line">            removeLruNode(lruCacheValue.node);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key, <span class="keyword">new</span> LRUCacheValue&lt;K, V&gt;(value, insertLruHead(key)));</span><br><span class="line">        lruSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lruCacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        removeLruNode(lruCacheValue.node);</span><br><span class="line">        <span class="comment">//压入链表节点</span></span><br><span class="line">        lruCacheValue.node = insertLruHead(key);</span><br><span class="line">        <span class="keyword">return</span> lruCacheValue.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.head == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.tail == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否满了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lruSize &gt;= limitSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历打印所有lru链表中的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LRUCacheNode&lt;K&gt; curr = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span> + curr.key);</span><br><span class="line">        &#125; <span class="keyword">while</span> ((curr = curr.next) != <span class="keyword">null</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;lrusize:&quot;</span> + lruSize + <span class="string">&quot; cacheCount:&quot;</span> + cache.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入到lru-头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LRUCacheNode&lt;K&gt; <span class="title">insertLruHead</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        LRUCacheNode&lt;K&gt; lruCacheNode = <span class="keyword">new</span> LRUCacheNode&lt;&gt;(key);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = lruCacheNode;</span><br><span class="line">            <span class="keyword">this</span>.tail = lruCacheNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lruCacheNode.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head.prew = lruCacheNode;</span><br><span class="line">            <span class="keyword">this</span>.head = lruCacheNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lruCacheNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除lru最后一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> K <span class="title">removeLruTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暂存key</span></span><br><span class="line">        K key = <span class="keyword">this</span>.tail.key;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            <span class="comment">//只有一个节点</span></span><br><span class="line">            removeAll();</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tail.prew != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tail.prew.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点指向到尾节点的prew节点</span></span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">this</span>.tail.prew;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除全部链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定节点的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLruNode</span><span class="params">(LRUCacheNode&lt;K&gt; cacheNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.head &amp;&amp; cacheNode == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            removeAll();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheNode.next.prew = cacheNode.prew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode.prew != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheNode.prew.next = cacheNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            <span class="comment">//要删除的是head指针</span></span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheNode == <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            <span class="comment">//要删除的是tail指针</span></span><br><span class="line">            <span class="keyword">this</span>.tail = cacheNode.prew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheValue</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; node;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheValue</span><span class="params">(V value, LRUCacheNode&lt;K&gt; node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheNode</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; prew;</span><br><span class="line">        <span class="keyword">private</span> LRUCacheNode&lt;K&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheNode</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>先检查是否容器已满，如果满了的情况删除最后一个链表的元素，并且从map集合中remove。</p><p>如果这个key已经存在于lru链表中，将lru中的该元素删除。</p><p>插入key到链表的头部</p><p>最后把数据放入到map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        <span class="comment">//如果当前lru已经满了的話  删除最后一个</span></span><br><span class="line">        K removeLruTailKey = removeLruTail();</span><br><span class="line">        cache.remove(removeLruTailKey);</span><br><span class="line">        lruSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lruCacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果这个key在lru缓存中是存在的話  先进行删除 remove操作</span></span><br><span class="line">        removeLruNode(lruCacheValue.node);</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(key, <span class="keyword">new</span> LRUCacheValue&lt;K, V&gt;(value, insertLruHead(key)));</span><br><span class="line">    lruSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>如果key存在于map中，则删除这个key在链表中的元素。</p><p>将这个key重新插入到链表的头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    LRUCacheValue&lt;K, V&gt; lruCacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lruCacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    removeLruNode(lruCacheValue.node);</span><br><span class="line">    <span class="comment">//压入链表节点</span></span><br><span class="line">    lruCacheValue.node = insertLruHead(key);</span><br><span class="line">    <span class="keyword">return</span> lruCacheValue.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>循环放入1万个数字，且是自增的数字，每次放入后都查询一下key为0、1的元素。</p><p>理论上，因为每次插入数据都会查询0、1，所以最后链表肯定1、0在最前面。再往后就是99999-99992</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; lruCache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            lruCache.put(i, String.valueOf(i));</span><br><span class="line">            lruCache.get(<span class="number">0</span>);</span><br><span class="line">            lruCache.get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lruCache.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果输出如下- 符合理论预期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key:1</span><br><span class="line">key:0</span><br><span class="line">key:99999</span><br><span class="line">key:99998</span><br><span class="line">key:99997</span><br><span class="line">key:99996</span><br><span class="line">key:99995</span><br><span class="line">key:99994</span><br><span class="line">key:99993</span><br><span class="line">key:99992</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LRU淘汰算法主要目的：在已知限制大小的容器中，当容器满了的情况还有元素放入容器时，移出最久未使用元素。</summary>
    
    
    
    <category term="算法" scheme="https://songlongkuan.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LRU" scheme="https://songlongkuan.com/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="https://songlongkuan.com/2020/11/26/data_structure_stack/"/>
    <id>https://songlongkuan.com/2020/11/26/data_structure_stack/</id>
    <published>2020-11-26T13:27:00.000Z</published>
    <updated>2021-01-07T01:49:41.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈结构是遵循先进后出，后进先出的 First In Last Out（FILO）。</p><p>而实现栈结构的方式有数组、链表。</p><ul><li><p>数组实现</p><ul><li>效率高，因为数组是一块连续的空间，CPU加载内存时会加载一片连续的内存。</li><li>需要对数组进行动态的扩容、缩容。</li></ul></li><li><p>链表实现</p><ul><li>效率相对数组要低，因为它的对象内存地址不连续。</li><li>内存空间占用更大，因为每个节点都需要包含next指针。</li><li>理论上可以无限压入数据到栈，但是可能会溢出。</li><li>不需要考虑扩容、缩容、下标越界。</li></ul><a id="more"></a></li></ul><p><img src="https://oss.pencilso.cn/enclosure/stack_1_1606395677610.png" alt="stack_1"></p><p>大多数场景下还是用数组实现的栈结构更多，因为它的性能更高。</p><p>先创建一个接口，再由子类去实现它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Item <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="栈-数组实现"><a href="#栈-数组实现" class="headerlink" title="栈-数组实现"></a>栈-数组实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cap = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Item table[] = (Item[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        judgeSize();</span><br><span class="line">        <span class="keyword">this</span>.table[size++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        judgeSize();</span><br><span class="line">        Item item = <span class="keyword">this</span>.table[--size];</span><br><span class="line">        <span class="keyword">this</span>.table[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验数组是否要扩容 或者缩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">judgeSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt;= <span class="keyword">this</span>.table.length) &#123;</span><br><span class="line">            <span class="comment">//扩容两倍</span></span><br><span class="line">            resize(<span class="keyword">this</span>.table.length * <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt;= cap &amp;&amp; (<span class="keyword">this</span>.table.length / <span class="number">2</span>) &gt; size) &#123;</span><br><span class="line">            <span class="comment">//如果当前元素数量大于cap 并且小于数组长度的一半  则对数组缩容一半</span></span><br><span class="line">            resize(<span class="keyword">this</span>.table.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> resize)</span> </span>&#123;</span><br><span class="line">        Item[] tempTable = (Item[]) <span class="keyword">new</span> Object[resize];</span><br><span class="line">        <span class="comment">//克隆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            tempTable[i] = <span class="keyword">this</span>.table[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.table = tempTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack&lt;String&gt; arrayStack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">        arrayStack.push(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">----- 输出结果如下所示</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="栈-链表实现"><a href="#栈-链表实现" class="headerlink" title="栈-链表实现"></a>栈-链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        LinkedStackNode&lt;Item&gt; newNode = <span class="keyword">new</span> LinkedStackNode&lt;&gt;(item);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.prew = tail;</span><br><span class="line">            tail.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedStackNode&lt;Item&gt; tempTail = <span class="keyword">this</span>.tail;</span><br><span class="line">        <span class="keyword">if</span> (tempTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">this</span>.tail = tempTail.prew;</span><br><span class="line">            <span class="keyword">return</span> tempTail.getData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStackNode</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedStackNode</span><span class="params">(Item data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Item data;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; prew;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> LinkedStackNode&lt;Item&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedStack&lt;String&gt; arrayStack = <span class="keyword">new</span> LinkedStack&lt;&gt;();</span><br><span class="line">        arrayStack.push(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        arrayStack.push(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">----- 输出结果如下所示</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java数组、链表实现实现 数据结构-栈</summary>
    
    
    
    <category term="数据结构" scheme="https://songlongkuan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈" scheme="https://songlongkuan.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Java之ThreadLocal</title>
    <link href="https://songlongkuan.com/2020/09/12/java_threadlocal/"/>
    <id>https://songlongkuan.com/2020/09/12/java_threadlocal/</id>
    <published>2020-09-12T07:30:16.000Z</published>
    <updated>2021-01-31T11:42:30.271Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</p><a id="more"></a><h2 id="ThreadLocal的简单应用"><a href="#ThreadLocal的简单应用" class="headerlink" title="ThreadLocal的简单应用"></a>ThreadLocal的简单应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread-<span class="number">1</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">1</span> 执行前数后:张三</span><br><span class="line">thread-<span class="number">2</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">2</span> 执行前数后:李四</span><br></pre></td></tr></table></figure><p>由此可以得出结论，threadLocal是线程之间隔离的数据存储方式。</p><h2 id="ThreadLocal-的问题"><a href="#ThreadLocal-的问题" class="headerlink" title="ThreadLocal 的问题"></a>ThreadLocal 的问题</h2><p>ThreadLocal在线程池中应用的话是会产生问题的，我们知道线程池它是会对线程进行重复利用，也就是说可能放几个任务到线程池中执行最后都是由一个KLT线程去运行的。</p><p>线程池+ThreadLocal问题重现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：张三</span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><p>可以观察到，runnable2执行的时候拿到了runnable1置入的”张三”，这时候已经不是逻辑上的隔离了，因为线程复用导致ThreadLocal里面的数据没有释放，从而导致下一次在线程池运行任务的时候，获取到的数据还是上一个线程置入的数据。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案-1"></a>解决方案-1</h2><p>第一种解决方案，就是在线程执行之前清空一下ThreadLocal，至于线程执行结束的话，系统会自动清理。</p><p>改造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">   <span class="comment">//设置为nulll</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">    <span class="comment">//设置为null</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行输出结果如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案-2"></a>解决方案-2</h2><p>第二种解决方案的话，主要是从线程池入手，线程池有一个执行线程任务前的拦截方法，可以在Runnable执行之前执行。</p><p>再次改造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>)) &#123;</span><br><span class="line">          <span class="comment">//重写beforeExecute方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">                <span class="comment">//统一把ThreadLocal设置为null</span></span><br><span class="line">                threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal实现的原理"><a href="#ThreadLocal实现的原理" class="headerlink" title="ThreadLocal实现的原理"></a>ThreadLocal实现的原理</h2><h3 id="ThreadLocal-的set方法"><a href="#ThreadLocal-的set方法" class="headerlink" title="ThreadLocal 的set方法"></a>ThreadLocal 的set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//如果map已创建  则置入数据 </span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//如果map还未创建 则创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的createMap方法"><a href="#ThreadLocal的createMap方法" class="headerlink" title="ThreadLocal的createMap方法"></a>ThreadLocal的createMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实例化一个ThreadLocalMap对象 并且赋值到thread.threadLocals字段里面</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的getMap方法"><a href="#ThreadLocal的getMap方法" class="headerlink" title="ThreadLocal的getMap方法"></a>ThreadLocal的getMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//直接获取的thread里面的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thread中的threadLocals字段"><a href="#Thread中的threadLocals字段" class="headerlink" title="Thread中的threadLocals字段"></a>Thread中的threadLocals字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal总结"><a href="#ThreadLocal总结" class="headerlink" title="ThreadLocal总结"></a>ThreadLocal总结</h3><p>ThreadLocal其实就是封装了调用Thread对象中ThreadLocalMap类型的threadlocals变量的过程。</p><p>至于ThreadLocalMap其实就是一个简化的hashmap。</p><p>如果说程序的调用链路比较长，假设一个请求需要调用10个方法，而只有第一个方法和最后一个方法需要一个”userId” 数据，如果我们给10个方法都加上”userId” 参数进行传递固然是可以解决，但是冗余了代码，而使用ThreadLocal后只需要在第一个和最后一个方法种调用ThreadLocal即可。</p><p>再比如说Mybatis的分页插件 PageHelper.startPage就是通过ThreadLocal把page参数放到了ThreadLocal中。</p><h2 id="ThreadLocal在线程间传递的问题"><a href="#ThreadLocal在线程间传递的问题" class="headerlink" title="ThreadLocal在线程间传递的问题"></a>ThreadLocal在线程间传递的问题</h2><p>ThreadLocal是线程独享的数据，是线程安全的，但是多线程开发过程中，可能会存在将一个线程的ThreadLocal数据传递给子线程的ThreadLocal。</p><h3 id="举例问题复现"><a href="#举例问题复现" class="headerlink" title="举例问题复现"></a>举例问题复现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------  输出结果如下  ----------</span><br><span class="line">当前线程中获取用户ID:<span class="number">1000</span></span><br><span class="line">子线程中获取用户ID：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>我们假设需要启动子线程去执行一些耗时任务，而子线程中需要ThreadLocal中的数据，那么这个时候子线程是获取不到的，当然我们也可以通过参数传递的方式把用户id传到thread对象中。<br>再举例一个场景，对请求的链路追踪，如果在程序在接到请求后，用子线程执行了某些耗时任务，那么也会追踪不到子线程中执行的哪些方法，因为ThreadLocal无法传递到子线程。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们将ThreadLocal 换成 InheritableThreadLocal 即可解决，如下代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------  输出结果如下  ----------</span><br><span class="line">当前线程中获取用户ID:<span class="number">1000</span></span><br><span class="line">子线程中获取用户ID：<span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="InheritableThreadLocal-源码解析-、Thread部分源码"><a href="#InheritableThreadLocal-源码解析-、Thread部分源码" class="headerlink" title="InheritableThreadLocal 源码解析 、Thread部分源码"></a>InheritableThreadLocal 源码解析 、Thread部分源码</h3><p>查看InheritableThreadLocal源码的时候，能看到InheritableThreadLocal只是继承自ThreadLocal 并且重写了三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继承可继承的inheritableThreadLocals 时会调用到该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写获取map方法，返回可继承的map对象</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写创建map方法，把创建出来的map赋值给可继承的 t.inheritableThreadLocals</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想弄明白InheritableThreadLocal的实现原理，需要先了解了解Thread的源码，接下来先写部分Thread的源码解析。<br>Thread的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 不可继承，ThreadLocal就是用的这个成员变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 可继承，InheritableThreadLocal 用的是这个变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>在Thread的构造方法中，会调用一个初始化方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//inheritThreadLocals 是否继承，默认为true   </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//现在的代码执行阶段还在Thread构造方法中调用的，所以这里currentThread 获取的还是当前线程，并不是未来将要开启的子线程。当前线程就是未来要开启的子线程的父级。</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果inheritThreadLocals = true 并且 父级的inheritableThreadLocals对象不为空</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">//根据父级的inheritableThreadLocals 创建一个新的map，并且赋值给新的Thread.inheritableThreadLocals 。</span></span><br><span class="line">               <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                   ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据父级的map，创建新的map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//ThreadLocalMap 的构造方法（复制父map的内容）</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//map中的table（数组）</span></span><br><span class="line">     Entry[] parentTable = parentMap.table;</span><br><span class="line">     <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">     setThreshold(len);</span><br><span class="line">     <span class="comment">//创建新的数组，这个tbale变量在ThreadLocalMap的成员属性中</span></span><br><span class="line">     table = <span class="keyword">new</span> Entry[len];    <span class="comment">//this.table = new Entry[len];</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//遍历数组</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        </span><br><span class="line">         Entry e = parentTable[j];</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从Entry中，拿到ThreadLocal</span></span><br><span class="line">             ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用ThreadLocal.childValue 方法， InheritableThreadLocal就重写了这个方法</span></span><br><span class="line">                 Object value = key.childValue(e.value);</span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">//接下来就是计算hash，然后决定将key放到哪里。</span></span><br><span class="line">                 Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                 <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                 <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                     h = nextIndex(h, len);</span><br><span class="line">                 table[h] = c;</span><br><span class="line">                 size++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure><p>以上是Thread对 可继承的inheritableThreadLocals 变量所做的一系列操作过程。</p><p>InheritableThreadLocal 总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用InheritableThreadLocal.set方法，而set方法第一次执行会调用createMap方法，而createMap已经被InheritableThreadLocal这个类重写。</span></span><br><span class="line">      <span class="comment">//所以创建出来的map会存储在inheritableThreadLocals变量中</span></span><br><span class="line">      threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这个get方法，里面实际是调用了一次getMap方法，而getMap也被inheritableThreadLocals重写，返回的是inheritableThreadLocals变量map。所以能拿到值。</span></span><br><span class="line">      System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//new Thread会执行一系列的初始化操作</span></span><br><span class="line">      <span class="comment">//1、判断inheritableThreadLocals=true （默认为true）</span></span><br><span class="line">      <span class="comment">//2、判断parent.inheritableThreadLocals !=null (我们放了一个id:1000在里面，所以不为空)</span></span><br><span class="line">      <span class="comment">//3、根据parent.inheritableThreadLocals 创建新的map对象，并且赋值到新的Thread.inheritableThreadLocals变量中（new Thread（）中)</span></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这个时候，Thread.inheritableThreadLocals已经继承了父级的数据，所以能拿到。</span></span><br><span class="line">          System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://songlongkuan.com/tags/Java/"/>
    
    <category term="ThreadLocal" scheme="https://songlongkuan.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之Executor线程池原理、增强拒绝策略</title>
    <link href="https://songlongkuan.com/2020/08/30/concurrent_executor_thread/"/>
    <id>https://songlongkuan.com/2020/08/30/concurrent_executor_thread/</id>
    <published>2020-08-30T04:48:00.000Z</published>
    <updated>2021-01-31T11:37:34.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是调度CPU资源的最小单位，线程模型分为KLT模型、ULT模型，JVM使用的KLT模型。因此Java线程与OS线程保持1:!的映射关系，也就是说一个Java线程也会在操作系统里有一个对应的线程。</p><a id="more"></a><p>Java线程有多种生命状态：</p><ul><li><p>NEW：新建</p></li><li><p>RUNNABLE：运行</p></li><li><p>BLOCKED：阻塞</p></li><li><p>WAITING：等待</p></li><li><p>TIMED_WAITING：超时等待</p></li><li><p>TERMINATED：终结</p><p><img src="https://oss.pencilso.cn/enclosure/thread_excter_1_1598748857919.png" alt="thread_excter_1"></p></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>这里记录一下协程相关的资料，协程（纤程、用户级线程），主要目的是为了追求最大力度的发挥硬件性能和提升软件的速度。</p><p>协程的基本原理：在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务，等完成或达到某个条件时，再还原原来的栈信息并继续执行，（整个过程不需要上下文切换）</p><p>协程是用户级线程ULT模型，多个协程由一个线程所处理，协程的创建与销毁由程序自己来控制，当提交了多个线程任务，那么最终都是由一个KLT线程去顺序执行这些协程的任务。以此避免KLT线程之间的切换。</p><p>Java原生是不支持协程的，在纯Java代码里需要使用协程的话需要引入第三方包，如：quasar</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>“线程池” 顾名思义就是一个线程缓存，线程时稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程统一分配、调优、监控。</p><h3 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h3><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行 处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p><ul><li>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁 线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</li></ul><p>线程池的解决方案：线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上，适合以下场景使用线程池：</p><ul><li>单个任务处理时间短</li><li>需要处理的任务数量很大</li></ul><h3 id="线程池优势"><a href="#线程池优势" class="headerlink" title="线程池优势"></a>线程池优势</h3><ul><li>重用存在的线程，减少线程创建，消亡的开销，提高性能</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资 源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p>1、Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImp</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadImp</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Callable（与前两种不同的是，Callable可以在执行任务后带有返回内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableImp</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图为它的继承与实现 <img src="https://oss.pencilso.cn/enclosure/thread_excter_2_1598752817575.png" alt="thread_excter_2"></p><p>从图中可以看出Executor下有一个重要子接口ExecutorService，其中定义了线程池的具体行为</p><ol><li>execute（Runnable command）：履行Ruannable类型的任务,</li><li>submit（task）：可用来提交Callable或Runnable任务，并返回代表此任务的Future 对象</li><li>shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务,</li><li>shutdownNow（）：停止所有正在履行的任务并封闭办事。</li><li>isTerminated（）：测试是否所有任务都履行完毕了。</li><li>isShutdown（）：测试是否该ExecutorService已被关闭。</li></ol><h3 id="ThreadPoolExecutor线程池重点属性"><a href="#ThreadPoolExecutor线程池重点属性" class="headerlink" title="ThreadPoolExecutor线程池重点属性"></a>ThreadPoolExecutor线程池重点属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>)); </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>ctl 是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存 workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p><p>ctl相关方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><ul><li>runStateOf：获取运行状态；</li><li>workerCountOf：获取活动线程数；</li><li>ctlOf：获取运行状态和活动线程数的值。</li></ul><p>线程池存在5种状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UNNING = ‐1 &lt;&lt; COUNT_BITS; //高3位为111 </span><br><span class="line">SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //高3位为000 </span><br><span class="line">STOP = 1 &lt;&lt; COUNT_BITS; //高3位为001 </span><br><span class="line">TIDYING = 2 &lt;&lt; COUNT_BITS; //高3位为010 </span><br><span class="line">TERMINATED = 3 &lt;&lt; COUNT_BITS; //高3位为011</span><br></pre></td></tr></table></figure><p>1、RUNNING</p><p>​    (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行 处理。</p><p>​     (02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处 于RUNNING状态，并且线程池中的任务数为0！</p><p>2、 SHUTDOWN </p><p>​    (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</p><p>​     (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p><p>3、STOP </p><p>​    (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中 断正在处理的任务。 </p><p>​    (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p><p>4、TIDYING </p><p>​    (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING 状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在 ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理； 可以通过重载terminated()函数来实现。 </p><p>​    (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也 为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的 任务为空时，就会由STOP -&gt; TIDYING。</p><p>5、 TERMINATED<br>    (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。</p><p>​     (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING - &gt; TERMINATED。 进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TIDYING状态或TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； workerCount为0； 设置TIDYING状态成功。</p><h3 id="线程池的具体实现"><a href="#线程池的具体实现" class="headerlink" title="线程池的具体实现"></a>线程池的具体实现</h3><p>ThreadPoolExecutor 默认线程池</p><p>ScheduledThreadPoolExecutor 定时线程池</p><h2 id="线程池-ThreadPoolExecutor"><a href="#线程池-ThreadPoolExecutor" class="headerlink" title="线程池 ThreadPoolExecutor"></a>线程池 ThreadPoolExecutor</h2><h3 id="线程池ThreadPoolExecutor的创建"><a href="#线程池ThreadPoolExecutor的创建" class="headerlink" title="线程池ThreadPoolExecutor的创建"></a>线程池ThreadPoolExecutor的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span></span><br></pre></td></tr></table></figure><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize：</span><br><span class="line">    线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</span><br><span class="line"></span><br><span class="line">maximumPoolSize：</span><br><span class="line">    线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。</span><br><span class="line"></span><br><span class="line">keepAliveTime：</span><br><span class="line">    线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime.</span><br><span class="line"></span><br><span class="line">unit：</span><br><span class="line">    keepAliveTime的单位。</span><br><span class="line"></span><br><span class="line">workQueue：</span><br><span class="line">    用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</span><br><span class="line">    1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；</span><br><span class="line">    2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</span><br><span class="line">    3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到 另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQuene；</span><br><span class="line">    4、priorityBlockingQuene：具有优先级的无界阻塞队列；</span><br><span class="line">    </span><br><span class="line">threadFactory：</span><br><span class="line">    它是ThreadFactory类型的变量，用来创建新线程。默认使用 Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</span><br><span class="line">    </span><br><span class="line">handler：</span><br><span class="line">    线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</span><br><span class="line">        1、AbortPolicy：直接抛出异常，默认策略；</span><br><span class="line">        2、CallerRunsPolicy：用调用者所在的线程来执行任务；</span><br><span class="line">        3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</span><br><span class="line">        4、DiscardPolicy：直接丢弃任务；</span><br><span class="line">        上面的4种策略都是ThreadPoolExecutor的内部类。</span><br><span class="line">        当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如 记录日志或持久化存储不能处理的任务。</span><br></pre></td></tr></table></figure><h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务无返回值提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span></span><br><span class="line"><span class="function"> <span class="comment">//任务有返回值提交</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程池监控方法"><a href="#线程池监控方法" class="headerlink" title="线程池监控方法"></a>线程池监控方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> <span class="comment">//线程池已执行与未执行的任务总数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> <span class="comment">//已完成的任务数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> <span class="comment">//线程池当前的线程数 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> <span class="comment">//线程池中正在执行任务的线程数量</span></span></span><br></pre></td></tr></table></figure><h3 id="线程池ThreadPoolExecutor原理"><a href="#线程池ThreadPoolExecutor原理" class="headerlink" title="线程池ThreadPoolExecutor原理"></a>线程池ThreadPoolExecutor原理</h3><p> <img src="https://oss.pencilso.cn/enclosure/thread_excter_3_1598755457770.png" alt="thread_excter_3"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h6 id="ThreadPoolExecutor-execute方法"><a href="#ThreadPoolExecutor-execute方法" class="headerlink" title="ThreadPoolExecutor execute方法"></a>ThreadPoolExecutor execute方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">// clt记录着runState和workerCount</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line"><span class="comment">   * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</span></span><br><span class="line"><span class="comment">   * 并把任务添加到该线程中。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">     * 如果为true，根据corePoolSize来判断；</span></span><br><span class="line"><span class="comment">     * 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果添加失败，则重新获取ctl值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 如果当前线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">       <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">      <span class="comment">// 这时需要移除该command</span></span><br><span class="line">      <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line"><span class="comment">       * 这里传入的参数表示：</span></span><br><span class="line"><span class="comment">       * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line"><span class="comment">       * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line"><span class="comment">       * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 如果执行到这里，有两种情况：</span></span><br><span class="line"><span class="comment">   * 1. 线程池已经不是RUNNING状态；</span></span><br><span class="line"><span class="comment">   * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。</span></span><br><span class="line"><span class="comment">   * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line"><span class="comment">   * 如果失败则拒绝该任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ThreadPoolExecutor-addWorker方法"><a href="#ThreadPoolExecutor-addWorker方法" class="headerlink" title="ThreadPoolExecutor addWorker方法"></a>ThreadPoolExecutor addWorker方法</h6><p> addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这个if判断</span></span><br><span class="line"><span class="comment">     * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line"><span class="comment">     * 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line"><span class="comment">     * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line"><span class="comment">     * 2. firsTask为空</span></span><br><span class="line"><span class="comment">     * 3. 阻塞队列不为空</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 首先考虑rs == SHUTDOWN的情况</span></span><br><span class="line"><span class="comment">     * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line"><span class="comment">     * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</span></span><br><span class="line"><span class="comment">     * 因为队列中已经没有任务了，不需要再添加线程了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">              <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></span><br><span class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">              <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                  <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">      <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                   <span class="comment">// workers是一个HashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                  <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">              <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h5><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，请参见JDK源码。</p><p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p><p>在调用构造方法时，需要把任务传入，这里通过getThreadFactory().newThread(this);来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p><p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p><ol><li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li><li>如果正在执行任务，则不应该中断线程；</li><li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li><li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li><li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li></ol><p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p><p>​    此外，在构造方法中执行了setState(-1);，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cas修改state，不可重入</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Worker构造方法"><a href="#Worker构造方法" class="headerlink" title="Worker构造方法"></a>Worker构造方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire方法是根据state是否是0来判断的，所以，setState(-1);将state设置为-1是为了禁止在执行任务前对线程进行中断。</p><p>正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0。</p><p>Worker runWorker方法：在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//允许中断，把state改为0</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 如果task为空，则通过getTask来获取任务 getTask会从阻塞队列获取任务，对于线程的复用就是在该while循环中体现</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">                <span class="comment">//该if判断见下面的备注</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//修改为正常退出循环</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>如果线程池正在停止，那么要保证当前线程是中断状态；</li><li>如果不是的话，则要保证当前线程不是中断状态；</li></ul><p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p><ul><li>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</li><li>在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</li><li>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</li></ul><p>总结一下runWorker方法的执行过程：</p><ol><li>while循环不断地通过getTask()方法获取任务；</li><li>getTask()方法从阻塞队列中取任务；</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li><li>调用task.run()执行任务；</li><li>如果task为null则跳出循环，执行processWorkerExit()方法；</li><li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li></ol><p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</p><p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p><h6 id="Worker-getTask方法"><a href="#Worker-getTask方法" class="headerlink" title="Worker getTask方法"></a>Worker getTask方法</h6><p>getTask方法用来从阻塞队列中取任务，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">                </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">       * 1. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">       * 2. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">       * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">       * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">           * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">           * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">           * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">           * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">//该判断的分析见备注</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class="line"><span class="comment">         * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">              <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">          <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><pre><code>目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</code></pre><h6 id="Worker-processWorkerExit方法"><a href="#Worker-processWorkerExit方法" class="headerlink" title="Worker processWorkerExit方法"></a>Worker processWorkerExit方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></span><br><span class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">       <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</span></span><br><span class="line"><span class="comment">   * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</span></span><br><span class="line"><span class="comment">   * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束。</p><h2 id="拒绝策略增强"><a href="#拒绝策略增强" class="headerlink" title="拒绝策略增强"></a>拒绝策略增强</h2><p>拒绝策略的触发条件是：核心线程已满、阻塞队列已满、非核心线程已满</p><p>而Java提供的四种策略：</p><pre><code>    1、AbortPolicy：直接抛出异常，默认策略；    2、CallerRunsPolicy：用调用者所在的线程来执行任务；    3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；    4、DiscardPolicy：直接丢弃任务；</code></pre><p>如果说应用场景里面，提交任务不允许异常、线程任务不允许丢弃、也不允许用调用者所在的线程来执行任务。那么这时候可以使用无界的阻塞队列，也可以我们自己来定义拒绝策略。</p><p>接下来我实现一个用redis实现的拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义线程任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTask</span><span class="params">(<span class="keyword">int</span> task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTask</span><span class="params">(<span class="keyword">int</span> task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; task:&quot;</span> + task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义拒绝策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String redisKey = <span class="string">&quot;executor_list&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisRejectedExecutionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledThreadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">        scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ListOperations listOperations = redisTemplate.opsForList();</span><br><span class="line">                <span class="keyword">while</span> (listOperations.size(redisKey) != <span class="number">0L</span>) &#123;</span><br><span class="line">                    BlockingQueue&lt;Runnable&gt; queue = executor.getQueue();</span><br><span class="line">                    <span class="keyword">if</span> (queue.remainingCapacity() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//尝试重新放回阻塞队列里面</span></span><br><span class="line">                        CustomTask customTask = ((CustomTask) listOperations.leftPop(redisKey));</span><br><span class="line">                        <span class="keyword">if</span> (customTask != <span class="keyword">null</span> &amp;&amp; !queue.offer(customTask, <span class="number">500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                            <span class="comment">//放入队列失败，跳出while循环</span></span><br><span class="line">                            <span class="comment">//把task重新放回redis</span></span><br><span class="line">                            listOperations.leftPush(redisKey, customTask);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//队列是满的 放不下</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> CustomTask) &#123;</span><br><span class="line">            CustomTask customTask = (CustomTask) r;</span><br><span class="line">            ListOperations&lt;String, Serializable&gt; listOperations = redisTemplate.opsForList();</span><br><span class="line">            listOperations.rightPush(redisKey, customTask);</span><br><span class="line">            System.out.println(<span class="string">&quot;task:&quot;</span> + customTask.getTask() + <span class="string">&quot; 已经放入redis&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟多线程测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), redisRejectedExecutionHandler);</span><br><span class="line">    redisRejectedExecutionHandler.setExecutor(threadPoolExecutor);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> CustomTask(i));</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000000000L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">task:<span class="number">6</span> 已经放入redis</span><br><span class="line">task:<span class="number">7</span> 已经放入redis</span><br><span class="line">task:<span class="number">8</span> 已经放入redis</span><br><span class="line">task:<span class="number">9</span> 已经放入redis</span><br><span class="line"> task:<span class="number">5</span></span><br><span class="line"> task:<span class="number">4</span></span><br><span class="line"> task:<span class="number">0</span></span><br><span class="line"> task:<span class="number">1</span></span><br><span class="line"> task:<span class="number">3</span></span><br><span class="line"> task:<span class="number">2</span></span><br><span class="line"> task:<span class="number">6</span></span><br><span class="line"> task:<span class="number">7</span></span><br><span class="line"> task:<span class="number">8</span></span><br><span class="line"> task:<span class="number">9</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//ps： ThreadPoolExecutor最大线程数是3，而ArrayBlockingQueue队列数量也是3，所以最终有4个会放到redis，从打印日志来看是符合预期的。6、7、8、9被放到了redis，当阻塞队列有空闲位置的时候，我们又把redis中的线程任务添加到队列中，最后6、7、8、9也执行了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ThreadPoolExecutor线程池的使用及原理</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://songlongkuan.com/tags/Java/"/>
    
    <category term="Executor" scheme="https://songlongkuan.com/tags/Executor/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 使用AOP拦截实现Redis分布式锁</title>
    <link href="https://songlongkuan.com/2020/07/02/redis_aop_lock/"/>
    <id>https://songlongkuan.com/2020/07/02/redis_aop_lock/</id>
    <published>2020-07-02T10:01:00.000Z</published>
    <updated>2021-01-31T12:18:28.468Z</updated>
    
    <content type="html"><![CDATA[<p>在使用redis的setnx指令过程中，需要在每一个用到的地方手动加锁，手动释放锁，接下来介绍使用aop和redis实现一个轻量级的分布式锁。</p><a id="more"></a><p>新建两个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisLock &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeoutSecond</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisLockParam &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aop拦截器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReidsLockInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.example.ent.corecommon.annotation.RedisLock)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redislock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;redislock()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nxlock</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String className = joinPoint.getSignature().getDeclaringType().getName();</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        Object[] params = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        RedisLock redisLock = method.getAnnotation(RedisLock.class);</span><br><span class="line">        <span class="comment">//参数注解，二维数组</span></span><br><span class="line">        Annotation[][] annotations = method.getParameterAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; annotations.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取参数上的所有注解</span></span><br><span class="line">            Annotation[] annotationArray = annotations[i];</span><br><span class="line">            <span class="keyword">for</span> (Annotation annotation : annotationArray) &#123;</span><br><span class="line">                <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> RedisLockParam) &#123;</span><br><span class="line">                    <span class="comment">// 有标记为redislockParam</span></span><br><span class="line">                    nxLock(className, methodName, params[i], redisLock.timeoutSecond());</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有标记参数</span></span><br><span class="line">        nxLock(className, methodName, <span class="keyword">null</span>, redisLock.timeoutSecond());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;redislock()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nxUnLock</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        HttpServletRequest request = request();</span><br><span class="line">        String lockKey = (String) request.getAttribute(<span class="string">&quot;lockKey&quot;</span>);</span><br><span class="line">        String lockId = (String) request.getAttribute(<span class="string">&quot;lockId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(lockKey) &amp;&amp; !StringUtils.isEmpty(lockId)) &#123;</span><br><span class="line">            ValueOperations&lt;String, String&gt; stringStringValueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">            <span class="keyword">if</span> (lockId.equals(stringStringValueOperations.get(lockKey))) &#123;</span><br><span class="line">                stringRedisTemplate.delete(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行nxlock 锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className  类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param      参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nxLock</span><span class="params">(String className, String methodName, Object param, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成redis key</span></span><br><span class="line">        String hashMd5 = HashTookit.hashMd5(className + methodName);</span><br><span class="line">        String lockKey = <span class="string">&quot;lock:&quot;</span> + hashMd5 + (param == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;:&quot;</span> + param.toString());</span><br><span class="line"></span><br><span class="line">        String lockId = IdTookit.uuid();</span><br><span class="line">        ValueOperations&lt;String, String&gt; stringStringValueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        Boolean nxlockState = stringStringValueOperations.setIfAbsent(lockKey, lockId, timeout, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (nxlockState) &#123;</span><br><span class="line">            <span class="comment">//加锁成功</span></span><br><span class="line">            request().setAttribute(<span class="string">&quot;lockKey&quot;</span>, lockKey);</span><br><span class="line">            request().setAttribute(<span class="string">&quot;lockId&quot;</span>, lockId);</span><br><span class="line">            log.info(<span class="string">&quot;nx lock success lockkey :[&#123;&#125;]  lockId:[&#123;&#125;]&quot;</span>, lockKey, lockId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取锁失败，抛出自定义异常，注：理应在统一异常处理器中处理该异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">&quot;系统繁忙，请尝试稍后重试！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpServletRequest <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">return</span> requestAttributes.getRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法，可以在controller、service等地方使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RedisLock</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;product_sell&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">productSell</span><span class="params">(<span class="meta">@RedisLockParam</span> String productId)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SpringBoot 使用AOP拦截实现Redis分布式锁</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
    <category term="aop" scheme="https://songlongkuan.com/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>Java基础  JDK类加载机制</title>
    <link href="https://songlongkuan.com/2020/06/26/java_basics_classloader/"/>
    <id>https://songlongkuan.com/2020/06/26/java_basics_classloader/</id>
    <published>2020-06-26T12:00:00.000Z</published>
    <updated>2021-01-31T11:44:08.176Z</updated>
    
    <content type="html"><![CDATA[<p>记录类加载全过程、类加载器、双亲委派机制，以及自定义类加载器。</p><a id="more"></a><h2 id="类加载运行全过程"><a href="#类加载运行全过程" class="headerlink" title="类加载运行全过程"></a>类加载运行全过程</h2><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到JVM。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.pencilso.study.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRun</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> int1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> int2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> int1 + int2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        TestRun testRun = <span class="keyword">new</span> TestRun();</span><br><span class="line">        <span class="keyword">int</span> add = testRun.add();</span><br><span class="line">        System.out.println(<span class="string">&quot;add-&gt; &quot;</span>+add);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 通过Java命令执行代码的大体流程如下：</p><p><img src="https://oss.pencilso.cn/enclosure/classloader%20(1)_1591971696396.png" alt="classloader (1)"></p><p>其中classloader.loadClass的类加载过程有如下几步：</p><p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p><ul><li><p>加载 ：读入class字节码文件，使用到类时才会加载，例如调用类的静态方法，new对象等。</p></li><li><p>验证：校验字节码文件的正确性。</p></li><li><p>准备：对静态变量分配内存，并赋予默认值，例如 int1的默认值是0，而user是null，至于int2则是2，因为int2 使用了final修饰词，所以int2是常量，不再是静态变量。</p></li><li><p>解析：将符号引用替换为直接引用，该阶段会把一些静态方法（符号引用，比如main() 方法）替换为指向数据所存内存的指针或句柄等 (直接引用) ，这是所谓的静态链接过程 (类加载期间完成)。</p><p>动态链接是在程序运行期间完成的将符号引用替换为直接引用。</p></li><li><p>初始化：对类的静态变量初始化为指定的值，int1赋值为1 ，user 则会加载User类，创建User实例后赋值给user， 然后执行静态代码块。</p></li></ul><p>主类在运行过程中如果使用到其他类，会逐步加载这些类。</p><p>jar包或war包里的类不是一次性全部加载的，是使用到时才加载。</p><h2 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h2><p>Java中有多种类加载器</p><pre><code>- 引导类加载器：负责加载jre/lib目录下的jvm的核心类库，rt.jar、charsets.jar 等。- 扩展类加载器：负责加载jre/ext目录下的jvm扩展类库。- 应用程序类加载器：负责加载ClassPath路径下的类，主要就是加载自己编写的那些类。- 自定义加载器：负责加载指定目录下的类。</code></pre><p>注意，引导类加载器是由C++所创建的，所以在Java代码中是获取不到引导类加载器的对象。</p><p>查看对应的几种类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader stringClassLoader = String.class.getClassLoader();</span><br><span class="line">        ClassLoader deskeyFactoryClassloader = DESKeyFactory.class.getClassLoader();</span><br><span class="line">        ClassLoader testJdkClassloader = TestJDKClassloader.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;stringClassLoader-&gt; &quot;</span>+stringClassLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;fileClassloader-&gt; &quot;</span>+deskeyFactoryClassloader);</span><br><span class="line">        System.out.println(<span class="string">&quot;testJdkClassloader-&gt; &quot;</span>+testJdkClassloader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line">stringClassLoader-&gt; <span class="keyword">null</span></span><br><span class="line">fileClassloader-&gt; sun.misc.Launcher$ExtClassLoader@1b28cdfa</span><br><span class="line">testJdkClassloader-&gt; sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">  </span><br><span class="line"><span class="comment">// String是Java核心类库，是由C++所编写的引导式加载器 bootstrapLoader，所以获取到的是null</span></span><br><span class="line"><span class="comment">// DESKeyFactory 是Java的扩展类库，所以获取到的是 ExtClassLoader</span></span><br><span class="line"><span class="comment">// testJdkClassloader 是自己编写的文件，所以类加载器是AppClassLoader</span></span><br></pre></td></tr></table></figure><p>在创建Launcher时就创建好了ExtClassLoader、AppClassLoader两种加载器。</p><p>查看源码Launcher，分析ExtClassLoader、AppClassLoader是如何创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例 Launcher</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line"> <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Create the extension class loader</span></span><br><span class="line">       ClassLoader extcl;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//创建扩展的类加载器</span></span><br><span class="line">           extcl = ExtClassLoader.getExtClassLoader(); </span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">               <span class="string">&quot;Could not create extension class loader&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//创建应用的类加载器 , 并且将扩展库加载器传递到参数</span></span><br><span class="line">           loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">               <span class="string">&quot;Could not create application class loader&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">     ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="ExtClassLoader-创建过程"><a href="#ExtClassLoader-创建过程" class="headerlink" title="ExtClassLoader 创建过程"></a>ExtClassLoader 创建过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、单例模式 ，在createExtClassLoader方法进行创建</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(ExtClassLoader.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        instance = createExtClassLoader();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、可以看到new了一个ExtClassLoader，并且把扩展类库的路径传给了构造参数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ExtClassLoader <span class="title">createExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Prior implementations of this doPrivileged() block supplied</span></span><br><span class="line">                <span class="comment">// aa synthesized ACC via a call to the private method</span></span><br><span class="line">                <span class="comment">// ExtClassLoader.getContext().</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                            <span class="keyword">final</span> File[] dirs = getExtDirs();</span><br><span class="line">                            <span class="keyword">int</span> len = dirs.length;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                                MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、调用了supper方法，将类库路径传给了supper构造的参数中，并且将parent参数传递的是null，至此extClassLoader则创建出来了</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] dirs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(getExtURLs(dirs), <span class="keyword">null</span>, factory);</span><br><span class="line">            SharedSecrets.getJavaNetAccess().</span><br><span class="line">                getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h6 id="AppClassLoader-创建过程"><a href="#AppClassLoader-创建过程" class="headerlink" title="AppClassLoader 创建过程"></a>AppClassLoader 创建过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取classpath下的类路径，并且new了一个AppClassLoader，将路径与扩展库加载器传递到构造参数。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> String s = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] path = (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> File[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    URL[] urls =</span><br><span class="line">                        (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> URL[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> AppClassLoader(urls, extcl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、AppClassLoader构造方法，将类路径数组与扩展库类加载器传到了supper</span></span><br><span class="line">        AppClassLoader(URL[] urls, ClassLoader parent) &#123;</span><br><span class="line">            <span class="keyword">super</span>(urls, parent, factory);</span><br><span class="line">            ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line">            ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 3、最后跟踪supper构造方法，将parent 保存在了一个成员变量里面。而对于AppClassLoader来说</span></span><br><span class="line"><span class="comment">//        这个parent就是扩展库的ClassLoader</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="类加载器初始化过程"><a href="#类加载器初始化过程" class="headerlink" title="类加载器初始化过程"></a>类加载器初始化过程</h6><p>类运行加载过程中会创建JVM启动器实例sun.misc.Launcher 并且使用了单例设计模式。</p><p>在Launcher构造方法内部，创建了两个类加载器，分别是：</p><pre><code>- ExtClassLoader 扩展类加载器- AppClassLoader 应用加载器 并且其parent是ExtClassLoader扩展类加载器- JVM默认使用Launcher的getClassLoader方法返回的类加载器实例，加载应用程序，而这个getClassLoader方法返回的就是AppClassLoader应用加载器。</code></pre><h6 id="双亲委派机制流程"><a href="#双亲委派机制流程" class="headerlink" title="双亲委派机制流程"></a>双亲委派机制流程</h6><p>每个类加载器都会维护一个已加载过的类数组，当需要加载某一个类时，类加载器执行顺序是：自定义加载器（如果有的话）-&gt; 应用类加载器 -&gt; 扩展类加载器 -&gt; 引导类加载器</p><p>假设现在需要加载一个User.class类，会从自定义加载器开始，先检查自身已加载类列表是否存在，如果存在则直接返回，如果不存在，调用parent类加载器进行加载，如果parent已加载列表也没有，则调用parent的parent类加载器，如此层层向上委托，直到没有parent为止。</p><p>如果最顶级的parent在它自己的已加载列表中找不到，则在它的类加载路径寻找文件，如果还找不到，则层层往下退回加载请求，每一层都执行同样的操作，只要有一层类加载器找到了，就会放到该加载器的已加载列表，并且返回该类的信息，如果所有的类加载器都没有找到，则抛出ClassNotFoundException。</p><p> <img src="https://oss.pencilso.cn/enclosure/classloader-shuangqin_1592006161540.png" alt="classloader-shuangqin"></p><h6 id="双亲委派机制源码实现"><a href="#双亲委派机制源码实现" class="headerlink" title="双亲委派机制源码实现"></a>双亲委派机制源码实现</h6><p>源码在ClassLoader.loadCLass </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 第一步，检查已经加载过的class，如果已加载过了，则直接return了。</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 如果该加载器有父类，则委托父加载器去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果该加载器没有父类，则用引导类加载器去加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="comment">// 如果所有的parent都加载不到的话，则去自己的类路径寻找文件</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="为什么要设计双亲委派机制"><a href="#为什么要设计双亲委派机制" class="headerlink" title="为什么要设计双亲委派机制"></a>为什么要设计双亲委派机制</h6><pre><code>- 沙箱安全机制 : 自己写的核心内库不会被加载，这样可以防止核心API库被随意篡改。- 避免类的重复加载：当父加载器已经加载了该类时，就没有必要子CLassLoader再加载一次，保证被加载类的唯一性</code></pre><p>尝试自定义String类如下，替换Java的核心类库String ，运行错误，提示找不到这个main方法。</p><p>原因String是Java核心类库，由引导类加载器最先加载的。在执行下列代码时，会委托给父加载器进行加载String，最后委托到引导类加载器的时候，会从引导类加载器返回回来，而引导类加载器所加载的String，是Java的核心类库，它的匹配规则是依据包名+类名的匹配规则来匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------My String ----------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure><h6 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h6><p>“全盘负责” 是指当一个ClassLoader装在一个类时，除非显示的使用另外一个CLassLoader，该类所依赖及引用的类也由这个CLassLoader载入。</p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><h6 id="自定义类加载器，加载Class文件"><a href="#自定义类加载器，加载Class文件" class="headerlink" title="自定义类加载器，加载Class文件"></a>自定义类加载器，加载Class文件</h6><p>实现一个简单的类加载器，只需要继承CLassLoader，并重写findClass 方法即可。</p><p>先准备一个示例类 : User </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.pencilso.study.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------this is User Class --------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对代码进行编译，编译之后class文件会在项目的target 目录下。</p><p>准备文件夹，将User这个类的class文件复制出来。</p><p>我把class文件放在了 “/Users/pencilso/Desktop/classloader/“ +  “cn/pencilso/study/classloader”</p><p>需要注意的是，后面的  “cn/pencilso/study/classloader” 对应的是这个类的包名。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pencilso@MacBook-Pro ~ % ls ~/Desktop/classloader/cn/pencilso/study/classloader</span><br><span class="line">User.class</span><br></pre></td></tr></table></figure><p>简单的类加载器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.pencilso.study.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/Users/pencilso/Desktop/classloader/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; userCLass = myClassLoader.loadClass(<span class="string">&quot;cn.pencilso.study.classloader.User&quot;</span>);</span><br><span class="line">        Object userInstance = userCLass.newInstance();</span><br><span class="line">        Method soutMethod = userCLass.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        soutMethod.invoke(userInstance, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader:&quot;</span> + userCLass.getClassLoader().getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * class 文件所在的文件夹</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String folder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从指定目录中寻找class文件</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将包名中的 &quot;.&quot; 替换为文件路径分隔符</span></span><br><span class="line">                String classPath = name.replace(<span class="string">&quot;.&quot;</span>, File.separator);</span><br><span class="line">                FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(folder + classPath + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> len = fileInputStream.available();</span><br><span class="line">                <span class="keyword">byte</span>[] classByte = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">                fileInputStream.read(classByte);</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">                <span class="comment">//解释class文件</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, classByte, <span class="number">0</span>, classByte.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，结果如下，可以看到已经调用到了User对象里面的”sout”方法，输出了 “this is User Class” 。</p><p>但是classLoader为什么还是AppClassLoader？</p><p>这是因为双亲委托机制的结果，自定义ClassLoader加载器也会向上层级委托。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------this is User Class --------</span><br><span class="line">classLoader:class sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure><p>源码分析：</p><p>我们的自定义类加载器是继承自CLassLoader，那么在初始化时会执行CLassLoader的构造方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1、ClassLoader的无参构造方法，调用了getSystemClassLoader，并且传入了二参构造    </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、getSystemClassLoader方法是获取一个CLassLoader对象，其初始化方法是 initSystemClassLoader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、初始化SystemClassLoader</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recursive invocation&quot;</span>);</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">// 调用了getClassLoader方法，而这个getClassLoader方法获取到的就是appClassLoader对象</span></span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">          ......</span><br><span class="line"> &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 4、查看二参的ClassLoader构造方法，可以得知，它最后将AppClassLoader对象存在了parent字段中。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面源码分析，我们自定义的类加载器，加载User.class，执行双亲委派机制时，委托到了AppClassLoader，后又委托到ExtClassLoader，后又委托到 BootstrapLoader ，而 BootstrapLoader 是肯定找不到这个类的，ExtClassLoader也找不到，委托退到AppClassLoader的时候找到了。所以上面的代码运行输出的ClassLoader是 AppClassLoader。</p><p>即使我们的User.class文件在项目的target目录下，和我们自己创建的外部文件夹都有一份，但是只要有一个类加载器加载到了文件，其他的类加载器则不再会加载。而AppClassLoader的层级比自定义ClassLoader的层级要高 。</p><p>那怎样让它用自定义加载器加载User.class ?</p><p>接下来，把源码中的User.java 删除，编译、重新运行，这次的结果是自定义的CLassLoader了，因为这时候target目录下已经没有了User.class ，所以AppClassLoader找不到这个类，委托会退到自定义CLassLoader，而自定义CLassLoader会去我们自定义的文件夹下面去找这个类文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------this is User Class --------</span><br><span class="line">classLoader:class cn.pencilso.study.classloader.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure><h6 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h6><p>我们得知在加载类文件时，需要经过双亲委派机制，层级向上委托，层级向下退回。</p><p>那么如何指定让自定义加载器直接加载，而不向上委托？</p><p>之前提到过双亲委派机制的源码实现在 ClassLoader.loadCLass  中，那么自定义类加载器继承后，在MyClassLoader类中，重写loadClass方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="keyword">if</span> (name.equals(<span class="string">&quot;cn.pencilso.study.classloader.User&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//当加载指定的类时，不委托给父加载器，自行加载。</span></span><br><span class="line">                        c = findClass(name);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//默认委托给父加载器</span></span><br><span class="line">                        c = getParent().loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接下来把源码中的User.java 文件添加回来，再次执行，最后输出的是我们自定义的类加载器了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------this is User Class --------</span><br><span class="line">classLoader:class cn.pencilso.study.classloader.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">类加载全过程、双亲委派机制。</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="类加载机制" scheme="https://songlongkuan.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存设计与性能优化</title>
    <link href="https://songlongkuan.com/2020/06/26/redis_cache_optimization/"/>
    <id>https://songlongkuan.com/2020/06/26/redis_cache_optimization/</id>
    <published>2020-06-26T09:50:00.000Z</published>
    <updated>2021-01-31T12:16:06.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存设计需要注意的问题"><a href="#缓存设计需要注意的问题" class="headerlink" title="缓存设计需要注意的问题"></a>缓存设计需要注意的问题</h2><a id="more"></a><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h6 id="缓存穿透原因"><a href="#缓存穿透原因" class="headerlink" title="缓存穿透原因"></a>缓存穿透原因</h6><p>缓存穿透是指查询一个根本不存在的数据，缓存层不会命中，从而大量的查询存储层。</p><p>通常我们的设计如图下所示：</p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200626-141708@2x_1593152275864.png" alt="QQ20200626-141708@2x"></p><p>缓存穿透会导致每次的请求都会执行db查询，增加数据库的压力，从而失去了缓存的意义。</p><p>造成这种情况出现基本原因有两个</p><ul><li>自身业务代码或者数据出现问题</li><li>一些恶意攻击，爬虫等造成大量空命中</li></ul><h6 id="缓存穿透解决方案"><a href="#缓存穿透解决方案" class="headerlink" title="缓存穿透解决方案"></a>缓存穿透解决方案</h6><p>解决方案 一 ：</p><p>​    对空对象进行缓存，也就是说，即使从db获取不到数据，也进行缓存，放到redis中。</p><p>​    但是这种方案，如果是恶意攻击的话，不太适用，倘若对方生成上亿个key，查询不到难道都放redis中吗？</p><p>解决方案二：</p><p>​    布隆过滤器：</p><p>​    布隆过滤器是一个大型的位数组和几个不一样的无偏hash函数。所谓无偏就是能够把元素的hash值算的比较均匀。</p><p>向布隆过滤器添加key时，会使用多个hash函数对key进行hash运算，每个函数算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个hash函数都会算得一个不同的位置，再把位数组的这几个位置都设置为1，就完成了add操作。</p><p>向布隆过滤器询问key是否存在时，同样会用多个hash函数对key进行运算，多个函数运算的整数索引值再取模位数组长度，最后得到key的多个所在位置，已知key所在的位置，取出数据判断是否都为1，只要有一个位置为0，则表示这个key是不存在的，但是如果都为1的话，这并不表示这个key就一定存在，只是极有可能存在。因为有可能是多个key产生了hash碰撞，导致其他的key对这个位置的数据设置为了1。</p><p>大概结构图长下面这个样子：</p><p>​        布隆过滤器在对多个key进行hash运算时，存在hash碰撞的可能，如下所示，两个key的hash-3算法碰撞。位数组越小，产生的概率就会越大。</p><p> <img src="https://oss.pencilso.cn/enclosure/redis_boolean_1593156113933.png" alt="redis_boolean"></p><p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都可以过滤掉，不让请求再往后端发送，当布隆过滤器说某个值存在时，这个值可能存在；当它说不存在时，那就肯定不存在。</p><p>代码维护较为复杂，但是缓存空间占用很少。</p><h6 id="Guava-布隆过滤器"><a href="#Guava-布隆过滤器" class="headerlink" title="Guava 布隆过滤器"></a>Guava 布隆过滤器</h6><p>谷歌的Guava包里面有布隆过滤器实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaBooleanFilterMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(</span><br><span class="line">                Funnels.stringFunnel(Charset.defaultCharset()),</span><br><span class="line">                <span class="number">1000</span>,<span class="comment">//预期的数据量</span></span><br><span class="line">                <span class="number">0.001</span><span class="comment">//预期的误差值，必须为正，且小于0</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//添加指定的key</span></span><br><span class="line">        bloomFilter.put(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;lisi&quot;</span>));</span><br><span class="line">        System.out.println(bloomFilter.mightContain(<span class="string">&quot;wangwu&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----输出结果如下</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><h6 id="Redisson-布隆过滤器"><a href="#Redisson-布隆过滤器" class="headerlink" title="Redisson 布隆过滤器"></a>Redisson 布隆过滤器</h6><p>Guava 的布隆过滤器只适合单机模式下的进程。</p><p>而大多数场景都是集群、分布式部署的，所以我们需要分布式的布隆过滤器，Redisson对这方面也有实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先创建JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeObject</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="单点Redis使用"><a href="#单点Redis使用" class="headerlink" title="单点Redis使用"></a>单点Redis使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@RequestMapping(&quot;redis_filter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">redisFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RBloomFilter&lt;SomeObject&gt; bloomFilter = redissonClient.getBloomFilter(<span class="string">&quot;sample&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化布隆过滤器</span></span><br><span class="line">        <span class="comment">// 预期插入数据 = 55000000</span></span><br><span class="line">        <span class="comment">// 预期错误概率 必须为正数，且小于0 = 0.03</span></span><br><span class="line">        bloomFilter.tryInit(<span class="number">55000000L</span>, <span class="number">0.03</span>);</span><br><span class="line"></span><br><span class="line">        bloomFilter.add(<span class="keyword">new</span> SomeObject(<span class="string">&quot;field1Value&quot;</span>, <span class="string">&quot;field2Value&quot;</span>));</span><br><span class="line">        bloomFilter.add(<span class="keyword">new</span> SomeObject(<span class="string">&quot;field5Value&quot;</span>, <span class="string">&quot;field8Value&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;contains-&gt; field1Value :&quot;</span>+bloomFilter.contains(<span class="keyword">new</span> SomeObject(<span class="string">&quot;field1Value&quot;</span>, <span class="string">&quot;field2Value&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;contains-&gt; field1Value :&quot;</span>+bloomFilter.contains(<span class="keyword">new</span> SomeObject(<span class="string">&quot;field5Value&quot;</span>, <span class="string">&quot;123&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;count:&quot;</span> + bloomFilter.count());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">-- 输出内容如下</span><br><span class="line">  </span><br><span class="line">contains-&gt; field1Value :<span class="keyword">true</span></span><br><span class="line">contains-&gt; field1Value :<span class="keyword">false</span></span><br><span class="line">count:<span class="number">4</span></span><br></pre></td></tr></table></figure><h6 id="集群Redis节点使用"><a href="#集群Redis节点使用" class="headerlink" title="集群Redis节点使用"></a>集群Redis节点使用</h6><p>该api 官方文档上说只支持redisson pro版本使用，我这里就没有再去测试了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RClusteredBloomFilter&lt;SomeObject&gt; bloomFilter = redisson.getClusteredBloomFilter(<span class="string">&quot;sample&quot;</span>);</span><br><span class="line"><span class="comment">// initialize bloom filter with </span></span><br><span class="line"><span class="comment">// expectedInsertions = 255000000</span></span><br><span class="line"><span class="comment">// falseProbability = 0.03</span></span><br><span class="line">bloomFilter.tryInit(<span class="number">255000000L</span>, <span class="number">0.03</span>);</span><br><span class="line">bloomFilter.add(<span class="keyword">new</span> SomeObject(<span class="string">&quot;field1Value&quot;</span>, <span class="string">&quot;field2Value&quot;</span>));</span><br><span class="line">bloomFilter.add(<span class="keyword">new</span> SomeObject(<span class="string">&quot;field5Value&quot;</span>, <span class="string">&quot;field8Value&quot;</span>));</span><br><span class="line">bloomFilter.contains(<span class="keyword">new</span> SomeObject(<span class="string">&quot;field1Value&quot;</span>, <span class="string">&quot;field8Value&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h3><p>由于大批量缓存在同一时间失效，可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大，甚至挂掉，对于这种情况，我们可以在批量增加缓存时最好将这一批数据的缓存过期时间设置为一个时间段内的不同时间。</p><p>比如说基础失效时间为3分钟，那么3minute + random(60) second ，为最终的失效时间。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩指的是缓存层支撑不住或者宕机后，流量会大量的打到后端的存储层。</p><p>由于缓存层承载着大量请求，有效保护了存储层，如果缓存层由于某些原因不能提供服务（比如大量并发请求、缓存设计不好、类似大量请求访问bigkey ； 导致缓存能支撑的并发急剧下降），于是大量请求都会打到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。</p><p>预防和解决缓存雪崩问题，可以从以下三个方面进行。</p><ul><li>保障缓存层服务的高可用性，比如使用Redis Sentinel 、 Redis Cluster。</li><li>依赖隔离组件为后端接口限流并降级。</li><li>提前演练。在项目上线前，演练缓存层宕机后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。</li></ul><h3 id="热点缓存key重建优化"><a href="#热点缓存key重建优化" class="headerlink" title="热点缓存key重建优化"></a>热点缓存key重建优化</h3><p>使用 “缓存+过期时间” 的策略既可以实现加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。但是有两个问题如果同时出现，可能就会对应用造成致命的危害：</p><ul><li>当前key是一个热点 key，并发量非常大</li><li>重建缓存不能在短时间完成，可能是一个复杂的计算、复杂的Sql、多次IO 等等</li></ul><p>在缓存失效的瞬间，有大量线程来重建缓存，会造成后端负载加大，甚至可能会让应用崩溃。</p><p>要解决这个问题主要就是避免大量线程同时重建缓存。</p><p>可以利用互斥锁来解决，一般来说，使用JDK内置的互斥锁足够了，保障一个进程只有一个线程执行重建缓存。</p><p>如果有大量的集群节点的话，可以使用Redis的分布式锁来做，最终的目的是达到只有一个线程重建缓存。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="键值设计"><a href="#键值设计" class="headerlink" title="键值设计"></a>键值设计</h3><h6 id="key-设计"><a href="#key-设计" class="headerlink" title="key 设计"></a>key 设计</h6><p>1、可读性和可管理性</p><p>以业务名（或数据库名）为前缀（防止key冲突），用冒号分隔，比如业务名:表名:id</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">share:article:1</span><br></pre></td></tr></table></figure><p>2、简洁性</p><p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始key: user:&#123;uid&#125;:friends:message:&#123;mid&#125;</span><br><span class="line">简化key: u:&#123;uid&#125;:fr:m&#123;mid&#125;</span><br></pre></td></tr></table></figure><h6 id="value-设计"><a href="#value-设计" class="headerlink" title="value 设计"></a>value 设计</h6><p>1、拒绝bigkey （防止网卡流量、慢查询）</p><ul><li><p>字符串类型 : 它的big体现在单个value值很大，一般认为超过10kb就是bigkey。</p></li><li><p>非字符串类型 : 哈希、列表、集合、有序即可，它们的big体现在元素个数太多。</p></li></ul><p>一般来说，String类型控制在10kb以内，hash、list、set、zset元素个数不要超过5000.</p><p>非字符串的bigkey，不要直接使用del删除，否则会引起阻塞情况的发生，应使用hcan、sscan、zscan方式渐进式删除。</p><p>同时要注意防止bigkey过期时间自动删除问题，如果没有设置异步过期的话，redis过期删除也会造成阻塞。</p><h6 id="bigkey的危害"><a href="#bigkey的危害" class="headerlink" title="bigkey的危害"></a>bigkey的危害</h6><ul><li>导致redis阻塞</li><li>网络拥塞<ul><li>bigkey也就意味着每次获取要产生的网络流量较大，假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通千兆网卡的服务器来讲简直是灭顶之灾。</li></ul></li><li>过期删除<ul><li>有个bigkey，一旦设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除（ lazyfree-lazy- expire yes ），就会存在阻塞Redis的可能性。</li></ul></li></ul><h6 id="bigkey的产生"><a href="#bigkey的产生" class="headerlink" title="bigkey的产生"></a>bigkey的产生</h6><ul><li>社交类：粉丝列表，如果某些明星或者大V不精心设计下，必是bigkey。</li><li>统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。</li><li>缓存类：将数据从数据库load出来，序列化放到Redis里，这个方式非常常用，但是有两个地方需要注意。<ul><li>是不是有必要把所有字段都缓存</li><li>有没有相关关联的数据，可能为了图方便把相关数据都存一个key下，产生bigkey。</li></ul></li></ul><h6 id="如何优化bigkey"><a href="#如何优化bigkey" class="headerlink" title="如何优化bigkey"></a>如何优化bigkey</h6><ul><li>拆成多个key，可以参考 ConcurrentHashMap的分段式设计。<ul><li>Biglist –&gt; list-1、list-2、list-3…list-N </li></ul></li><li>如果bigkey不可避免，也要考虑一下有没有必要每次都把所有元素取出来（例如有时候仅仅需要hmget，而不是hgetall），删除也是一样，尽量使用优雅的方式来处理。</li><li>选择适合的数据类型<ul><li>比如对象类型，应放到hash数据类型里。 例如 : “ hmset user:1 name zhangsan age 20”</li></ul></li><li>控制key的生命周期<ul><li>使用expire设置过期时间（条件允许可以打散过期时间，防止集中过期）。</li></ul></li></ul><h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><ul><li>O(N) 命令关注N的数量<ul><li>例如hgetall、lrange、smembers、zrange、sinter等并发不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</li></ul></li><li>禁用命令<ul><li>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</li></ul></li><li>合理使用select<ul><li>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</li></ul></li><li>使用批量操作提高效率<ul><li>原生命令：mget、mset…</li><li>非原生命令：可以使用pipeline管道提高效率。</li></ul></li><li>Redis事务功能较弱，不建议过多使用，可以用lua替代</li></ul><h3 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h3><p>避免多个应用使用一个Redis实例</p><p>使用带有连接池的数据库，可以有效控制连接，同时提高效率，比如JedisPool。</p><p>客户端参数调优</p><ul><li>maxActive：最大连接数<ul><li>这个参数考虑的因素比较多：</li><li>业务希望Redis的并发量</li><li>客户端执行命令时间</li><li>Redis资源： 应用个数 * maxActive 是不能超过 redis的最大连接数 maxclients。</li><li>资源开销：虽然希望控制空闲连接（连接池此刻可用连接），但是不希望因为连接池的频繁释放和创建连接造成不必要的开销。</li><li>假设：一次redis命令时间的平均耗时约为1ms，那么一个连接的QPS大约是1000。业务期望的QPS是50000，那么理论上需要的资源池大小是 50000 / 1000 = 50 个连接。但事实上这只是个理论值，还要考虑到预留一些资源，通常我们会为maxActive设置的比理论值大一些。</li><li>maxActive 并不是设置越大越好，一方面连接太多占用客户端和服务端资源，另一方面对于Redis这种单线程的服务，一个大命令的阻塞即使设置再大资源池仍然会无济于事。</li></ul></li><li>maxIdle <ul><li>maxIdle实际上才是业务需要的最大连接数，maxActive是为了给出余量，所以maxIdle不要设置过小，否则会有创建新连接的开销。</li><li>连接池的最佳性能是maxActive = maxIdle，这样就避免连接池伸缩带来的性能干扰。</li><li>但是如果并发量不大或者maxActive设置过高，会导致不必要的连接资源浪费，一般推荐maxIdle可以设置为按上面的业务期望QPS计算出来的理论连接数，maxActive可以再放大一倍。</li></ul></li><li>minIdle<ul><li>minIdle (至少需要保持的空闲连接数)，在使用连接的过程中，如果连接数超过了minIdle，那么会继续建立连接，如果超过了maxIdle，当超过的连接执行完业务后悔慢慢被移出连接池并释放掉。</li><li>如果系统启动完，马上就会有很多的请求过来，那么可以给redis连接池做预热，比如快速的创建一些redis连接，执行简单命令，类似ping() ， 快速的将连接池里的空闲连接提升到minIdle的数量。</li></ul></li></ul><p>高并发下建议客户端添加熔断功能（netflix、hystrix）</p><p>设置合理的密码，如有必要可以使用SSL加密访问</p><h3 id="Redis-清除策略"><a href="#Redis-清除策略" class="headerlink" title="Redis 清除策略"></a>Redis 清除策略</h3><p>Redis对于过期键有三种清除策略</p><ul><li><p>被动删除：当读/写一个已经过期的key时，会出发惰性删除策略，直接删除掉这个过期key</p></li><li><p>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key</p></li><li><p>当前已用内存超过maxmemory限定时，触发主动清理策略</p></li></ul><p>当Redis运行在主从模式时，只有主节点才会执行被动和主动这两种过期删除策略，然后把删除操作” del key “ 同步到从节点。</p><p>第三种策略的情况如下:</p><p>当前已用内存超过maxmemory限定时，会触发主动清理策略</p><p>根据自身业务类型，选好maxmemory-policy ( 最大内存淘汰策略 )，设置好过期时间。如果不设置最大内存，当Redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap ) ，会让Redis的性能急剧下降。</p><p>默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p>其他策略如下:</p><ul><li><p>allkeys-lru: 根据lru算法删除键，不管数据有没有设置超时时间，直到腾出足够空间位置。</p></li><li><p>allkeys-random : 随机删除所有键，直到腾出足够空间为止。</p></li><li><p>volatile-random : 随机删除过期键，直到腾出足够空间为止。</p></li><li><p>Volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</p></li><li><p>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息 “(error) </p><p>OOM command not allowed when used memory”，此时Redis只响应读操作。</p></li></ul>]]></content>
    
    
    <summary type="html">Redis 缓存设计与性能优化</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Lua脚本原子性、高并发分布式锁</title>
    <link href="https://songlongkuan.com/2020/06/26/redis_lua_lock/"/>
    <id>https://songlongkuan.com/2020/06/26/redis_lua_lock/</id>
    <published>2020-06-26T02:57:00.000Z</published>
    <updated>2021-01-31T12:19:08.598Z</updated>
    
    <content type="html"><![CDATA[<p>在集群环境多节点下，存在多个进程竞争资源的问题，而传统Java自带的锁已经不能满足需求，这时就需要分布式锁。</p><p>分布式锁有多种实现方案，Zookeeper等，而Redis的分布式锁性能非常高。</p><a id="more"></a><h6 id="模拟减库存场景"><a href="#模拟减库存场景" class="headerlink" title="模拟减库存场景"></a>模拟减库存场景</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redis/lock&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplatel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1001商品的 redis key</span></span><br><span class="line">    <span class="keyword">private</span> String rediskey = <span class="string">&quot;product:1001:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化库存100</span></span><br><span class="line">        stringRedisTemplatel.opsForValue().set(rediskey + <span class="string">&quot;stock&quot;</span>, String.valueOf(<span class="number">50</span>));</span><br><span class="line">        log.info(<span class="string">&quot;init stock 100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖出商品接口</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sellProduct&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sellProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试使用jdk内置锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ValueOperations&lt;String, String&gt; stringValueOperations = stringRedisTemplatel.opsForValue();</span><br><span class="line">            <span class="comment">//查询库存</span></span><br><span class="line">            Integer stock = Integer.valueOf(stringValueOperations.get(rediskey + <span class="string">&quot;stock&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//库存不足</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;库存不足&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;sell product , current stock:[&#123;&#125;] , surplus stock: [&#123;&#125;]&quot;</span>, stock, --stock);</span><br><span class="line">            stringValueOperations.set(rediskey + <span class="string">&quot;stock&quot;</span>, String.valueOf(stock));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成功售出&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码，单机情况下是没有什么问题的，但是在集群环境下，存在多个进程消费一个stock的可能。</p><p>配置nginx反向代理，然后idea运行两个SpringBoot进程，端口不同，分别为9090，9092.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream myServer &#123;</span><br><span class="line">    server 192.168.2.103:9090 weight=1;</span><br><span class="line">    server 192.168.2.103:9092 weight=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://myServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置jmeter自动化工具， 开启1000个线程，循环3次，调用nginx端口，再由nginx反向代理到两个进程。<img src="https://oss.pencilso.cn/enclosure/redis_lock_jmeter_1592834574919.png" alt="redis_lock_jmeter"></p><p>测试结果输出如下，可见两个进程都消费了40，38 这两个库存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 9090端口</span></span><br><span class="line">...</span><br><span class="line">sell product , current stock:[40] , surplus stock: [39]</span><br><span class="line">sell product , current stock:[38] , surplus stock: [37]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9092</span></span><br><span class="line">sell product , current stock:[40] , surplus stock: [39]</span><br><span class="line">sell product , current stock:[38] , surplus stock: [37]</span><br></pre></td></tr></table></figure><h6 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h6><p>在redis中，存在setnx指令集，redis在执行这条指令之前会判断key是否已存在，key不存在的时候才会执行，并且返回1，如果key已存在，则不会执行，并且返回0。</p><p>改造sellProduct接口，使用redistemplate的setIfAbsent方法，并且同时设置超时时间。</p><p>如果没有设置超时时间的话，万一线程在获取锁后宕机了，没来得及释放锁，也就是没有删除key，那么就会造成其他的线程无法获得锁。</p><p>为了防止代码出现异常无法删除key，应在finally代码块中删除key，而且在删除前，应判断是否是当前线程加的锁，否则可能删除掉其他线程加的锁。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;sellProduct&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">sellProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// setnx锁的key</span></span><br><span class="line">     String redisLockKey = rediskey + <span class="string">&quot;lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">     ValueOperations&lt;String, String&gt; stringValueOperations = stringRedisTemplatel.opsForValue();</span><br><span class="line">     <span class="comment">//生成一个uuid作为线程标识</span></span><br><span class="line">     String uuid = UUID.randomUUID().toString();</span><br><span class="line">     <span class="comment">//redistemplate为我们包装了setnx指令，这里执行setnx指令获取锁并且指定超时时间。</span></span><br><span class="line">     Boolean redisLock = stringValueOperations.setIfAbsent(redisLockKey, uuid, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (!redisLock) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">&quot;操作频繁&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//查询库存</span></span><br><span class="line">         Integer stock = Integer.valueOf(stringValueOperations.get(rediskey + <span class="string">&quot;stock&quot;</span>));</span><br><span class="line">         <span class="keyword">if</span> (stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//库存不足</span></span><br><span class="line">             <span class="keyword">return</span> <span class="string">&quot;库存不足&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         log.info(<span class="string">&quot;sell product , current stock:[&#123;&#125;] , surplus stock: [&#123;&#125;]&quot;</span>, stock, --stock);</span><br><span class="line">         stringValueOperations.set(rediskey + <span class="string">&quot;stock&quot;</span>, String.valueOf(stock));</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//判断 这把锁是否是当前线程加的锁，是当前线程加的锁才删除掉</span></span><br><span class="line">         <span class="keyword">if</span> (uuid.equals(stringValueOperations.get(redisLockKey))) &#123;</span><br><span class="line">             <span class="comment">//删除key，释放锁</span></span><br><span class="line">             stringRedisTemplatel.delete(redisLockKey);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;成功售出&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这时候再次开启jmeter，已经不会出现重复消费的问题了，一般来讲，做到这里已经足够了但是还会遇到一些问题。</p><ul><li>比如说在删除key之前，这个线程宕了，那么就会导致key在超时时间之前无法被释放，从而造成死锁。</li><li>假设锁的超时时间是10秒，而某一个线程获取锁后需要执行15秒，那么就会导致线程还没执行完毕，而锁已经自动释放，这时候其他线程获取锁后，存在资源竞争的问题。</li></ul><h6 id="Redis-lua脚本原子操作"><a href="#Redis-lua脚本原子操作" class="headerlink" title="Redis lua脚本原子操作"></a>Redis lua脚本原子操作</h6><p>以下代码，可能存在的问题是，在执行equals方法之后，执行delete之前宕机了，那么就会导致无法删除key。</p><p>也就是无法保证get、delete 两个操作的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断 这把锁是否是当前线程加的锁，是当前线程加的锁才删除掉</span></span><br><span class="line"><span class="keyword">if</span> (uuid.equals(stringValueOperations.get(redisLockKey))) &#123;</span><br><span class="line">    <span class="comment">//删除key，释放锁</span></span><br><span class="line">    stringRedisTemplatel.delete(redisLockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用lua脚本来保障原子性</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取指定key的内容，并且放到变量里 uuid</span></span><br><span class="line"><span class="keyword">local</span> uuid = redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 判断uuid 是否与传递进来的uuid一致</span></span><br><span class="line"><span class="keyword">if</span> (uuid == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">         <span class="comment">-- 删除key  </span></span><br><span class="line">    redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line">      <span class="comment">-- 返回 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">--返回 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="comment">-- 脚本结束</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用RedisTemplate 执行lua脚本。lua脚本可以一次性执行多条redis命令，以此保障原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DefaultRedisScript&lt;Number&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">redisScript.setResultType(Number.class);</span><br><span class="line">redisScript.setScriptText(</span><br><span class="line">        <span class="string">&quot;local uuid = redis.call(\&quot;get\&quot;,KEYS[1])\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;if (uuid == ARGV[1]) then\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    redis.call(\&quot;del\&quot;,KEYS[1])\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    return 1\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    return 0\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>);</span><br><span class="line">List&lt;String&gt; keys = Collections.singletonList(redisLockKey);</span><br><span class="line">Number execute = stringRedisTemplatel.execute(</span><br><span class="line">        redisScript,</span><br><span class="line">        keys,</span><br><span class="line">        uuid</span><br><span class="line">);</span><br><span class="line">            <span class="comment">//这里的返回值，就是在lua脚本写的return所返回的</span></span><br><span class="line"><span class="keyword">int</span> result = execute.intValue();</span><br><span class="line">log.info(<span class="string">&quot;execute:[&#123;&#125;]&quot;</span>, result);</span><br></pre></td></tr></table></figure><h6 id="Redisson-分布式锁"><a href="#Redisson-分布式锁" class="headerlink" title="Redisson 分布式锁"></a>Redisson 分布式锁</h6><p>之前提到过，假设setnx锁的超时时间设置为10秒，而某一个线程执行需要15秒，那么这个线程还未执行结束，其他线程会获取到锁，可能会产生资源竞争。那么要解决这个问题的话，有一套方案是为这把锁续命，就是开启一个子线程，然后延迟（超时时间 / 3）重新设置锁的超时时间。</p><p>Redisson已经提供了相应的实现，直接使用就可以。</p><p>添加pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置redisson</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">getRedisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><span class="line">                .setRetryInterval(<span class="number">5000</span>)</span><br><span class="line">                .setTimeout(<span class="number">10000</span>)</span><br><span class="line">                .setConnectTimeout(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redis/lock&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplatel;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1001商品的 redis key</span></span><br><span class="line">    <span class="keyword">private</span> String rediskey = <span class="string">&quot;product:1001:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化库存100</span></span><br><span class="line">        stringRedisTemplatel.opsForValue().set(rediskey + <span class="string">&quot;stock&quot;</span>, String.valueOf(<span class="number">50</span>));</span><br><span class="line">        log.info(<span class="string">&quot;init stock 100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖出商品接口</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sellProduct&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sellProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// setnx锁的key</span></span><br><span class="line">        String redisLockKey = rediskey + <span class="string">&quot;lock&quot;</span>;</span><br><span class="line">        <span class="comment">//初始化锁</span></span><br><span class="line">        RLock lock = redissonClient.getLock(redisLockKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行加锁操作，如果没有竞争到锁，则会自旋，等待下一次获取锁。</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            ValueOperations&lt;String, String&gt; stringValueOperations = stringRedisTemplatel.opsForValue();</span><br><span class="line">            <span class="comment">//查询库存</span></span><br><span class="line">            Integer stock = Integer.valueOf(stringValueOperations.get(rediskey + <span class="string">&quot;stock&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//库存不足</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;库存不足&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;sell product , current stock:[&#123;&#125;] , surplus stock: [&#123;&#125;]&quot;</span>, stock, --stock);</span><br><span class="line">            stringValueOperations.set(rediskey + <span class="string">&quot;stock&quot;</span>, String.valueOf(stock));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成功售出&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点需要注意的是，lock.lock(); 是阻塞操作，当它获取锁失败，会自旋，一直获取锁。</p><p>如果不需要使用自旋锁，可以用，lock.tryLock() ；api 它会返回一个boolean类型的返回值 。</p>]]></content>
    
    
    <summary type="html">Redis Lua脚本原子性、高并发分布式锁</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
    <category term="lua" scheme="https://songlongkuan.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存高可用集群、水平扩容、水平缩容</title>
    <link href="https://songlongkuan.com/2020/06/20/redis_cluster/"/>
    <id>https://songlongkuan.com/2020/06/20/redis_cluster/</id>
    <published>2020-06-19T16:27:00.000Z</published>
    <updated>2021-01-31T12:13:22.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis有主从架构、哨兵架构，哨兵架构可以在master节点宕机的情况下，通过选举的方式切换slave节点作为新的master主节点。</p><p>哨兵架构的情况下，只能提供一个master主节点，也就是说只能有一个“写”的节点，这种情况下redis的性能瓶颈问题就暴露出来了，它支撑不了很高的并发。</p><p>而且在哨兵架构下，倘若master宕机了，而新的slave升级为master，这个切换的时间段，短则几秒，长则十几秒甚至更长都是有可能的。</p><p>而且单个主节点master，也不适合设置过大的内存，否则redis启动时恢复数据，需要过长的时间。</p><a id="more"></a><h2 id="高可用集群介绍"><a href="#高可用集群介绍" class="headerlink" title="高可用集群介绍"></a>高可用集群介绍</h2><p> <img src="https://oss.pencilso.cn/enclosure/redis-cluster_1592572253175.png" alt="redis-cluster"></p><p>Redis 集群是一个由多个小的主从节点群组，组成的分布式服务器群，它具有复制、高可用、分片特性。</p><p>Redis集群不需要哨兵也能完成节点移除和故障转移。</p><p>需要将每个节点设置为集群模式，这种集群模式没有中心节点，可以水平扩展。</p><p>redis集群环境下，可以提供多个master主节点，也就是可以提供多个“写”的节点，所以它的性能和高可用性均优于哨兵模式，而且它的配置还很简单。</p><pre><code>- 复制 ：跟主从架构一样，master会把数据同步到slave节点- 高可用：当某一个master挂了的情况下，其他的master还在正常运行，而且其他的master会选举slave作为新的master。- 分片：redis使用了crc16的算法，对key进行运算，然后将key分布到各个master节点当中</code></pre><h2 id="Redis高可用集群搭建"><a href="#Redis高可用集群搭建" class="headerlink" title="Redis高可用集群搭建"></a>Redis高可用集群搭建</h2><h6 id="在centos上搭建集群"><a href="#在centos上搭建集群" class="headerlink" title="在centos上搭建集群"></a>在centos上搭建集群</h6><p>我这里准备了三个centos虚拟机，我准备在三个centos上都搭建一主二从。三个虚拟机ip如下：</p><pre><code>- 10.211.55.6- 10.211.55.7- 10.211.55.8</code></pre><p>假设已经下载好了redis在linux系统上，并且已编译。</p><p>先在第一台centos上进行操作部署。（ 10.211.55.6 ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 /root目录下创建文件夹 redis-cluster，并且在下面创建两个文件夹，以要运行的端口号为命名。</span></span><br><span class="line">[root@localhost redis-cluster]# mkdir 8010 8011 8012</span><br><span class="line">[root@localhost redis-cluster]# ls</span><br><span class="line">8010  8011  8012</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制配置文件到各个端口文件夹下</span></span><br><span class="line">cp /root/redis/redis.conf /root/redis-cluster/801*/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -----对每个redis.conf文件进行修改-----</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ps: 可以先修改一个redis.conf，其他的端口直接用vim的%s替换命令，替换端口即可。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置后台守护进程运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> redis要运行的端口号</span></span><br><span class="line">port 8010</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定数据文件存放位置，如果多个redis实例的存放位置一致的话，会导致数据丢失，以端口号命名</span></span><br><span class="line">dir /root/redis-cluster/8010/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志存放文件名，这里以端口号命名</span></span><br><span class="line">logfile &quot;8010.log&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启集群模式 , 默认这个配置被注释了，解开就可以。</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群节点信息文件，这里的文件命名最好和port对应上，默认也注释掉了。</span></span><br><span class="line">cluster-config-file nodes-8010.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群节点的超时时间 单位毫秒 , 默认也被注释了</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 去掉<span class="built_in">bind</span>绑定访问ip信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启aof数据备份</span></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ------如果需要设置密码的话，增加以下配置------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置redis访问密码</span></span><br><span class="line">requirepass 666666</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置集群节点间的访问密码</span></span><br><span class="line">masterauth 888888</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第一台centos上，运行三个个实例</span></span><br><span class="line">[root@localhost redis-cluster]# /root/redis/src/redis-server /root/redis-cluster/8010/redis.conf</span><br><span class="line">[root@localhost redis-cluster]# /root/redis/src/redis-server /root/redis-cluster/8011/redis.conf</span><br><span class="line">[root@localhost redis-cluster]# /root/redis/src/redis-server /root/redis-cluster/8012/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看进程，可以看到三个进程已经启动，进程信息后面的[cluster]，表示以集群方式运行。</span></span><br><span class="line">[root@localhost redis-cluster]# ps -ef | grep redis</span><br><span class="line">root     23081     1  0 22:15 ?        00:00:00 /root/redis/src/redis-server *:8010 [cluster]</span><br><span class="line">root     23099     1  0 22:15 ?        00:00:00 /root/redis/src/redis-server *:8011 [cluster]</span><br><span class="line">root     23114     1  0 22:15 ?        00:00:00 /root/redis/src/redis-server *:8012 [cluster]</span><br></pre></td></tr></table></figure><p>进入第二台、第三台centos执行相同的操作，需要注意的是需要更改不同的redis端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 10.211.55.7 centos</span></span><br><span class="line">[root@localhost redis-cluster]# ps -ef | grep redis</span><br><span class="line">root     23787     1  0 22:19 ?        00:00:00 /root/redis/src/redis-server *:8020 [cluster]</span><br><span class="line">root     23807     1  0 22:19 ?        00:00:00 /root/redis/src/redis-server *:8021 [cluster]</span><br><span class="line">root     23822     1  0 22:19 ?        00:00:00 /root/redis/src/redis-server *:8022 [cluster]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.211.55.8 centos</span></span><br><span class="line">[root@localhost redis-cluster]# ps -ef | grep redis</span><br><span class="line">root     24705     1  0 22:21 ?        00:00:00 /root/redis/src/redis-server *:8030 [cluster]</span><br><span class="line">root     24720     1  0 22:21 ?        00:00:00 /root/redis/src/redis-server *:8031 [cluster]</span><br><span class="line">root     24732     1  0 22:21 ?        00:00:00 /root/redis/src/redis-server *:8032 [cluster]</span><br></pre></td></tr></table></figure><p>最后三台服务器结构图如下 <img src="https://oss.pencilso.cn/enclosure/redis-cluster-node-centos_1592576899590.png" alt="redis-cluster-node-centos"></p><h6 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h6><p>用redis-cli 创建整个redis集群，注意需要将防火墙关掉，或者暴露出redis的gossip 通讯端口。</p><p>redis的gossip通讯端口一般为数据端口+10000，例如8010端口，8010+10000 = 18010 （gossip 端口）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -a <span class="string">&#x27;requirepass&#x27;</span> 用密码访问， ‐‐cluster create 创建集群 ‐‐cluster‐replicas 1 为每个master设置多少个slave节点</span>  </span><br><span class="line">/root/redis/src/redis‐cli ‐a requirepass ‐‐cluster create ‐‐cluster‐replicas 2 xxx:port ....</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例创建集群，在任意服务器运行即可。</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 --cluster create --cluster-replicas 2 10.211.55.6:8010 10.211.55.6:8011 10.211.55.6:8012 10.211.55.7:8020 10.211.55.7:8021 10.211.55.7:8022 10.211.55.8:8030 10.211.55.8:8031 10.211.55.8:8032</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这时候它会提示你给各个master分配slots槽位，输yes回车即可</span></span><br><span class="line">......</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): </span><br></pre></td></tr></table></figure><p>验证集群是否搭建成功，连接任意一个客户端 （ -c 表示集群模式 ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.6 -p 8010</span><br></pre></td></tr></table></figure><p> 查看节点列表 （ cluster nodes ）</p><p><img src="https://oss.pencilso.cn/enclosure/redis-cluster-nodes-info_1592578844133.png" alt="redis-cluster-nodes-info"></p><p>查看集群信息 ( cluster info ) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10.211.55.6:8010&gt; cluster info</span><br><span class="line">cluster_state:ok  </span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:9</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:9</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:683</span><br><span class="line">cluster_stats_messages_pong_sent:575</span><br><span class="line">cluster_stats_messages_sent:1258</span><br><span class="line">cluster_stats_messages_ping_received:567</span><br><span class="line">cluster_stats_messages_pong_received:683</span><br><span class="line">cluster_stats_messages_meet_received:8</span><br><span class="line">cluster_stats_messages_received:1258</span><br></pre></td></tr></table></figure><p>字段解释摘自：<a href="http://www.redis.cn/commands/cluster-info.html">http://www.redis.cn/commands/cluster-info.html</a></p><pre><code>- `cluster_state`: `ok`状态表示集群可以正常接受查询请求。`fail` 状态表示，至少有一个哈希槽没有被绑定（说明有哈希槽没有被绑定到任意一个节点），或者在错误的状态（节点可以提供服务但是带有FAIL 标记），或者该节点无法联系到多数master节点。.- `cluster_slots_assigned`: 已分配到集群节点的哈希槽数量（不是没有被绑定的数量）。16384个哈希槽全部被分配到集群节点是集群正常运行的必要条件.- `cluster_slots_ok`: 哈希槽状态不是`FAIL` 和 `PFAIL` 的数量.- `cluster_slots_pfail`: 哈希槽状态是 `PFAIL`的数量。只要哈希槽状态没有被升级到`FAIL`状态，这些哈希槽仍然可以被正常处理。`PFAIL`状态表示我们当前不能和节点进行交互，但这种状态只是临时的错误状态。- `cluster_slots_fail`: 哈希槽状态是`FAIL`的数量。如果值不是0，那么集群节点将无法提供查询服务，除非`cluster-require-full-coverage`被设置为`no` .- `cluster_known_nodes`: 集群中节点数量，包括处于`握手`状态还没有成为集群正式成员的节点.- `cluster_size`: 至少包含一个哈希槽且能够提供服务的master节点数量.- `cluster_current_epoch`: 集群本地`Current Epoch`变量的值。这个值在节点故障转移过程时有用，它总是递增和唯一的。- `cluster_my_epoch`: 当前正在使用的节点的`Config Epoch`值. 这个是关联在本节点的版本值.- `cluster_stats_messages_sent`: 通过node-to-node二进制总线发送的消息数量.- `cluster_stats_messages_received`: 通过node-to-node二进制总线接收的消息数量.</code></pre><h6 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h6><p>尝试进行数据操作，我这里进入8010端口执行，可以看到我虽然用8010端口发送命令，但是redis客户端给我转到了另一个服务器的8030服务器上，这是因为”zhangsan” 这个key的槽位solt，对应的是8030的这个服务器，下面原理分析有写关于槽位solt。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>一个key，zhangsan，</span></span><br><span class="line">10.211.55.6:8010&gt; set zhangsan 666666</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [12767] located at 10.211.55.8:8030</span></span><br><span class="line">OK</span><br><span class="line">10.211.55.8:8030&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在集群环境下，也就会意味着一些批量处理的命令将会无法使用。假设我这里设置三个key，可以看到执行失败了，这是因为它们三个的ket所计算出的solt不在一个master上，如果它们的solt都在一台master上，那么这条命令还是可以执行的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.211.55.8:8030&gt; mset zhangsan 666666 lisi 666666 wangwu 666666</span><br><span class="line">(error) CROSSSLOT Keys in request don&#x27;t hash to the same slot</span><br><span class="line">10.211.55.8:8030&gt; </span><br></pre></td></tr></table></figure><p>在集群环境下，如果要使用批量处理的命令，可以包装一个大括号，如下.</p><p>当使用了大括号包装后，那么redis只会用大括号包装的那一部分来计算solt，而大括号之外的则不会参与solt计算，所以它们最终会落到一个master节点上。</p><p>但是可能产生数据倾斜的问题，假设{user}:* 数据非常多的话，那么就会大量的数据存在某一个master节点上，还有就是hash数据结构，在集群环境下，某一个key的hash结构数据过大，也会出现数据倾斜。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10.211.55.8:8030&gt; mset &#123;user&#125;:zhangsan 666666 &#123;user&#125;:lisi 666666 &#123;user&#125;:wangwu 666666</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [5474] located at 10.211.55.7:8020</span></span><br><span class="line">OK</span><br><span class="line">10.211.55.7:8020&gt; </span><br><span class="line">10.211.55.7:8020&gt; mget &#123;user&#125;:zhangsan &#123;user&#125;:lisi &#123;user&#125;:wangwu </span><br><span class="line">1) &quot;666666&quot;</span><br><span class="line">2) &quot;666666&quot;</span><br><span class="line">3) &quot;666666&quot;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot-集成Redis群"><a href="#SpringBoot-集成Redis群" class="headerlink" title="SpringBoot 集成Redis群"></a>SpringBoot 集成Redis群</h2><h6 id="引入相关依赖"><a href="#引入相关依赖" class="headerlink" title="引入相关依赖"></a>引入相关依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="SpringBoot项目核心配置"><a href="#SpringBoot项目核心配置" class="headerlink" title="SpringBoot项目核心配置"></a>SpringBoot项目核心配置</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="comment"># 这里放集群节点，建议放入所有节点信息，包括slave节点，它会在你给的节点列表任意一个节点获取所有的master节点信息</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.6</span><span class="string">:8010</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">50</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">10</span></span><br><span class="line">    <span class="comment"># 访问redis密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">666666</span></span><br></pre></td></tr></table></figure><h6 id="访问接口代码"><a href="#访问接口代码" class="headerlink" title="访问接口代码"></a>访问接口代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//死循环不停的写入数据到redis</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;whileWriteData&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">whileWriteData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           stringRedisTemplate.opsForValue().set(<span class="string">&quot;zhangsan:&quot;</span> + i, String.valueOf(i));</span><br><span class="line">           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="数据验证-1"><a href="#数据验证-1" class="headerlink" title="数据验证"></a>数据验证</h6><p>进入查看redis数据，可以看到数据被分散到多个节点上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入8010查看</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.6 -p 8010</span><br><span class="line">10.211.55.6:8010&gt; keys *</span><br><span class="line">1) &quot;zhangsan:14&quot;</span><br><span class="line">2) &quot;zhangsan:11&quot;</span><br><span class="line">3) &quot;zhangsan:10&quot;</span><br><span class="line">4) &quot;zhangsan:0&quot;</span><br><span class="line">5) &quot;zhangsan:4&quot;</span><br><span class="line">6) &quot;zhangsan:8&quot;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入8020查看，忽略之前<span class="built_in">set</span>的部分数据，&#123;user&#125;:*</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.7 -p 8020</span><br><span class="line">10.211.55.7:8020&gt; keys *</span><br><span class="line"> 1) &quot;zhangsan:2&quot;</span><br><span class="line"> 2) &quot;zhangsan:5&quot;</span><br><span class="line"> 3) &quot;&#123;user&#125;:zhangsan&quot;</span><br><span class="line"> 4) &quot;zhangsan:1&quot;</span><br><span class="line"> 5) &quot;&#123;user&#125;wangwu&quot;</span><br><span class="line"> 6) &quot;zhangsan:6&quot;</span><br><span class="line"> 7) &quot;&#123;user&#125;:wangwu&quot;</span><br><span class="line"> 8) &quot;zhangsan:9&quot;</span><br><span class="line"> 9) &quot;zhangsan:13&quot;</span><br><span class="line">10) &quot;&#123;user&#125;:lisi&quot;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入8030查看</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.8 -p 8030</span><br><span class="line">10.211.55.8:8030&gt; keys *</span><br><span class="line">1) &quot;zhangsan:3&quot;</span><br><span class="line">2) &quot;zhangsan:12&quot;</span><br><span class="line">3) &quot;zhangsan:7&quot;</span><br><span class="line">4) &quot;zhangsan&quot;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="Redis-水平扩容"><a href="#Redis-水平扩容" class="headerlink" title="Redis 水平扩容"></a>Redis 水平扩容</h2><h6 id="查看当前集群节点状态"><a href="#查看当前集群节点状态" class="headerlink" title="查看当前集群节点状态"></a>查看当前集群节点状态</h6><p>进入节点执行cluster nodes 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.211.55.6:8010&gt; cluster nodes</span><br></pre></td></tr></table></figure><p><img src="https://oss.pencilso.cn/enclosure/redis-cluster-nodes-slots-2_1592663611846.png" alt="redis-cluster-nodes-slots-2"></p><p>从上图可以看到，整个集群运行正常，三个master节点和三个slave节点。</p><ul><li>8010端口存储槽位：0-5460</li><li>8020端口存储槽位：5461-10922</li><li>8030端口存储槽位：10923-16383</li></ul><p>稍后我们进行水平扩容、水平缩容，都会对槽位进行重新分配，可多加留意。</p><h6 id="启动新的节点"><a href="#启动新的节点" class="headerlink" title="启动新的节点"></a>启动新的节点</h6><p>我这里在 10.211.55.6 服务器上新增两个节点，一个主，一个从。</p><ul><li>主master端口：8110</li><li>从slave端口    ：8120</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建两个文件夹，以端口命名</span></span><br><span class="line">mkdir /root/redis-cluster/8110 /root/redis-cluster/8120</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我这里直接从8010文件夹下复制文件到新的两个文件夹下，然后再用vim的%s命令替换端口，可自行查一下vim替换命令</span></span><br><span class="line">cp /root/redis-cluster/8010/redis.conf /root/redis-cluster/8110/redis.conf</span><br><span class="line">cp /root/redis-cluster/8010/redis.conf /root/redis-cluster/8120/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动两个服务</span></span><br><span class="line">/root/redis/src/redis-server /root/redis-cluster/8110/redis.conf</span><br><span class="line">/root/redis/src/redis-server /root/redis-cluster/8120/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看进程运行状态</span></span><br><span class="line">[root@localhost ~]# ps -ef | grep redis</span><br><span class="line">root      4533     1  0 22:18 ?        00:00:04 /root/redis/src/redis-server *:8010 [cluster]</span><br><span class="line">root      4554     1  0 22:18 ?        00:00:05 /root/redis/src/redis-server *:8011 [cluster]</span><br><span class="line">root      4858     1  0 22:19 ?        00:00:04 /root/redis/src/redis-server *:8012 [cluster]</span><br><span class="line">root      9719     1  0 22:43 ?        00:00:00 /root/redis/src/redis-server *:8110 [cluster]</span><br><span class="line">root      9737     1  0 22:43 ?        00:00:00 /root/redis/src/redis-server *:8120 [cluster]</span><br></pre></td></tr></table></figure><p>需要注意的是这个时候，8110、8120进程只是启动完毕，但是并没有加入整个集群。</p><h6 id="加入节点到集群"><a href="#加入节点到集群" class="headerlink" title="加入节点到集群"></a>加入节点到集群</h6><p>配置8110节点为master，并加入集群，Redis集群会把新加入的节点默认设为master主节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 newnode:port表示的是要加入的新节点  oldnode:port表示的是已经在集群的节点</span></span><br><span class="line">redis-cli -a password --cluster add-node newnode:port oldnode:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 --cluster add-node 10.211.55.6:8110 10.211.55.7:8020</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新查看集群状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入节点</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.6 -p 8110</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群状态</span></span><br><span class="line">10.211.55.6:8110&gt; cluster nodes</span><br></pre></td></tr></table></figure><p> 从下图可以看到，8110端口已经添加到集群中，并且它是一个master节点，但是这个master它并没有任何solt槽位，也就意味着，这个master其实现在还是没用的阶段，我们需要为新的master节点手动分配solt槽位。<img src="https://oss.pencilso.cn/enclosure/redis-cluster-new-node_1592664932085.png" alt="redis-cluster-new-node"></p><h6 id="为新的master分配槽位"><a href="#为新的master分配槽位" class="headerlink" title="为新的master分配槽位"></a>为新的master分配槽位</h6><p>使用redis-cli命令为8110分配solt槽位，找到集群中的任意一个主节点，对其进行重新分片工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/root/redis/src/redis-cli -a 666666 --cluster reshard 10.211.55.7:8020</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下：</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要多少个solt槽位移动到指定节点上，直接设置，比如1000个solt槽位</span></span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 1000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接收这1000个槽位的redis节点id，我们填写8110端口的节点id</span></span><br><span class="line">What is the receiving node ID? 0281fcbafef94b783ebf194f1b8c03440ed3af00</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入all，则表示从所有主节点中分别抽取响应的solt到指定的节点中，抽取的总solt数量为1000</span></span><br><span class="line">Source node #1: all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入yes确认开始执行分片任务</span></span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次查看集群的最新状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入节点</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.6 -p 8110</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群状态</span></span><br><span class="line">10.211.55.6:8110&gt; cluster nodes</span><br></pre></td></tr></table></figure><p>如下图所示，8110端口已经分配了solt，到目前为止，8110已经可以写入数据了。</p><ul><li>槽位1：0-332</li><li> 槽位2：5461-5794</li><li>槽位3：10923-11255<img src="https://oss.pencilso.cn/enclosure/redis-cluster-newnode-revicesolt_1592665636808.png" alt="redis-cluster-newnode-revicesolt"></li></ul><h6 id="为新的master分配slave节点"><a href="#为新的master分配slave节点" class="headerlink" title="为新的master分配slave节点"></a>为新的master分配slave节点</h6><p>接下来为8110分配一个slave节点，也就是刚刚启动的8120端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 newnode:port表示的是要加入的新节点  oldnode:port表示的是已经在集群的节点</span></span><br><span class="line">redis-cli -a password --cluster add-node newnode:port oldnode:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例 ，和添加8110端口的方法一样，但是添加进入后，因为是默认设置为master，所以后续要手动改为slave节点</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 --cluster add-node 10.211.55.6:8120 10.211.55.7:8020</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用redis-cli 命令进入这个8120节点</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.6 -p 8120</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用命令设置为某一个master的slave节点 : cluster replicate masterid</span></span><br><span class="line">10.211.55.6:8120&gt; cluster replicate 0281fcbafef94b783ebf194f1b8c03440ed3af00</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>再次查看集群状态，可以看到8120已经设置为8110的slave节点，水平扩容到此完毕。</p><p><img src="https://oss.pencilso.cn/enclosure/redis-cluster-newslave_1592666433331.png" alt="redis-cluster-newslave"></p><h2 id="Redis-水平缩容"><a href="#Redis-水平缩容" class="headerlink" title="Redis 水平缩容"></a>Redis 水平缩容</h2><h6 id="移除slave节点"><a href="#移除slave节点" class="headerlink" title="移除slave节点"></a>移除slave节点</h6><p>水平缩容无非就是把指定的主从移除集群，准备移除刚刚添加并且分配了solt的8110主节点，8120从节点。</p><p>删除从节点，8120端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/root/redis/src/redis-cli -a 666666 --cluster del-node 10.211.55.6:8120 93230cc3e90e371e7a3950e4ebfd3146402122c3</span><br><span class="line"></span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Removing node 93230cc3e90e371e7a3950e4ebfd3146402122c3 from cluster 10.211.55.6:8120</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER RESET SOFT to the deleted node.</span></span><br></pre></td></tr></table></figure><p>查看集群状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入任意一个节点</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.6 -p 8010</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看节点信息，可以看到8120端口节点已经不在了</span></span><br><span class="line">10.211.55.6:8010&gt; cluster nodes</span><br><span class="line">529aacc697943d76146858ff08b29fc255bc0fc6 10.211.55.6:8010@18010 myself,master - 0 1592666806000 1 connected 333-5460</span><br><span class="line">0281fcbafef94b783ebf194f1b8c03440ed3af00 10.211.55.6:8110@18110 master - 0 1592666805101 10 connected 0-332 5461-5794 10923-11255</span><br><span class="line">b93be2ad14af5724ad016c20be87981324770f36 10.211.55.7:8020@18020 master - 0 1592666806000 4 connected 5795-10922</span><br><span class="line">040ba74db58cd2912b5b9f6445ddfc90de31d230 10.211.55.8:8031@18031 slave 0281fcbafef94b783ebf194f1b8c03440ed3af00 0 1592666806509 10 connected</span><br><span class="line">1b57c2aa088f84e68711e92eb715b395d55dadb1 10.211.55.6:8011@18011 slave 23c3a630c3173af822e20338e33b49ce5ef38207 0 1592666805000 7 connected</span><br><span class="line">23c3a630c3173af822e20338e33b49ce5ef38207 10.211.55.8:8030@18030 master - 0 1592666806609 7 connected 11256-16383</span><br><span class="line">8428e0da601f849d96edb63dc6571642eb6874fd 10.211.55.6:8012@18012 slave b93be2ad14af5724ad016c20be87981324770f36 0 1592666805503 4 connected</span><br><span class="line">3900369ca0098df78972291d638cf3f88ed6c554 10.211.55.7:8022@18022 slave 23c3a630c3173af822e20338e33b49ce5ef38207 0 1592666806509 7 connected</span><br><span class="line">3e2108060ecdcdc4a220ab14c8f04202932be2f1 10.211.55.8:8032@18032 slave b93be2ad14af5724ad016c20be87981324770f36 0 1592666805000 9 connected</span><br><span class="line">4e9195825d14d2ec74b593e158c9c229cc682d8c 10.211.55.7:8021@18021 slave 529aacc697943d76146858ff08b29fc255bc0fc6 0 1592666806000 5 connected</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看redis进程</span></span><br><span class="line">[root@localhost ~]# ps -ef | grep redis</span><br><span class="line">root      4533     1  0 22:18 ?        00:00:11 /root/redis/src/redis-server *:8010 [cluster]</span><br><span class="line">root      4554     1  0 22:18 ?        00:00:12 /root/redis/src/redis-server *:8011 [cluster]</span><br><span class="line">root      4858     1  0 22:19 ?        00:00:12 /root/redis/src/redis-server *:8012 [cluster]</span><br><span class="line">root      9719     1  0 22:43 ?        00:00:07 /root/redis/src/redis-server *:8110 [cluster]</span><br><span class="line">root      9737     1  0 22:43 ?        00:00:04 /root/redis/src/redis-server *:8120 [cluster]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动<span class="built_in">kill</span>掉8120</span></span><br><span class="line">kill 9737</span><br></pre></td></tr></table></figure><h6 id="重新分配solt槽位"><a href="#重新分配solt槽位" class="headerlink" title="重新分配solt槽位"></a>重新分配solt槽位</h6><p>删除主节点，8110端口</p><p>删除主节点需要先把solt槽位分配给其他节点，一开始在把新节点加进来时，手动为其分配了1000个solt槽位，现在要移除这个master，那么就需要把这1000个槽位分配到其他任意一个节点上，目前还做不了平均分配功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 调用重新分配命令，后面ip:port 指定任意一个master节点</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 --cluster reshard 10.211.55.6:8010</span><br><span class="line"><span class="meta">#</span><span class="bash">输出如下</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash">要移动多少槽位: 1000</span></span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 1000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接收槽位的master节点id，我这里写8010的id</span> </span><br><span class="line">What is the receiving node ID? 529aacc697943d76146858ff08b29fc255bc0fc6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从哪个节点id抽取，这里填写8110的节点id</span></span><br><span class="line">Source node #1: 0281fcbafef94b783ebf194f1b8c03440ed3af00</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后输入<span class="keyword">done</span> 准备迁移计划</span></span><br><span class="line">Source node #2: done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入yes开始迁移</span></span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure><p>查看当前集群情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入任意节点</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 -c -h 10.211.55.6 -p 8010</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看节点信息</span></span><br><span class="line">10.211.55.6:8010&gt; cluster nodes</span><br></pre></td></tr></table></figure><p>如下图所示，我们的8110主节点，已经没有任何的solt槽位了，这时候已经迁移成功了。 <img src="https://oss.pencilso.cn/enclosure/redis-cluster-node-remove_1592667748420.png" alt="redis-cluster-node-remove"></p><h6 id="移除master节点"><a href="#移除master节点" class="headerlink" title="移除master节点"></a>移除master节点</h6><p>接下来就是大胆的删除这个节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行删除命令</span></span><br><span class="line">/root/redis/src/redis-cli -a 666666 --cluster del-node 10.211.55.6:8110 0281fcbafef94b783ebf194f1b8c03440ed3af00</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Removing node 0281fcbafef94b783ebf194f1b8c03440ed3af00 from cluster 10.211.55.6:8110</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER RESET SOFT to the deleted node.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群信息，已经没有8110这个节点了，水平缩容也到此结束，别忘了最后<span class="built_in">kill</span>掉8110的进程</span></span><br><span class="line">10.211.55.6:8010&gt; cluster nodes</span><br><span class="line">529aacc697943d76146858ff08b29fc255bc0fc6 10.211.55.6:8010@18010 myself,master - 0 1592667896000 11 connected 0-5794 10923-11255</span><br><span class="line">b93be2ad14af5724ad016c20be87981324770f36 10.211.55.7:8020@18020 master - 0 1592667896000 4 connected 5795-10922</span><br><span class="line">040ba74db58cd2912b5b9f6445ddfc90de31d230 10.211.55.8:8031@18031 slave 529aacc697943d76146858ff08b29fc255bc0fc6 0 1592667897744 11 connected</span><br><span class="line">1b57c2aa088f84e68711e92eb715b395d55dadb1 10.211.55.6:8011@18011 slave 23c3a630c3173af822e20338e33b49ce5ef38207 0 1592667897000 7 connected</span><br><span class="line">23c3a630c3173af822e20338e33b49ce5ef38207 10.211.55.8:8030@18030 master - 0 1592667897000 7 connected 11256-16383</span><br><span class="line">8428e0da601f849d96edb63dc6571642eb6874fd 10.211.55.6:8012@18012 slave b93be2ad14af5724ad016c20be87981324770f36 0 1592667896000 4 connected</span><br><span class="line">3900369ca0098df78972291d638cf3f88ed6c554 10.211.55.7:8022@18022 slave 23c3a630c3173af822e20338e33b49ce5ef38207 0 1592667898044 7 connected</span><br><span class="line">3e2108060ecdcdc4a220ab14c8f04202932be2f1 10.211.55.8:8032@18032 slave b93be2ad14af5724ad016c20be87981324770f36 0 1592667897542 9 connected</span><br><span class="line">4e9195825d14d2ec74b593e158c9c229cc682d8c 10.211.55.7:8021@18021 slave 529aacc697943d76146858ff08b29fc255bc0fc6 0 1592667897039 11 connected</span><br></pre></td></tr></table></figure><h2 id="Redis-集群原理分析"><a href="#Redis-集群原理分析" class="headerlink" title="Redis 集群原理分析"></a>Redis 集群原理分析</h2><h6 id="Redis的slots槽位，分片"><a href="#Redis的slots槽位，分片" class="headerlink" title="Redis的slots槽位，分片"></a>Redis的slots槽位，分片</h6><p>在redis集群中，它会给每一个master分配一定的槽位，在创建集群时第一次分配，具体为0-16383。比如我现在是三个master，那么就会把16383分配给我的三个master，每个节点负责一部分槽位，槽位的信息会存储于每个节点中。</p><p>redis客户端在连接上集群后，会获得所有master信息，包含它的solt槽位信息并且缓存在本地，当客户端要执行某个命令时，会对key进行solt运算，这样就可以立即定位到目标节点。</p><p>假设现在有一个命令 “set zhangsan 666 “ ,那么redis客户端会对这个 “zhangsan” 这个key进行crc16运算得到一个数，再然后用这个数 对 16384进行取模运算，最后得到的solt必然是 16384 以内的数字。</p><p>客户端在获得这个solt后，就会把命令发送到这个solt所对应的redis服务，假设 “zhangsan”这个key的solt为10999，那么redis客户端会把命令发送到图下的最右边的master节点中。</p><p> 我这里简单的画了一个图<img src="https://oss.pencilso.cn/enclosure/redis-cluster-solts_1592579824242.png" alt="redis-cluster-solts"></p><h6 id="跳转重定位"><a href="#跳转重定位" class="headerlink" title="跳转重定位"></a>跳转重定位</h6><p>当redis集群出现水平扩容，或者水平缩容等情况，那么redis各个服务之间的sol会有所变动。</p><p>如果这时候客户端计算key的solt后，用它已有的缓存去定位solt所对应的节点，有可能这个节点已经不对应这个solt了，当客户端向这个错误的节点发出了指令，该节点会发现指令的key所在的槽位不归属于自己管理，这时候节点会反馈给客户端一个特殊的跳转指令，并携带目标操作的节点地址，客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位缓存，后续所有的key将会使用新的槽位缓存。</p><h6 id="Redis-集群节点间的通信机制"><a href="#Redis-集群节点间的通信机制" class="headerlink" title="Redis 集群节点间的通信机制"></a>Redis 集群节点间的通信机制</h6><p>redis cluster 节点间采取gossip协议进行通信，各个节点之间会保持连接。</p><p>集中式维护集群元数据</p><p>​       有点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以感知到；不足自安于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。</p><p>gossip维护集群元数据</p><p>​       gossip协议包含多种消息，包括ping，pong，meet，fail等等。</p><pre><code>    - ping : 每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据    - pong：返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新;    - fail：某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了;    - meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信，不需要发送形成网络所需的所有cluster meet命令，发送cluster meet消息以便每个节点能够达到其他每个节点只需通过一条已知的节点链就够了，由于在心跳包中会交换gossip信息，将会创建节点间确实的链接。</code></pre><p>gossip协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。</p><p>每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，每个节点每隔一段时间都会往另外几个节点发送ping消息，同时其他介个节点收到ping消息滞后会返回pong消息。</p><h6 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a>网络抖动</h6><p>真实环境中，机房网络往往会出现各种小问题，比如常见的网络抖动，可能突然造成部分连接的不可访问，然后很快又恢复正常。</p><p>为解决这种问题，Redis Clister 提供了一个参数 cluster-node-timeout配置，标识当某个节点持续timeout的时间失联时，才可以认定该节点出现故障，需要进行主从切换，如果没有这个配置，网络抖动会导致主从频繁切换（数据的重新复制）。</p><h6 id="Redis集群选举原理"><a href="#Redis集群选举原理" class="headerlink" title="Redis集群选举原理"></a>Redis集群选举原理</h6><p>当slave发现自己的master节点不可用时，便尝试发送消息到其他节点，告知master节点已不可用，请求升级为新的master节点，由于挂掉的master可能会有多个slave，那就存在多个slave节点竞争成为master节点的可能。</p><ol><li>slave发现自己的master不可用，变为了fail</li><li>将自己记录的集群currentEpoch加1，并且广播FAILOVER_AUTH_REQUEST 信息</li><li>其他节点收到信息，只有master响应，先判断请求者的合法性，再发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li><li>尝试请求升级为master的slave节点，会收集其他master节点反馈的FAILOVER_AUTH_ACK</li><li>slave收到超过半数的master的ack后就会变成新的master（如果只有两个master主节点，当其中一个挂了，只剩一个主节点，那么是不能选举成功的，所以集群至少应该要有三个主节点）</li><li>广播pong消息通知其他集群节点</li></ol><p>从节点并不是在主节点一进入FAIL状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其他master或许尚未意识到FAIL状态，可能会拒绝投票</p><ul><li>延迟计算公式：<ul><li>DELAY = 500ms + random（0-500ms） + SLAVE_RANK * 1000ms<ul><li>SLAVE_RANK 所表示的是此slave已经从master复制数据的总量的Rank，Rank越小代表已复制的数据越新，这种方式下，持有最新数据的slave将会首先发起选举（理论上），这样可以极大程度的避免多个slave竞争。如果多个slave竞争选举，并且所获得的master投票一致，那么将会重新发起选举。</li></ul></li></ul></li></ul><h6 id="集群是否完整才对外提供服务"><a href="#集群是否完整才对外提供服务" class="headerlink" title="集群是否完整才对外提供服务"></a>集群是否完整才对外提供服务</h6><p>当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线并且没有对应的从库进行故障恢复时，集群的其他master节点仍然可用，如果为yes则集群不可用。</p><h6 id="集群为什么至少需要三个master节点"><a href="#集群为什么至少需要三个master节点" class="headerlink" title="集群为什么至少需要三个master节点"></a>集群为什么至少需要三个master节点</h6><p>因为新master的选举需要大于半数的集群master节点同意才能选举成功，假设只有两个master节点，当其中一个挂了的情况下，slave获得的投票是达不到升级为master的条件的。</p><p>奇数个master节点可以在满足选举选举条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点，大家都能选举出新的master节点，如果都挂了两个master节点，那么都没法选举新master节点，因为slave获取不到半数的投票，所以master节点部署为奇数的个数更多的是从节省机器资源角度来考虑，当然如果奇数不能满足性能要求，偶数刚好合适，那么部署偶数也可以。</p><h6 id="哨兵leader-选举流程"><a href="#哨兵leader-选举流程" class="headerlink" title="哨兵leader 选举流程"></a>哨兵leader 选举流程</h6><p>当一个master服务被某个sentinel认为下线状态，不可用状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。每个发现master服务不可用的sentinel都可以要求其他sentinel选自己为sentinel的leader，选举是先到先得。</p><p>同时每个sentinel每次选举都会自增配置纪元（选举周期），每个纪元中只会选择一个sentinel的leader。</p><p>如果所有超过一半的sentinel选举某个sentinel作为leader，之后由该sentinel进行故障转移操作，从存活的slave节点中选举出新的master，这个选举过程跟集群的master选举类似。</p><p>即使哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新的master。</p><p>一般为了高可用推荐至少部署三个哨兵节点，为什么推荐奇数为个数部署哨兵节点，原理与集群奇数个master节点类似。</p>]]></content>
    
    
    <summary type="html">Redis 缓存高可用集群、水平扩容、水平缩容</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
    <category term="cluster" scheme="https://songlongkuan.com/tags/cluster/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从架构、哨兵架构</title>
    <link href="https://songlongkuan.com/2020/06/11/redis_master_slate_sentiel/"/>
    <id>https://songlongkuan.com/2020/06/11/redis_master_slate_sentiel/</id>
    <published>2020-06-11T08:53:00.000Z</published>
    <updated>2021-01-31T12:09:45.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一点需要注意，在不关闭防火墙的情况下，可能导致slave节点同步主节点数据失败。</p></blockquote><a id="more"></a><h2 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h2><h6 id="搭建Redis主从"><a href="#搭建Redis主从" class="headerlink" title="搭建Redis主从"></a>搭建Redis主从</h6><p>先启动一个6379端口的redis，作为主节点，master。</p><p>复制一份新的redis.conf文件进行修改，作为slave节点的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改端口</span></span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改pid文件路径</span></span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改redis数据存放目录</span></span><br><span class="line">dir /root/redis/data/6380/dir</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定主节点，从主节点同步数据</span></span><br><span class="line">replicaof 192.168.2.166 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置slave节点为只读</span></span><br><span class="line">replica‐read‐only yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动slave节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server data/6380/redis.conf</span><br></pre></td></tr></table></figure><p>查看进程，这时候已经能看到两个进程了，一个6379，一个6380 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# ps -ef | grep redis</span><br><span class="line">root      8966     1  0 10:14 ?        00:00:00 src/redis-server 127.0.0.1:6379</span><br><span class="line">root      9020     1  0 10:15 ?        00:00:00 src/redis-server 127.0.0.1:6380</span><br><span class="line">root      9053  3698  0 10:15 pts/0    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><p>进入6379主节点写入数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set zhangsan 2020</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p>进入slave从节点执行get命令，可以看到已经同步了主节点 master的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; get zhangsan</span><br><span class="line">&quot;2020&quot;</span><br><span class="line">127.0.0.1:6380&gt; </span><br></pre></td></tr></table></figure><p>但是slave节点我们在配置文件里设置的是只读，不允许写，尝试一下写入命令。可以看到控制台输出错误信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; set zhangsan 1</span><br><span class="line">(error) READONLY You can&#x27;t write against a read only replica.</span><br><span class="line">127.0.0.1:6380&gt; </span><br></pre></td></tr></table></figure><h6 id="使用Docker-搭建主从架构"><a href="#使用Docker-搭建主从架构" class="headerlink" title="使用Docker 搭建主从架构"></a>使用Docker 搭建主从架构</h6><p>先使用docker 拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# docker pull redis:6</span><br><span class="line">6: Pulling from library/redis</span><br><span class="line">8559a31e96f4: Pull complete </span><br><span class="line">85a6a5c53ff0: Pull complete </span><br><span class="line">b69876b7abed: Pull complete </span><br><span class="line">a72d84b9df6a: Pull complete </span><br><span class="line">5ce7b314b19c: Pull complete </span><br><span class="line">04c4bfb0b023: Pull complete </span><br><span class="line">Digest: sha256:800f2587bf3376cb01e6307afe599ddce9439deafbd4fb8562829da96085c9c5</span><br><span class="line">Status: Downloaded newer image for redis:6</span><br><span class="line">docker.io/library/redis:6</span><br></pre></td></tr></table></figure><p>创建多个文件夹，我这里以端口为命名，文件夹下有dir文件夹（作为redis工作目录），并且复制一个未修改的redis.conf 配置文件。</p><p>需要注意的是，需要对文件夹的权限修改为757。不然后续redis会没有写入权限 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-data]# mkdir 6379/dir</span><br><span class="line">[root@localhost redis-data]# cp /root/redis/redis.conf 6379/redis.conf</span><br><span class="line">[root@localhost redis-data]# chmod -R 757 6379</span><br><span class="line">[root@localhost redis-data]# ls 6379</span><br><span class="line">dir  redis.conf</span><br></pre></td></tr></table></figure><p>修改redis.conf中的工作目录  其他的aof  rdb持久化等配置，根据自己需要，自行修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止使用后台守护进程</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置redis的工作目录</span></span><br><span class="line">dir /redis-data/dir</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置绑定地址</span></span><br><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure><p>运行主节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动主节点 master</span>  </span><br><span class="line">docker run -d --name redis-master -p 6379:6379 -v /root/redis-data/6379:/redis-data redis:6 redis-server /redis-data/redis.conf</span><br></pre></td></tr></table></figure><p>准备slave从节点，将master主节点的文件夹 ”6379“ 复制出一份，到 ”6380“  。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-data]# cp -r 6379 6380</span><br><span class="line">[root@localhost redis-data]# chmod -R 757 6380</span><br><span class="line">[root@localhost redis-data]# ls</span><br><span class="line">6379  6380</span><br></pre></td></tr></table></figure><p>修改6380下的redis.conf配置文件，添加主节点的ip地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定主节点，从主节点同步数据</span></span><br><span class="line">replicaof 192.168.2.116 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置slave节点为只读</span></span><br><span class="line">replica‐read‐only yes</span><br></pre></td></tr></table></figure><p>启动slave 从节点命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动从节点 slave-6380</span>  </span><br><span class="line">docker run -d --name redis-slave-6380 -p 6380:6379 -v /root/redis-data/6380:/redis-data redis:6 redis-server /redis-data/redis.conf</span><br></pre></td></tr></table></figure><p>测试主从是否生效，先进入主节点端口，执行set指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set zhangsan 2020</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p>现在进入slave从节点，查看数据，已经同步到slave从节点上了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# src/redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; get zhangsan</span><br><span class="line">&quot;2020&quot;</span><br><span class="line">127.0.0.1:6380&gt; </span><br></pre></td></tr></table></figure><h6 id="主从架构数据复制原理"><a href="#主从架构数据复制原理" class="headerlink" title="主从架构数据复制原理"></a>主从架构数据复制原理</h6><p>Slave 节点在第一次启动时，会发送psync指令到主节点同步全量数据，主节点在获取到psync指令后，会将master主节点最新的内存数据，生成一次RDB数据快照（如果同时收到多次同步全量数据的指令，只会生成一次数据快照），并且发送到slave节点，slave节点接收到RDB数据后，加载到内存当中，然后master主节点会将生成RDB文件后的缓存在内存中的命令，发送给slave节点。</p><p>当slave节点与master节点完成同步之后，master会通过长连接的方式，持续将新的写命令，发送给slave节点。</p><p>master 主节点在执行写的命令时，会将命令存放到缓存区，每条命令都会有一个offset偏移值，缓存区大小约为1M，会滚动删除，并且master和它所有的slave节点都会持有每条命令的offset 偏移值和master 进程id。</p><p>如果因为网络波动等原因导致slave 与 master连接中断，这时候slave节点会进行重连，如果master 进程id出现了变化，则会发送全量同步的指令，否则会执行增量同步，发送psync( offset )指令，将slave节点最新的一条数据的偏移量（offset）通过psync指令发送给master。master在接到这条psync（offset）指令后，会去master的缓存区域查找这条offset，如果找到了的话，会将这个指令之后的数据一次性同步给slave节点，倘若没有找到的话，说明这个offset 已经过旧了，则会出发一次全量同步。</p><h2 id="哨兵架构"><a href="#哨兵架构" class="headerlink" title="哨兵架构"></a>哨兵架构</h2><p>sentinel哨兵是特殊的redis服务，它主要是用来监控redis的实例节点。</p><p>在哨兵的架构下，client端会在第一次获取redis实例，从sentinel找出主节点master，后续就会一直访问该主节点。</p><p>如果主节点master宕机了的情况下，sentinel会第一时间感知到，并对slave节点进行选举，选出一个新的master节点。如果redis的client端实现了订阅功能，那么这时候client可以订阅sentinel发布的节点变动消息。</p><h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><p>先运行一个master主节点，其次再运行两个slave节点，其实就是先把主从跑起来。</p><p>这里的话我就不采用docker运行了，修改配置文件，参考上面写的搭建Redis主从slave配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行主节点  master</span></span><br><span class="line">[root@myredis redis]# src/redis-server /root/redis-data/6379/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行slave节点  6380</span></span><br><span class="line">[root@myredis redis]# src/redis-server /root/redis-data/6380/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行slave节点  6381</span></span><br><span class="line">[root@myredis redis]# src/redis-server /root/redis-data/6381/redis.conf</span><br></pre></td></tr></table></figure><p>查看进程是否运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@myredis redis]# ps -ef | grep redis</span><br><span class="line">root      7746     1  0 17:14 ?        00:00:01 src/redis-server 0.0.0.0:6379</span><br><span class="line">root      7767     1  0 17:14 ?        00:00:01 src/redis-server 0.0.0.0:6380</span><br><span class="line">root      7783     1  0 17:14 ?        00:00:01 src/redis-server 0.0.0.0:6381</span><br></pre></td></tr></table></figure><h6 id="搭建哨兵架构"><a href="#搭建哨兵架构" class="headerlink" title="搭建哨兵架构"></a>搭建哨兵架构</h6><p>修改配置文件，要启动多少个哨兵，就修改多少份文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个文件夹 用来存储多个sentinel节点的配置文件</span></span><br><span class="line">mkdir sentinel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制一个sentinel.conf 文件，并以端口为结尾命名</span></span><br><span class="line">cp sentinel.conf sentinel/sentinel-26379.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来修改 配置文件</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行端口</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否开启后台守护进程</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进程id保存路径 结尾以端口号命名，以防多个实例冲突。</span></span><br><span class="line">pidfile /var/run/redis-sentinel-26379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件，同样以端口号命名，以防多个实例冲突。</span></span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改工作目录，同样以端口号结尾命名，工作目录要事先创建好，</span></span><br><span class="line">dir /root/redis-data/sentinel/26379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置主节点的ip地址和端口号，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel monitor &lt;master‐name&gt; &lt;ip&gt; &lt;redis‐port&gt; &lt;quorum&gt;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> quorum是一个数字，指明多少个sentinel认为master失效时，master才算真正失效（一般是sentinel总数/2 + 1）。</span></span><br><span class="line">sentinel monitor mymaster 192.168.2.116 6379 2</span><br></pre></td></tr></table></figure><p>启动sentinel。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据指定的配置文件启动sentinel 哨兵</span></span><br><span class="line">[root@localhost redis]# src/redis-sentinel sentinel/sentinel-26379.conf</span><br><span class="line">[root@localhost redis]# src/redis-sentinel sentinel/sentinel-26380.conf</span><br><span class="line">[root@localhost redis]# src/redis-sentinel sentinel/sentinel-26381.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动后，使用redis客户端进入sentinel</span></span><br><span class="line">[root@localhost redis]# src/redis-cli -p 26379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看sentinel信息，执行info命令</span></span><br><span class="line">127.0.0.1:26379&gt; info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Sentinel</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到 redis master的地址和端口，还有该master所对应的slaves的数量</span></span><br><span class="line">master0:name=mymaster,status=ok,address=192.168.2.116:6379,slaves=2,sentinels=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，哨兵架构已经搭建起来了</p><h2 id="SpringBoot-集成Redis哨兵"><a href="#SpringBoot-集成Redis哨兵" class="headerlink" title="SpringBoot 集成Redis哨兵"></a>SpringBoot 集成Redis哨兵</h2><p>依赖配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> application.yaml 配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment"># 哨兵节点，逗号分隔</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.116</span><span class="string">:26379,192.168.2.116:26380,192.168.2.116:26381</span></span><br><span class="line">      <span class="comment"># 主节点所在名称</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>编写测试接口，测试是否能从哨兵节点获取master节点，并写入数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一直向Redis 循环写入数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;whileWriteData&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">whileWriteData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               stringRedisTemplate.opsForValue().set(<span class="string">&quot;zhangsan:&quot;</span> + i, String.valueOf(i));</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用接口后，可以看到在一直向redis写入数据</p> <img src="https://oss.pencilso.cn/enclosure/WX20200616-174401@2x_1592300679655.png" alt="WX20200616-174401@2x" style="zoom:50%;" /><p>这时候尝试将redis的master节点，也就是 6379的进程kill掉。测试sentinel是否会切换slave为master。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@myredis redis]# ps -ef | grep redis</span><br><span class="line">root      7746     1  0 17:14 ?        00:00:04 src/redis-server 0.0.0.0:6379</span><br><span class="line">root      7767     1  0 17:14 ?        00:00:03 src/redis-server 0.0.0.0:6380</span><br><span class="line">root      7783     1  0 17:14 ?        00:00:03 src/redis-server 0.0.0.0:6381</span><br><span class="line">root      8312     1  0 17:17 ?        00:00:04 src/redis-sentinel *:26379 [sentinel]</span><br><span class="line">root     10878     1  0 17:30 ?        00:00:02 src/redis-sentinel *:26380 [sentinel]</span><br><span class="line">root     10907     1  0 17:30 ?        00:00:02 src/redis-sentinel *:26381 [sentinel]</span><br><span class="line">root     13848  3855  0 17:45 pts/0    00:00:00 grep --color=auto redis</span><br><span class="line"></span><br><span class="line">[root@myredis redis]# kill 7746</span><br></pre></td></tr></table></figure><p>再看SpringBoot运行日志，先是连接超时异常，后又重新尝试重新连接master节点。当sentinel重新选举出新的master后，会获取到新的master节点地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.lettuce.core.RedisCommandTimeoutException: Command timed out after <span class="number">3</span> second(s)</span><br><span class="line">  .....</span><br><span class="line"><span class="comment">//尝试重连master</span></span><br><span class="line">Cannot reconnect to [<span class="number">192.168</span><span class="number">.2</span><span class="number">.116</span>:<span class="number">6379</span>]: Connection refused: /<span class="number">192.168</span><span class="number">.2</span><span class="number">.116</span>:<span class="number">6379</span></span><br><span class="line"><span class="comment">// 连接新的master  </span></span><br><span class="line">Reconnected to <span class="number">192.168</span><span class="number">.2</span><span class="number">.116</span>:<span class="number">6382</span></span><br></pre></td></tr></table></figure><p>当SpringBoot获取到新的节点后，代码会继续往redis插入数据。</p><p>如果旧的master重新启动后，旧的master会变成slave节点。</p>]]></content>
    
    
    <summary type="html">Redis 主从架构、哨兵架构</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
    <category term="master" scheme="https://songlongkuan.com/tags/master/"/>
    
    <category term="slave" scheme="https://songlongkuan.com/tags/slave/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化，RDB、AOF、混合持久化</title>
    <link href="https://songlongkuan.com/2020/06/10/redis_rdb_aof/"/>
    <id>https://songlongkuan.com/2020/06/10/redis_rdb_aof/</id>
    <published>2020-06-10T15:11:00.000Z</published>
    <updated>2021-01-31T12:12:28.961Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 持久化，RDB、AOF、混合持久化</p><a id="more"></a><h2 id="RDB快照（snapshot）"><a href="#RDB快照（snapshot）" class="headerlink" title="RDB快照（snapshot）"></a><strong>RDB快照（snapshot）</strong></h2><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>在默认情况下，Redis会将快照数据放到 “dump.rdb” 的文件中。并且该文件是一个被压缩过的二进制文件。</p><p>而且可以对Redis设置多个生成RDB快照的策略。让Redis在某一个时间段内，修改次数达到设定的阈值，则触发持久化。</p><p>打开redis.conf 配置文件，配置几条规则，这里设置阈值较小，方便测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 存储RDB文件的文件名</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 存储数据目录，RDB 、 AOF 等文件都会存储在这个目录下</span></span><br><span class="line">dir /root/redis/data/6379/dir</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置30秒内 有20个更新操作即生成一个RDB快照</span></span><br><span class="line">save 30 20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置60秒内 有10个更新操作即生成一个RDB快照</span></span><br><span class="line">save 60 10</span><br></pre></td></tr></table></figure><p>尝试手动在30秒内执行20个更新操作，观察dir目录下确实生成了一个 “dump.rdb” 文件，不过因为这是二进制的压缩文件，所以查看时，会是乱码状态。 <img src="https://oss.pencilso.cn/enclosure/QQ20200610-210658@2x_1591794433375.png" alt="QQ20200610-210658@2x"></p><p>除了这种方式以外，还有手动生成快照的命令，可以通过redis的客户端，发送命令到redis，让redis生成数据快照保存下来。</p><p>先把 dump.rdb 文件删除，接着我们直接使用 “src/redis-cli -p 6379 ” 进入redis客户端，执行save命令。</p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-211224@2x_1591794756582.png" alt="QQ20200610-211224@2x"></p><p>这时候再次进入dir 目录下，可以看到新的dump.rdb 文件生成了。</p><p>可以尝试手动将redis的进程kill掉，然后重启，会发现数据被恢复回来了。</p><p>不过需要注意的是，save是一个同步命令，它会在生成快照的这个时间段，阻塞其他的命令。</p><p>bgsave，是redis提供的异步生成快照的命令（bg是background的简写），当redis的单线程解析到 “bg” 这个指令的时候，就会fork一个子进程去执行命令。</p><p>比如bgsave，就会fork出来一个子进程去生成RDB文件快照。</p><p>而且，通过配置文件的策略自动生成RDB快照，是以bgsave的命令生成的。不会阻塞客户端的其他命令。</p><p>如果要关闭RDB持久化方案，将redis.conf 配置文件中的所有save 配置注释掉即可。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>RDB快照方案的持久化，存在较大的可能，数据丢失问题。</p><p>倘若设置的60秒以内1000个更新操作则生成RDB快照，如果在这60秒以内没有达到1000个更新操作的阈值，而Redis宕机了的话，则会丢失这60秒的数据。</p><h2 id="AOF-持久化方案"><a href="#AOF-持久化方案" class="headerlink" title="AOF 持久化方案"></a>AOF 持久化方案</h2><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><p>从Redis的1.1版本开始，增加了一种AOF持久化（ append-only file ），它会将每一条更新命令以RESP协议的方式，追加在文件 “appendonly.aof” 中。</p><p>当Redis重启时，会从aof文件里读取命令，重新执行一遍，以此来恢复数据。</p><p>修改配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是否启用 AOF，  no、yes</span> </span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF保存的文件名，默认 appendonly.aof</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步策略  每秒同步一次</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>同步策略有三种</p><ul><li>appendfsync always 每次有新的命令都会执行一次fsync，追加命令到文件，安全性高，性能低下。</li><li>appendfsync everysec 每秒会执行一次fsync，把新的命令追加到文件里。倘若故障，会丢失一秒的数据。（Redis默认配置）</li><li>appendfsync no  从不fsync到文件 ，将数据交给操作系统来处理。更快，也更不安全的选择。</li></ul><p>测试一下执行多次incr命令后，是否会追加到aof文件里。</p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-221432@2x_1591798485793.png" alt="QQ20200610-221432@2x"></p><p>查看aof文件， 可以看到有6个incr指令都被追加到了appendonly.aof的文件里。<img src="https://oss.pencilso.cn/enclosure/QQ20200610-221914@2x_1591798766759.png" alt="QQ20200610-221914@2x"></p><p>这时候aof的弊端也显现出来了，就是aof的文件必然会非常的大，假设这个zhangsan字段，被incr了一万次，那么就会在aof文件里生成一万条incr指令，</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>aof里面可能会存在大量没用的指令，造成文件过大，数据恢复较慢。</p><p>那么在这种场景下，aof定期重写，可以做到一定的优化，它会定期将当前最新的数据，生成aof文件。</p><p>通过修改redis.conf配置，让redis自动执行aof重写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> aof 文件至少要达到64mb 以后才会执行aof重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure><p>可以通过 “bgrewriteaof” 指令，手动进行aof重写，而且该指令会fork一个新的子进程到后台去处理。</p><p>我们进入redis客户端，手动执行一次“bgrewriteaof”后，查看一下aof文件内容。可以明确的看到多条incr指令变成了一个set zhangsan 6 的指令。</p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-224605@2x_1591800376580.png" alt="QQ20200610-224605@2x"></p><p>redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点。</p><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>Redis重启时，我们很少用RDB来恢复数据，因为RDB可能会丢失过多的数据，通常使用AOF来恢复数据，对命令重新执行。</p><p>但是重新执行AOF，效率对于RDB来说会低很多，有可能导致恢复数据时间过长。</p><p>Redis 为了解决这个问题，引入了混合持久化。</p><p>通过配置redis.conf 可以开启混合持久化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p>开启了混合持久化后，AOF在进行重写的时候，不再是简单的最新的数据存储在apf文件中。</p><p>而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改命令存在一起，并一起存入到新的文件中。</p><p>新的文件一开始不叫“appendonly.aof”，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</p><p>在混合持久化开启下，Redis重启会先加载“appendonly.aof” 文件中的RDB数据，其次再加载“appendonly.aof” RDB后面的 AOF增量命令。</p><p>接下来测试拥有RDB和AOF增量数据的 “appendonly.aof” 文件会是什么样的。</p><p>在打开持久化后，手动执行一次AOF重写，也就是“bgrewriteaof”命令，当我们再次查看aof文件的时候，应该是下面这样的乱码，这些是RDB格式的二进制数据，因为在生成RDB之后，重写AOF之前，没有新的修改命令，所以这里看不到AOF的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REDIS0009�      redis-ver6.0.5�</span><br><span class="line">�edis-bits�@�ctime�T��^used-mem�3</span><br><span class="line"> aof-preamble��zhangsan����dD�C�A</span><br></pre></td></tr></table></figure><p>打开redis客户端，再次执行几次incr命令之后，再次查看aof文件，如下。可以看到，上面的是RDB数据，下面的是AOF增量数据。</p><p><img src="https://oss.pencilso.cn/enclosure/QQ20200610-230841@2x_1591801742677.png" alt="QQ20200610-230841@2x"></p>]]></content>
    
    
    <summary type="html">Redis 持久化，RDB、AOF、混合持久化</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
    <category term="aof" scheme="https://songlongkuan.com/tags/aof/"/>
    
    <category term="rdb" scheme="https://songlongkuan.com/tags/rdb/"/>
    
  </entry>
  
  <entry>
    <title>Redis 渐进式遍历键</title>
    <link href="https://songlongkuan.com/2020/06/10/redis_key_search/"/>
    <id>https://songlongkuan.com/2020/06/10/redis_key_search/</id>
    <published>2020-06-10T09:55:00.000Z</published>
    <updated>2021-01-31T12:10:12.421Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中难免有时候会遇到遍历key的情景，但是redis是单线程处理命令的，如果说我们采用keys * 的指令来进行遍历的话，那么很有可能会造成redis的单线程阻塞，因为这是一个耗时操作。</p><a id="more"></a><p>这个时候可以采用Redis的 scan指令，进行渐进式遍历键，也可以理解为分页遍历。防止数据量过大遍历的时间过长。</p><p>redis指令 : scan cursor match pattern count querycount</p><p>例如 : scan 0 match user* count 1000</p><p>指令中, cursor 指的是游标第一次为0，pattern指的是key的匹配正则，querycount指的是，要遍历的数量（ 注意不是匹配的数据数量 )</p><p>我们先模拟10万个用户 ，插入到Redis缓存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;generateUserCache&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateUserCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:&quot;</span> + num, String.valueOf(num));</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用scan 命令渐进式遍历键，返回的第一个数值，即下一次执行scan命令时用到的游标。</p><p>当游标为0时，则表明数据已经遍历完毕。</p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-173005@2x_1591781440678.png" alt="QQ20200610-173005@2x" style="zoom: 50%;" /><p>再次使用scan命令遍历</p> <img src="https://oss.pencilso.cn/enclosure/QQ20200610-173251@2x_1591781585146.png" alt="QQ20200610-173251@2x" style="zoom:50%;" /><p>我们尝试使用SpringBoot中的RedisTemplate来实现，RedisTemplate已经封装好了方法，直接调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;scanUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">scanUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String keyPattern = <span class="string">&quot;user*&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> queryCount = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> stringRedisTemplate.execute((RedisCallback&lt;Integer&gt;) connection -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> dataCount = <span class="number">0</span>;</span><br><span class="line">        Cursor&lt;<span class="keyword">byte</span>[]&gt; cursor = connection.scan(<span class="keyword">new</span> ScanOptions.ScanOptionsBuilder().match(keyPattern).count(queryCount).build());</span><br><span class="line">        <span class="keyword">while</span> (cursor.hasNext()) &#123;</span><br><span class="line">            String value = <span class="keyword">new</span> String(cursor.next());</span><br><span class="line">            dataCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;dataCount:[&#123;&#125;]&quot;</span>,dataCount);</span><br><span class="line">        <span class="keyword">return</span> dataCount;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果为10万，Redis中的所有user都遍历了出来。</p>]]></content>
    
    
    <summary type="html">Redis 渐进式遍历键</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 核心数据结构</title>
    <link href="https://songlongkuan.com/2020/06/08/redis_core_data_structure/"/>
    <id>https://songlongkuan.com/2020/06/08/redis_core_data_structure/</id>
    <published>2020-06-08T15:23:00.000Z</published>
    <updated>2021-01-31T12:01:59.236Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 具有五种核心数据结构。</p><ol><li>String 结构，该结构用来存储字符串数据。</li><li>Hash 结构，该结构用来存储key value 键值对，可以理解为嵌套map 。</li><li>List 列表，该结构用来存储列表数据，还可以用来当做队列结构，和栈结构。</li><li>Set集合，该结构存储的数据不允许重复。</li><li>ZSet集合，该结构是一个有序的Set集合，排序条件是分值Scores 。</li></ol><a id="more"></a><h2 id="Redis-String数据结构"><a href="#Redis-String数据结构" class="headerlink" title="Redis String数据结构"></a>Redis String数据结构</h2><h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><h6 id="插入字符串键值对"><a href="#插入字符串键值对" class="headerlink" title="插入字符串键值对"></a>插入字符串键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令: set key value </span><br><span class="line"></span><br><span class="line">例如:  set user:zhangsan 10086</span><br></pre></td></tr></table></figure><h6 id="批量插入字符串键值对"><a href="#批量插入字符串键值对" class="headerlink" title="批量插入字符串键值对"></a>批量插入字符串键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令: mset key value key value ....</span><br><span class="line"></span><br><span class="line">例如: mset user:zhangsan 10086  user:lisi 10010 user:wangwu 10000</span><br></pre></td></tr></table></figure><h6 id="插入不存在的键值对"><a href="#插入不存在的键值对" class="headerlink" title="插入不存在的键值对"></a>插入不存在的键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : setnx key value</span><br><span class="line"></span><br><span class="line">例如 : setnx commodity:100 uid56</span><br></pre></td></tr></table></figure><p>该功能可以用作轻量级的分布式锁，当执行指令后，redis会判断是否数据已存在，如果不存在则新增数据并且返回1，否则返回0。</p><p>当线程获取到返回1后才可以继续执行业务，并且要在执行完毕后删除该key，也就是释放锁。</p><p>以防万一线程挂了的情况下造成死锁，理应给key加上超时时间，让redis自行删除超时数据。</p><h6 id="获取单个字符串数据"><a href="#获取单个字符串数据" class="headerlink" title="获取单个字符串数据"></a>获取单个字符串数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : get key </span><br><span class="line"></span><br><span class="line">例如 : get  user:zhangsan</span><br></pre></td></tr></table></figure><h6 id="批量获取字符串数据"><a href="#批量获取字符串数据" class="headerlink" title="批量获取字符串数据"></a>批量获取字符串数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : mget key key ....</span><br><span class="line"></span><br><span class="line">例如 : mget user:zhangsan user:lisi user:wangwu</span><br></pre></td></tr></table></figure><h6 id="删除key"><a href="#删除key" class="headerlink" title="删除key"></a>删除key</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : del key key ....</span><br><span class="line"></span><br><span class="line">例如 : del user:zhangsan user:wangwu</span><br></pre></td></tr></table></figure><h6 id="设置key的超时时间"><a href="#设置key的超时时间" class="headerlink" title="设置key的超时时间"></a>设置key的超时时间</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : expire  key  seconds</span><br><span class="line"></span><br><span class="line">例如 : expire  commodity:100  10</span><br></pre></td></tr></table></figure><h3 id="原子增减"><a href="#原子增减" class="headerlink" title="原子增减"></a>原子增减</h3><h6 id="对数据原子增-1"><a href="#对数据原子增-1" class="headerlink" title="对数据原子增 1"></a>对数据原子增 1</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : incr key</span><br><span class="line"></span><br><span class="line">例如 : incr commodity:share</span><br></pre></td></tr></table></figure><h6 id="对数据原子减-1"><a href="#对数据原子减-1" class="headerlink" title="对数据原子减 1"></a>对数据原子减 1</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : decr key </span><br><span class="line"></span><br><span class="line">例如 : decr commodity:share</span><br></pre></td></tr></table></figure><h6 id="对数据原子增-指定数值"><a href="#对数据原子增-指定数值" class="headerlink" title="对数据原子增 指定数值"></a>对数据原子增 指定数值</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : incrby key increment </span><br><span class="line"></span><br><span class="line">例如 : incrby commodity:share 1000</span><br></pre></td></tr></table></figure><h6 id="对数据原子减-指定数值"><a href="#对数据原子减-指定数值" class="headerlink" title="对数据原子减 指定数值"></a>对数据原子减 指定数值</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : decrby key increment</span><br><span class="line"></span><br><span class="line">例如 : decrby commodity:share 1000</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、计数器，例如点赞次数 、分享次数、预览次数 。</p><p>2、Web集群session共享 </p><p>3、分布式系统全局自增序列</p><h2 id="Redis-Hash数据结构"><a href="#Redis-Hash数据结构" class="headerlink" title="Redis Hash数据结构"></a>Redis Hash数据结构</h2><h3 id="Hash常用操作"><a href="#Hash常用操作" class="headerlink" title="Hash常用操作"></a>Hash常用操作</h3><h6 id="存储哈希表key的键值"><a href="#存储哈希表key的键值" class="headerlink" title="存储哈希表key的键值"></a>存储哈希表key的键值</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hset  key  field  value</span><br><span class="line"></span><br><span class="line">例如 : hset commodity:100 name 蛋黄酥</span><br></pre></td></tr></table></figure><h6 id="插入不存在的哈希表键值对"><a href="#插入不存在的哈希表键值对" class="headerlink" title="插入不存在的哈希表键值对"></a>插入不存在的哈希表键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hsetnx  key  field  value</span><br><span class="line"></span><br><span class="line">例如 : hsetnx commodity:100 edit uid56</span><br></pre></td></tr></table></figure><p>同String结构，当Redis中没有该数据时，会新增并返回1.否则返回0 。</p><h6 id="存储多个键值对"><a href="#存储多个键值对" class="headerlink" title="存储多个键值对"></a>存储多个键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hmset  key  field  value field  value ...</span><br><span class="line"></span><br><span class="line">例如 : hmset commodity:100 name 蛋黄酥 price 10</span><br></pre></td></tr></table></figure><h6 id="获取哈希表key中的键值对数量"><a href="#获取哈希表key中的键值对数量" class="headerlink" title="获取哈希表key中的键值对数量"></a>获取哈希表key中的键值对数量</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hlen  key</span><br><span class="line"></span><br><span class="line">例如 : hlen  commodity:100</span><br></pre></td></tr></table></figure><h6 id="获取哈希表key中的单个field对应的value"><a href="#获取哈希表key中的单个field对应的value" class="headerlink" title="获取哈希表key中的单个field对应的value"></a>获取哈希表key中的单个field对应的value</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hget key field</span><br><span class="line"></span><br><span class="line">例如 : hget commodity:100 edit</span><br></pre></td></tr></table></figure><h6 id="获取哈希表key中的多个field对应的value"><a href="#获取哈希表key中的多个field对应的value" class="headerlink" title="获取哈希表key中的多个field对应的value"></a>获取哈希表key中的多个field对应的value</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hmget key field field</span><br><span class="line"></span><br><span class="line">例如 : hmget commodity:100 edit share</span><br></pre></td></tr></table></figure><h6 id="获取哈希表key中的所有键值数据"><a href="#获取哈希表key中的所有键值数据" class="headerlink" title="获取哈希表key中的所有键值数据"></a>获取哈希表key中的所有键值数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hgetall  key</span><br><span class="line"></span><br><span class="line">例如 : hgetall commodity:100</span><br></pre></td></tr></table></figure><h6 id="对哈希表key中field的value数据原子增"><a href="#对哈希表key中field的value数据原子增" class="headerlink" title="对哈希表key中field的value数据原子增"></a>对哈希表key中field的value数据原子增</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hincrby  key  field  increment</span><br><span class="line"></span><br><span class="line">例如 : hincrby commodity:100 share 100</span><br></pre></td></tr></table></figure><h6 id="删除哈希表key中的键值对"><a href="#删除哈希表key中的键值对" class="headerlink" title="删除哈希表key中的键值对"></a>删除哈希表key中的键值对</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : hdel key field field field....</span><br><span class="line"></span><br><span class="line">例如 : hdel commodity:100 name price</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象缓存</p><p>例如购物车，用户id为key值，field为商品id，value 为加入购物车的数量。</p><p>当用户操作商品数量时，对value进行原子增、原子减。</p><p>hlen 命令获取购物车数量，hgetall获取所有购物车商品id 和 数量 。</p> <img src="https://oss.pencilso.cn/enclosure/WX20200608-231646@2x_1591629454263.png" alt="WX20200608-231646@2x" style="zoom:50%;" /><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点 ：</p><p>1、同类数据归类整合储存，方便数据管理<br>2、相比string操作消耗内存与cpu更小<br>3、相比string储存更节省空间</p><p>缺点：</p><p>1、过期功能不能使用在field上，只能用在key上<br>2、Redis集群架构下不适合大规模使用</p><h2 id="Redis-List数据结构"><a href="#Redis-List数据结构" class="headerlink" title="Redis List数据结构"></a>Redis List数据结构</h2><h3 id="List-常用操作"><a href="#List-常用操作" class="headerlink" title="List 常用操作"></a>List 常用操作</h3><h6 id="插入一个或多个数据到list表头-最左边"><a href="#插入一个或多个数据到list表头-最左边" class="headerlink" title="插入一个或多个数据到list表头 (最左边 )"></a>插入一个或多个数据到list表头 (最左边 )</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : lpush  key  value value ....</span><br><span class="line"></span><br><span class="line">例如 : lpush commodity:hot 100 101 102 103</span><br></pre></td></tr></table></figure><h6 id="插入一个或多个数据到list表尾-最右边"><a href="#插入一个或多个数据到list表尾-最右边" class="headerlink" title="插入一个或多个数据到list表尾 ( 最右边 )"></a>插入一个或多个数据到list表尾 ( 最右边 )</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : rpush key value value ...</span><br><span class="line"></span><br><span class="line">例如 : rpush commodity:hot 99 98 97</span><br></pre></td></tr></table></figure><h6 id="移除并返回表头元素"><a href="#移除并返回表头元素" class="headerlink" title="移除并返回表头元素"></a>移除并返回表头元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : lpop key</span><br><span class="line"></span><br><span class="line">例如 : lpop commodity:hot</span><br></pre></td></tr></table></figure><h6 id="移除并返回表尾元素"><a href="#移除并返回表尾元素" class="headerlink" title="移除并返回表尾元素"></a>移除并返回表尾元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : rpop key</span><br><span class="line"></span><br><span class="line">例如 : rpop commodity:hot</span><br></pre></td></tr></table></figure><h6 id="获取list指定区间的数据"><a href="#获取list指定区间的数据" class="headerlink" title="获取list指定区间的数据"></a>获取list指定区间的数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  lrange  key  start  stop</span><br><span class="line"></span><br><span class="line">例如 : lrange commodity:hot 1 3</span><br></pre></td></tr></table></figure><h3 id="List-阻塞操作"><a href="#List-阻塞操作" class="headerlink" title="List 阻塞操作"></a>List 阻塞操作</h3><h6 id="阻塞弹出表头的元素"><a href="#阻塞弹出表头的元素" class="headerlink" title="阻塞弹出表头的元素"></a>阻塞弹出表头的元素</h6><p>从表头弹出一个元素，若没有数据则会等待， timeout是超时时间 ( 单位为秒 ) ,倘若为0的话，则会一直等待。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : blpop  key  timeout</span><br><span class="line"></span><br><span class="line">例如 : blpop commodity:hot 10 </span><br></pre></td></tr></table></figure><h6 id="阻塞弹出表尾的元素"><a href="#阻塞弹出表尾的元素" class="headerlink" title="阻塞弹出表尾的元素"></a>阻塞弹出表尾的元素</h6><p>从表尾弹出一个元素，若没有数据则会等待， timeout是超时时间 ( 单位为秒 ) ,倘若为0的话，则会一直等待。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : brpop key timeout</span><br><span class="line"></span><br><span class="line">例如 : brpop commodity:hot 10</span><br></pre></td></tr></table></figure><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、Stack 栈数据结构，先进后出。 lpush + lpop </p><p>2、Queue 队列，先进先出。 lpush + rpop </p><p>3、Blocking MQ 阻塞队列 先进先出。lpush + brpop</p><p>4、业务场景：文章流分页查询，lrange  key  start  stop 查询区间数据 。</p><h2 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h2><h3 id="Set集合常用操作"><a href="#Set集合常用操作" class="headerlink" title="Set集合常用操作"></a>Set集合常用操作</h3><h6 id="加入数据到Set集合"><a href="#加入数据到Set集合" class="headerlink" title="加入数据到Set集合"></a>加入数据到Set集合</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : sadd key member member...</span><br><span class="line"></span><br><span class="line">例如 : sadd commodity:101:collect uid56 uid57 uid58 uid59 uid60</span><br></pre></td></tr></table></figure><p>如果数据不存在则新增，并且返回1，否则忽略执行，并且返回0 。</p><h6 id="从Set集合中移除数据"><a href="#从Set集合中移除数据" class="headerlink" title="从Set集合中移除数据"></a>从Set集合中移除数据</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : srem key member member...</span><br><span class="line"></span><br><span class="line">例如：srem commodity:101:collect uid56 uid57</span><br></pre></td></tr></table></figure><h6 id="获取集合中所有元素"><a href="#获取集合中所有元素" class="headerlink" title="获取集合中所有元素"></a>获取集合中所有元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  smembers  key</span><br><span class="line"></span><br><span class="line">例如 : smembers  commodity:101:collect</span><br></pre></td></tr></table></figure><h6 id="获取集合key的元素个数"><a href="#获取集合key的元素个数" class="headerlink" title="获取集合key的元素个数"></a>获取集合key的元素个数</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  scard key</span><br><span class="line"></span><br><span class="line">例如 : scard commodity:101:collect</span><br></pre></td></tr></table></figure><h6 id="判断Set集合中是否存在元素"><a href="#判断Set集合中是否存在元素" class="headerlink" title="判断Set集合中是否存在元素"></a>判断Set集合中是否存在元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sismember key  member</span><br><span class="line"></span><br><span class="line">例如 : sismember commodity:101:collect uid58</span><br></pre></td></tr></table></figure><p>存在则返回1，不存在则返回0。</p><h6 id="从Set集合随机取出指定数量元素"><a href="#从Set集合随机取出指定数量元素" class="headerlink" title="从Set集合随机取出指定数量元素"></a>从Set集合随机取出指定数量元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : srandmember  key count</span><br><span class="line"></span><br><span class="line">例如 : srandmember commodity:101:collect 2</span><br></pre></td></tr></table></figure><h6 id="从Set集合随机取出指定数量元素，并删除"><a href="#从Set集合随机取出指定数量元素，并删除" class="headerlink" title="从Set集合随机取出指定数量元素，并删除"></a>从Set集合随机取出指定数量元素，并删除</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : spop  key count</span><br><span class="line"></span><br><span class="line">例如 : spop commodity:101:collect 2</span><br></pre></td></tr></table></figure><h3 id="Set运算操作"><a href="#Set运算操作" class="headerlink" title="Set运算操作"></a>Set运算操作</h3><p>先初始化三个Set集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd commodity:101:collect uid56 uid57 uid58</span><br><span class="line"></span><br><span class="line">sadd commodity:102:collect uid57 uid58 uid59</span><br><span class="line"></span><br><span class="line">sadd commodity:103:collect uid57 uid60 uid61</span><br></pre></td></tr></table></figure><p><img src="https://oss.pencilso.cn/enclosure/QQ20200609-114153@2x_1591674138390.png" alt="QQ20200609-114153@2x"></p><h6 id="交集运算"><a href="#交集运算" class="headerlink" title="交集运算"></a>交集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sinter key key ...</span><br><span class="line"></span><br><span class="line">例如 : sinter commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>交集运算可以在多个集合中，寻找共同的数据，比如这三个集合中都有uid57，所以交集运算结果能能到uid57。</p><h6 id="交集运算-生成新的集合"><a href="#交集运算-生成新的集合" class="headerlink" title="交集运算 生成新的集合"></a>交集运算 生成新的集合</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sinterstore newkey  key key...</span><br><span class="line"></span><br><span class="line">例如 : sinterstore commodity:101-102-103:collect:sinter commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>该指令会将其他集合有交集的数据放到新的集合中，如上指令执行后，会生成一个 “commodity:101-102-103:collect:sinter” 集合。</p><h6 id="并集运算"><a href="#并集运算" class="headerlink" title="并集运算"></a>并集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sunion key  key....</span><br><span class="line"></span><br><span class="line">例如 : sunion commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>该指令会将多个集合的数据组合成一起返回</p><h6 id="并集运算-生成新的集合"><a href="#并集运算-生成新的集合" class="headerlink" title="并集运算 生成新的集合"></a>并集运算 生成新的集合</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  sunionstore newkey  key key....</span><br><span class="line"></span><br><span class="line">例如 : sunionstore commodity:101-102-103:collect:sunion commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>该指令会将多个集合的数据组成一个新的集合，如上指令执行后，会生成一个 “commodity:101-102-103:collect:sunion” 集合。</p><h6 id="差集运算"><a href="#差集运算" class="headerlink" title="差集运算"></a>差集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : sdiff  key key ....</span><br><span class="line"></span><br><span class="line">例如 : sdiff  commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>差集运算是以第一个key的集合为基准，与其他集合进行匹配，最后筛选出不在其他集合中的数据。</p><p>如上指令执行后，得到的结果是uid56，因为其他两个集合都没有uid56，所以uid56被筛选出来了。</p><h6 id="差集运算-生成新的集合"><a href="#差集运算-生成新的集合" class="headerlink" title="差集运算 生成新的集合"></a>差集运算 生成新的集合</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : sdiffstore  newkey  key key...</span><br><span class="line"></span><br><span class="line">例如 : sdiffstore commodity:101-102-103:collect:diff commodity:101:collect commodity:102:collect commodity:103:collect </span><br></pre></td></tr></table></figure><p>该指令会将差集数据生成到新的集合中 ，如上指令会生成一个 “commodity:101-102-103:collect:diff ” 的集合。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、列表数据不重复，点赞用户列表、分享用户列表 等等 。</p><p>2、随机抽奖，利用srandmember 、spop 指令随机抽取。</p><p>3、并集运算、交集运算、差集运算。</p><h2 id="ZSet-数据结构"><a href="#ZSet-数据结构" class="headerlink" title="ZSet 数据结构"></a>ZSet 数据结构</h2><h3 id="ZSet-常用操作"><a href="#ZSet-常用操作" class="headerlink" title="ZSet 常用操作"></a>ZSet 常用操作</h3><h6 id="添加带分值元素"><a href="#添加带分值元素" class="headerlink" title="添加带分值元素"></a>添加带分值元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zadd key score member score member ...</span><br><span class="line"></span><br><span class="line">例如 : zadd article:hotlist 100 article1 101 article2 102 article3</span><br></pre></td></tr></table></figure><h6 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zrem key member member...</span><br><span class="line"></span><br><span class="line">例如 : zrem article:hotlist article1 article2</span><br></pre></td></tr></table></figure><h6 id="查询元素的分值"><a href="#查询元素的分值" class="headerlink" title="查询元素的分值"></a>查询元素的分值</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zscore key member</span><br><span class="line"></span><br><span class="line">例如 : zscore article:hotlist article3</span><br></pre></td></tr></table></figure><h6 id="对元素分值增加"><a href="#对元素分值增加" class="headerlink" title="对元素分值增加"></a>对元素分值增加</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zincrby key increment member</span><br><span class="line"></span><br><span class="line">例如 : zincrby article:hotlist 100 article3</span><br></pre></td></tr></table></figure><h6 id="获取集合中的元素个数"><a href="#获取集合中的元素个数" class="headerlink" title="获取集合中的元素个数"></a>获取集合中的元素个数</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zcard key</span><br><span class="line"></span><br><span class="line">例如 : zcard article:hotlist </span><br></pre></td></tr></table></figure><h6 id="正序获取区间元素"><a href="#正序获取区间元素" class="headerlink" title="正序获取区间元素"></a>正序获取区间元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zrange key start stop </span><br><span class="line"></span><br><span class="line">例如 : zrange article:hotlist  0 1</span><br></pre></td></tr></table></figure><p>如果需要连分值一起获取的话，在指令后面加上withscores即可，例: zrange article:hotlist  0 1 withscores</p><h6 id="倒序获取区间元素"><a href="#倒序获取区间元素" class="headerlink" title="倒序获取区间元素"></a>倒序获取区间元素</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zrevrange  key start stop</span><br><span class="line"></span><br><span class="line">例如 : zrevrange  article:hotlist 0 1</span><br></pre></td></tr></table></figure><h3 id="ZSet-集合操作"><a href="#ZSet-集合操作" class="headerlink" title="ZSet 集合操作"></a>ZSet 集合操作</h3><p>准备两个集合数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zincrby article:hotlist:20200608 2 article1</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200608 1 article2</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200608 1 article3</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 4 article1</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 2 article2</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 1 article6</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 1 article4</span><br><span class="line"></span><br><span class="line">zincrby article:hotlist:20200609 1 article3</span><br></pre></td></tr></table></figure><p>这时候数据应该是这样的  <img src="https://oss.pencilso.cn/enclosure/QQ20200609-143312@2x_1591684411678.png" alt="20200608"></p><p> <img src="https://oss.pencilso.cn/enclosure/QQ20200609-143537@2x_1591684569390.png" alt="20200609"></p><h6 id="并集运算-1"><a href="#并集运算-1" class="headerlink" title="并集运算"></a>并集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 :  zunionstore newkey numkeys key key ...</span><br><span class="line"></span><br><span class="line">例如 : zunionstore article:hotlist:20200608-20200609  2 article:hotlist:20200608 article:hotlist:20200609</span><br></pre></td></tr></table></figure><p>指令中numkeys 用来表示要计算的集合数量。</p><p>将多个集合组合起来，并且会叠加分值，生成一个新的集合，如上执行后，会生成新的 “article:hotlist:20200608-20200609” 集合。</p><h6 id="交集运算-1"><a href="#交集运算-1" class="headerlink" title="交集运算"></a>交集运算</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 : zinterstore newkey numkeys key key ...</span><br><span class="line"></span><br><span class="line">例如 : zinterstore article:hotlist:insterstore 2 article:hotlist:20200608 article:hotlist:20200609</span><br></pre></td></tr></table></figure><p>指令中numkeys 用来表示要计算的集合数量。</p><p>将多个集合进行交集运算，并且会叠加分值，生成一个新的集合，如上执行后，会生成新的 “article:hotlist:insterstore” 集合。</p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、排行榜，通过分值让redis自行排序。</p><p>2、近期排行榜，通过redis并集计算，生成近期排行榜。</p>]]></content>
    
    
    <summary type="html">Redis 核心数据结构、常用命令</summary>
    
    
    
    <category term="redis" scheme="https://songlongkuan.com/categories/redis/"/>
    
    
    <category term="redis" scheme="https://songlongkuan.com/tags/redis/"/>
    
  </entry>
  
</feed>
