<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋龙宽|个人博客</title>
  
  
  <link href="https://songlongkuan.com/atom.xml" rel="self"/>
  
  <link href="https://songlongkuan.com/"/>
  <updated>2021-01-07T01:34:32.774Z</updated>
  <id>https://songlongkuan.com/</id>
  
  <author>
    <name>宋龙宽|个人博客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java之ThreadLocal</title>
    <link href="https://songlongkuan.com/2020/09/12/java_threadlocal/"/>
    <id>https://songlongkuan.com/2020/09/12/java_threadlocal/</id>
    <published>2020-09-12T07:30:16.000Z</published>
    <updated>2021-01-07T01:34:32.774Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</p><h2 id="ThreadLocal的简单应用"><a href="#ThreadLocal的简单应用" class="headerlink" title="ThreadLocal的简单应用"></a>ThreadLocal的简单应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数据:&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行前数后:&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread-<span class="number">1</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">1</span> 执行前数后:张三</span><br><span class="line">thread-<span class="number">2</span> 执行前数据:<span class="literal">null</span></span><br><span class="line">thread-<span class="number">2</span> 执行前数后:李四</span><br></pre></td></tr></table></figure><p>由此可以得出结论，threadLocal是线程之间隔离的数据存储方式。</p><a id="more"></a><h2 id="ThreadLocal-的问题"><a href="#ThreadLocal-的问题" class="headerlink" title="ThreadLocal 的问题"></a>ThreadLocal 的问题</h2><p>ThreadLocal在线程池中应用的话是会产生问题的，我们知道线程池它是会对线程进行重复利用，也就是说可能放几个任务到线程池中执行最后都是由一个KLT线程去运行的。</p><p>线程池+ThreadLocal问题重现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：张三</span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><p>可以观察到，runnable2执行的时候拿到了runnable1置入的”张三”，这时候已经不是逻辑上的隔离了，因为线程复用导致ThreadLocal里面的数据没有释放，从而导致下一次在线程池运行任务的时候，获取到的数据还是上一个线程置入的数据。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案-1"></a>解决方案-1</h2><p>第一种解决方案，就是在线程执行之前清空一下ThreadLocal，至于线程执行结束的话，系统会自动清理。</p><p>改造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">   <span class="comment">//设置为nulll</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">    <span class="comment">//设置为null</span></span><br><span class="line">    threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span>+threadLocal.get());</span><br><span class="line">    threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span>+threadLocal.get());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行输出结果如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案-2"></a>解决方案-2</h2><p>第二种解决方案的话，主要是从线程池入手，线程池有一个执行线程任务前的拦截方法，可以在Runnable执行之前执行。</p><p>再次改造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable1 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行前数据：&quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.set(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;runnable2 执行后数据：&quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>)) &#123;</span><br><span class="line">          <span class="comment">//重写beforeExecute方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">                <span class="comment">//统一把ThreadLocal设置为null</span></span><br><span class="line">                threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        threadPoolExecutor.execute(runnable1);</span><br><span class="line">        threadPoolExecutor.execute(runnable2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果输出如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runnable1 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable1 执行后数据：张三</span><br><span class="line">runnable2 执行前数据：<span class="literal">null</span></span><br><span class="line">runnable2 执行后数据：李四</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal实现的原理"><a href="#ThreadLocal实现的原理" class="headerlink" title="ThreadLocal实现的原理"></a>ThreadLocal实现的原理</h2><h3 id="ThreadLocal-的set方法"><a href="#ThreadLocal-的set方法" class="headerlink" title="ThreadLocal 的set方法"></a>ThreadLocal 的set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//如果map已创建  则置入数据 </span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//如果map还未创建 则创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的createMap方法"><a href="#ThreadLocal的createMap方法" class="headerlink" title="ThreadLocal的createMap方法"></a>ThreadLocal的createMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实例化一个ThreadLocalMap对象 并且赋值到thread.threadLocals字段里面</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal的getMap方法"><a href="#ThreadLocal的getMap方法" class="headerlink" title="ThreadLocal的getMap方法"></a>ThreadLocal的getMap方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//直接获取的thread里面的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thread中的threadLocals字段"><a href="#Thread中的threadLocals字段" class="headerlink" title="Thread中的threadLocals字段"></a>Thread中的threadLocals字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal总结"><a href="#ThreadLocal总结" class="headerlink" title="ThreadLocal总结"></a>ThreadLocal总结</h3><p>ThreadLocal其实就是封装了调用Thread对象中ThreadLocalMap类型的threadlocals变量的过程。</p><p>至于ThreadLocalMap其实就是一个简化的hashmap。</p><p>如果说程序的调用链路比较长，假设一个请求需要调用10个方法，而只有第一个方法和最后一个方法需要一个”userId” 数据，如果我们给10个方法都加上”userId” 参数进行传递固然是可以解决，但是冗余了代码，而使用ThreadLocal后只需要在第一个和最后一个方法种调用ThreadLocal即可。</p><p>再比如说Mybatis的分页插件 PageHelper.startPage就是通过ThreadLocal把page参数放到了ThreadLocal中。</p><h2 id="ThreadLocal在线程间传递的问题"><a href="#ThreadLocal在线程间传递的问题" class="headerlink" title="ThreadLocal在线程间传递的问题"></a>ThreadLocal在线程间传递的问题</h2><p>ThreadLocal是线程独享的数据，是线程安全的，但是多线程开发过程中，可能会存在将一个线程的ThreadLocal数据传递给子线程的ThreadLocal。</p><h3 id="举例问题复现"><a href="#举例问题复现" class="headerlink" title="举例问题复现"></a>举例问题复现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------  输出结果如下  ----------</span><br><span class="line">当前线程中获取用户ID:<span class="number">1000</span></span><br><span class="line">子线程中获取用户ID：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>我们假设需要启动子线程去执行一些耗时任务，而子线程中需要ThreadLocal中的数据，那么这个时候子线程是获取不到的，当然我们也可以通过参数传递的方式把用户id传到thread对象中。<br>再举例一个场景，对请求的链路追踪，如果在程序在接到请求后，用子线程执行了某些耗时任务，那么也会追踪不到子线程中执行的哪些方法，因为ThreadLocal无法传递到子线程。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们将ThreadLocal 换成 InheritableThreadLocal 即可解决，如下代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------  输出结果如下  ----------</span><br><span class="line">当前线程中获取用户ID:<span class="number">1000</span></span><br><span class="line">子线程中获取用户ID：<span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="InheritableThreadLocal-源码解析-、Thread部分源码"><a href="#InheritableThreadLocal-源码解析-、Thread部分源码" class="headerlink" title="InheritableThreadLocal 源码解析 、Thread部分源码"></a>InheritableThreadLocal 源码解析 、Thread部分源码</h3><p>查看InheritableThreadLocal源码的时候，能看到InheritableThreadLocal只是继承自ThreadLocal 并且重写了三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继承可继承的inheritableThreadLocals 时会调用到该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写获取map方法，返回可继承的map对象</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写创建map方法，把创建出来的map赋值给可继承的 t.inheritableThreadLocals</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想弄明白InheritableThreadLocal的实现原理，需要先了解了解Thread的源码，接下来先写部分Thread的源码解析。<br>Thread的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 不可继承，ThreadLocal就是用的这个成员变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map -&gt; 可继承，InheritableThreadLocal 用的是这个变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>在Thread的构造方法中，会调用一个初始化方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//inheritThreadLocals 是否继承，默认为true   </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//现在的代码执行阶段还在Thread构造方法中调用的，所以这里currentThread 获取的还是当前线程，并不是未来将要开启的子线程。当前线程就是未来要开启的子线程的父级。</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果inheritThreadLocals = true 并且 父级的inheritableThreadLocals对象不为空</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">//根据父级的inheritableThreadLocals 创建一个新的map，并且赋值给新的Thread.inheritableThreadLocals 。</span></span><br><span class="line">               <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                   ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据父级的map，创建新的map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//ThreadLocalMap 的构造方法（复制父map的内容）</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//map中的table（数组）</span></span><br><span class="line">     Entry[] parentTable = parentMap.table;</span><br><span class="line">     <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">     setThreshold(len);</span><br><span class="line">     <span class="comment">//创建新的数组，这个tbale变量在ThreadLocalMap的成员属性中</span></span><br><span class="line">     table = <span class="keyword">new</span> Entry[len];    <span class="comment">//this.table = new Entry[len];</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//遍历数组</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        </span><br><span class="line">         Entry e = parentTable[j];</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从Entry中，拿到ThreadLocal</span></span><br><span class="line">             ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//调用ThreadLocal.childValue 方法， InheritableThreadLocal就重写了这个方法</span></span><br><span class="line">                 Object value = key.childValue(e.value);</span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">//接下来就是计算hash，然后决定将key放到哪里。</span></span><br><span class="line">                 Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                 <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                 <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                     h = nextIndex(h, len);</span><br><span class="line">                 table[h] = c;</span><br><span class="line">                 size++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure><p>以上是Thread对 可继承的inheritableThreadLocals 变量所做的一系列操作过程。</p><p>InheritableThreadLocal 总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用InheritableThreadLocal.set方法，而set方法第一次执行会调用createMap方法，而createMap已经被InheritableThreadLocal这个类重写。</span></span><br><span class="line">      <span class="comment">//所以创建出来的map会存储在inheritableThreadLocals变量中</span></span><br><span class="line">      threadLocal.set(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//这个get方法，里面实际是调用了一次getMap方法，而getMap也被inheritableThreadLocals重写，返回的是inheritableThreadLocals变量map。所以能拿到值。</span></span><br><span class="line">      System.out.println(<span class="string">&quot;当前线程中获取用户ID:&quot;</span> + threadLocal.get());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//new Thread会执行一系列的初始化操作</span></span><br><span class="line">      <span class="comment">//1、判断inheritableThreadLocals=true （默认为true）</span></span><br><span class="line">      <span class="comment">//2、判断parent.inheritableThreadLocals !=null (我们放了一个id:1000在里面，所以不为空)</span></span><br><span class="line">      <span class="comment">//3、根据parent.inheritableThreadLocals 创建新的map对象，并且赋值到新的Thread.inheritableThreadLocals变量中（new Thread（）中)</span></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这个时候，Thread.inheritableThreadLocals已经继承了父级的数据，所以能拿到。</span></span><br><span class="line">          System.out.println(<span class="string">&quot;子线程中获取用户ID：&quot;</span> + threadLocal.get());</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ThreadLocal是一个用来在当前线程种存储自定义数据的，它可以做到线程与线程之间的数据隔离。</summary>
    
    
    
    <category term="Java" scheme="https://songlongkuan.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://songlongkuan.com/tags/Java/"/>
    
    <category term="ThreadLocal" scheme="https://songlongkuan.com/tags/ThreadLocal/"/>
    
  </entry>
  
</feed>
